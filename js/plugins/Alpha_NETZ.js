/*
 * Copyright (c) 2025 Vladimir Skrypnikov (Pheonix KageDesu)
 * <https://kdworkshop.net/>
 *
* License: Creative Commons 4.0 Attribution, Share Alike, Commercial
 */


/*:
 * @plugindesc (v.0.9 BETA)[PRO] Multiplayer for RPG Maker
 * @author Pheonix KageDesu
 * @target MZ MV
 * @url https://kdworkshop.net/plugins/alpha-net-z/
 *
 * 
 * @help
 * ---------------------------------------------------------------------------
 *
 * Alpha NET Z plugin content:
 * Plugin: js/plugins/Alpha_NETZ.js
 * Styles: css/
 *      -anet_chat.css
 *      -anet.css
 * Images: img/Alpha_NETZ/ *all files*
 * Data: data/ANETZ/ *all files*
 *
 *
 * GUIDE:
 * https://github.com/KageDesu/Alpha-NET-Z/wiki
 *
 * ---------------------------------------------------------------------------
 
 *
 * If you like my Plugins, want more and offten updates, please support me
 * on one of the following platforms:
 *
 * Boosty:
 *     https://boosty.to/kagedesu
 * Patreon:
 *      https://www.patreon.com/KageDesu
 * YouTube:
 *      https://www.youtube.com/channel/UCA3R61ojF5vp5tGwJ1YqdgQ?
 *
 *
 * License: Creative Commons 4.0 Attribution, Share Alike, Commercial
 *
 * @param ANETZ
 * @text ANETZ
 * 
 * 

 * 
 * 
 * @param connection:s
 * @text Connection
 * @type struct<LConnectionSettings>
 * @default {"serverIp":"anetzglobal.ru","serverPort":"3034","isHttpsConnection:b":"false"}
 * @desc Connection to server configuration
 * 
 * 

 * 
 * 
 * @param isCustomGameId:b
 * @parent connection:s
 * @type boolean
 * @text Use Custom Game ID?
 * @default false
 * @desc You can specify own (unique) GameId for your game. Only players with the games with same gameId can join each other.
 * 
 * 

 * 
 * 
 * @param customGameId
 * @parent isCustomGameId:b
 * @text Custom Game ID
 * @default
 * @desc CAN'T be Empty. Should be UNIQUE for your game. Example: SuperGame1000FromJohnDoe
 * 
 * 

 * 
 * 
 * @param isQuickDevConnectionAllowed:b
 * @parent connection:s
 * @type boolean
 * @text Allow Quick Connection?
 * @default false
 * @desc For devs. Press C for quick connect right from Title Menu
 * 
 * 

 * 
 * 
 * @param isEndGameWhenHostIsLeave:b
 * @parent connection:s
 * @type boolean
 * @text End when the host is disconnected?
 * @default true
 * @desc If false, other players will continue game (the host will be transferred to another)
 * 
 * 

 * 
 * 
 * @param spacer|gamesettings @text‏‏‎ ‎@desc ===============================================
 * 
 * 

 * 
 * 
 * @param gameModeSettingsGroup
 * @text Multiplayer Settings
 * 
 * 

 * 
 * 
 * @param netGameTitleCmd:b
 * @parent gameModeSettingsGroup
 * @type boolean
 * @text Add Network command?
 * @default true
 * @desc Adds Network command to Main Menu on Title Screen
 * 
 * 

 * 
 * 
 * @param onlySameMap:b
 * @parent gameModeSettingsGroup
 * @type boolean
 * @text Wait Map Transfer?
 * @default false
 * @desc When player transferred to the new map he will wait until all players not transfered on same map.
 * 
 * 

 * 
 * 
 * @param isCustomStartMap:b
 * @parent onlySameMap:b
 * @type boolean
 * @text Is Custom Start?
 * @default false
 * @desc Each Actor can use own custom start map and position. Read Wiki for more info.
 * 
 * 

 * 
 * 
 * @param singlePlayerAllowed:b
 * @parent gameModeSettingsGroup
 * @type boolean
 * @text New Game Allowed?
 * @default true
 * @desc If false, the menu item "New Game" will not be displayed in title menu
 * 
 * 

 * 
 * 
 * @param isReadyStatusCheck:b
 * @parent gameModeSettingsGroup
 * @type boolean
 * @text Is Check Ready?
 * @default false
 * @desc If true, each player should set Ready status before host can start game room
 * 
 * 

 * 
 * 
 * @param roomFilter:b
 * @parent gameModeSettingsGroup
 * @type boolean
 * @text Rooms Filter?
 * @on ON
 * @off OFF
 * @default false
 * @desc If filter is ON, you can see only this (same) game rooms in lobby
 * 
 * 

 * 
 * 
 * @param joinStartedAllowed:b
 * @parent gameModeSettingsGroup
 * @type boolean
 * @text Join to Game Allowed?
 * @default false
 * @desc If true, player can join in rooms with already started game
 * 
 * 

 * 
 * 
 * @param joinStartedAndLoadedAllowed:b
 * @parent joinStartedAllowed:b
 * @type boolean
 * @text Join to Loaded Game?
 * @default true
 * @desc If true, player can join in rooms with started and loaded from savefile game
 * 
 * 
 * 

 * 
 * 
 * @param onJoinCE:int
 * @parent joinStartedAllowed:b
 * @text On Player Joined CE
 * @type common_event
 * @default 0
 * @desc That common event will be called when player joined game. CE called ONLY for this player.
 * 
 * 

 * 
 * 
 * @param isJoinRandomOptionExists:b
 * @parent gameModeSettingsGroup
 * @type boolean
 * @text Join Random Room Option
 * @default true
 * @desc Show the Join Random Room option?
 * 
 * 

 * 
 * 
 * @param saveLoadGame:b
 * @parent gameModeSettingsGroup
 * @type boolean
 * @text Save and Load Allowed?
 * @on YES
 * @off NO
 * @default true
 * @desc Can player save and load network game?
 * 
 * 

 * 
 * 
 * @param networkStatusIcons:b
 * @parent gameModeSettingsGroup
 * @type boolean
 * @text Is show network icons?
 * @on YES
 * @off NO
 * @default true
 * @desc Network current state icons above players (menu, event, battle, etc...)
 * 
 * 

 * 
 * 
 * @param isMapEncountersGlobal:b
 * @parent gameModeSettingsGroup
 * @type boolean
 * @text Is Encounters is Global?
 * @on YES, for all
 * @off NO, for player
 * @default false
 * @desc Is Map Encounters are for all players on map?
 * 
 * 

 * 
 * 
 * @param spacer|playerssettings @text‏‏‎ ‎@desc ===============================================
 * 
 * 

 * 
 * 
 * @param playersSettingsGroup
 * @text Players Settings
 * 
 * 

 * 
 * 
 * @param actorsForNetwork:intA
 * @parent playersSettingsGroup
 * @type actor[]
 * @text Actors
 * @default ["1","2","3","4"]
 * @desc Available actors for network game players.
 * 
 * 

 * 
 * 
 * @param maxPlayersInRoom:int
 * @text Players per Room
 * @parent playersSettingsGroup
 * @type number
 * @min 2
 * @default 4
 * @desc Maximum players in one Room. Should be <= Actors count. Max 2 for BASIC version.
 * 
 * 

 * 
 * 
 * @param isActorSelectionAllowed:b
 * @parent playersSettingsGroup
 * @text Actor selection?
 * @type boolean
 * @default true
 * @desc Can player select actor in lobby?
 * 
 * 

 * 
 * 
 * @param isSinglePlayerStartAllowed:b
 * @parent playersSettingsGroup
 * @text One player start?
 * @type boolean
 * @default true
 * @desc If in room only 1 player (host), he can start game alone?
 * 
 * 

 * 
 * 
 * @param playerActorNameType
 * @parent playersSettingsGroup
 * @text Player Name for Actor
 * @type select
 * @option Not Show
 * @option Instead Name
 * @option Instead Nickname
 * @default Instead Nickname
 * @desc Show network player name instead of his Actor name (or nickname)
 * 
 * 

 * 
 * 
 * @param playerLeaveGameCommonEvent:int
 * @parent playersSettingsGroup
 * @text On Player Disconnect CE
 * @type common_event
 * @default 0
 * @desc That common event will be called when somebody leave (disconnect) game. 0 - nothing
 * 
 * 

 * 
 * 
 * @param isAllowCollsBetweenNetChars:b
 * @parent playersSettingsGroup
 * @text Players Collisions
 * @type boolean
 * @default false
 * @desc Allows collisions on map between players characters?
 * 
 * 

 * 
 * 
 * @param globalData:s
 * @text Global Data
 * @type struct<LGlobalData>
 * @default {"globalVariablesIds:intA":"[]","globalSwitchesIds:intA":"[]"}
 * @desc All this data will be automatically synchronized between all players
 * 
 * 

 * 
 * 
 * @param spacer|othersettings @text‏‏‎ ‎@desc ===============================================
 * 
 * 
 * 

 * 
 * 
 * @param otherSettingsGroup
 * @text Other Settings
 * 
 * 

 * 
 * 
 * @param textInputMaxLength:i
 * @text Input Max Length
 * @parent otherSettingsGroup
 * @type number
 * @min 3
 * @default 12
 * @desc Input field (room or player name) max characters count
 * 
 * 

 * 
 * 
 * @param localeDB:struct
 * @text Localization
 * @parent otherSettingsGroup
 * @type struct<LLocaleDB>
 * @default {"network":"Network","createRoom":"Create Room","joinRoom":"Join Room","joinRandomRoom":"Join Random Room","settings":"Settings","start":"Start","leave":"Leave","joinGame":"Join Game","ready":"Ready","character":"Character","close":"Close","welcome":"Welcome, %1","playersCount":"Players on server: %1"}
 * @desc You can translate or change embedded plugin text
 * 
 * 

 * 
 * 
 * @param spacer|endHolder @text‏‏‎ ‎@desc ===============================================
 * 

@command EventCommandSelector
@text Command Options
@desc Next Event Command network start options




@arg whoSelector
@text Who can start
@type select
@option All
@option Master
@option Master Except
@option Actor List
@option Actor List Except
@default All




@arg actorList
@text Actors List
@type actor[]
@default []
@desc Actors list for 'Execute For' if you select 'Actor List' or 'Actor List Except'




@arg scope
@text Scope
@type select
@option Same map
@option All world
@default Same map
@desc For which players will the virtual command be executed?




@arg executeMode
@text Execute Mode
@type select
@option Auto
@option Virtual
@option Common Event
@default Auto
@desc How this command will be exectuted for other players. Read Wiki for more info
@desc_CH 此命令将如何为其他玩家执行。有关更多信息，请阅读维基百科

@command EventStartOptions
@text Event Options
@desc Event network start options




@arg whoSelector
@text Who can start
@type select
@option All
@option Master
@option Master Except
@option Actor List
@option Actor List Except
@default All




@arg actorList
@text Actors List
@type actor[]
@default []
@desc Actors list for 'Execute For' if you select 'Actor List' or 'Actor List Except'




@arg lockMode
@text Lock Event?
@type boolean
@default false
@desc If true - event will be locked while executed. Nobody can't start locked event




@arg sharedMode
@text Shared Mode
@type select
@option No
@option Strict
@option Optional
@desc Shared event - starts for all players simultaneously, synchronized commands execution
@default No


@command SharedBattle
@text Set Shared Battle
@desc Make next Battle Processing command shared between all players




@arg battleId
@text ID
@default
@desc Unique battle ID. Empty - not shared battle (by default)
@desc_CH 独特的战斗编号。为空 - 非共享战斗（默认）

@command EMPTY_HOLDER
@text ‏
@desc
@default


 */
/*:ru
 * @plugindesc (v.0.9 BETA)[PRO] Multiplayer for RPG Maker
 * @author Pheonix KageDesu
 * @target MZ MV
 * @url https://kdworkshop.net/plugins/alpha-net-z/
 *
 * 
 * @help
 * ---------------------------------------------------------------------------
 * Содержимое плагина (необходимые файлы):
 *
 * Файл плагина: js/plugins/Alpha_NETZ.js
 * Стили: css/
 *      -anet_chat.css
 *      -anet.css
 * Изображения: img/Alpha_NETZ/ *все файлы*
 * Данные (настройки): data/ANETZ/ *все файлы*
 *
 * Скопируйте эти файлы и папки в себе проект чтобы Alpha NET Z работал корректно
 *
 *
 * РУКОВОДСТВО:
 * https://github.com/KageDesu/Alpha-NET-Z/wiki
 *
 * ---------------------------------------------------------------------------
 
 *
 * Если вам нравятся мои плагины, вы хотите больше и частых обновлений,
 * пожалуйста, поддержите меня на одной из следующих платформ:
 *
 * Boosty:
 *     https://boosty.to/kagedesu
 * Patreon:
 *      https://www.patreon.com/KageDesu
 * YouTube:
 *      https://www.youtube.com/channel/UCA3R61ojF5vp5tGwJ1YqdgQ?
 *
 *
 * License: Creative Commons 4.0 Attribution, Share Alike, Commercial
 *
 * @param ANETZ
 * @text ANETZ
 * 
 * 

 * 
 * 
 * @param connection:s
 * @text Соединение
 * @type struct<LConnectionSettings>
 * @default {"serverIp":"anetzglobal.ru","serverPort":"3034","isHttpsConnection:b":"false"}
 * @desc Настройки соединения с сервером
 * 
 * 

 * 
 * 
 * @param isCustomGameId:b
 * @parent connection:s
 * @type boolean
 * @text Использовать пользовательский идентификатор игры?
 * @default false
 * @desc Вы можете указать собственный (уникальный) идентификатор игры для вашей игры. Только игроки с играми с одинаковым идентификатором игры могут присоединяться друг к другу.
 * 
 * 

 * 
 * 
 * @param customGameId
 * @parent isCustomGameId:b
 * @text Пользовательский идентификатор игры
 * @default
 * @desc НЕ может быть пустым. Должен быть УНИКАЛЬНЫМ для вашей игры. Пример: SuperGame1000FromJohnDoe
 * 
 * 

 * 
 * 
 * @param isQuickDevConnectionAllowed:b
 * @parent connection:s
 * @type boolean
 * @text Быстрое соединение?
 * @default false
 * @desc Для разработчиков. Нажмите C для быстрого подключения прямо из главного меню
 * 
 * 

 * 
 * 
 * @param isEndGameWhenHostIsLeave:b
 * @parent connection:s
 * @type boolean
 * @text Завершить, когда хост отключается?
 * @default true
 * @desc Если ложь, другие игроки продолжат игру (хост будет передан другому)
 * 
 * 

 * 
 * 
 * @param spacer|gamesettings @text‏‏‎ ‎@desc ===============================================
 * 
 * 

 * 
 * 
 * @param gameModeSettingsGroup
 * @text Настройки мультиплеера
 * 
 * 

 * 
 * 
 * @param netGameTitleCmd:b
 * @parent gameModeSettingsGroup
 * @type boolean
 * @text Добавить команду Network?
 * @default true
 * @desc Добавляет команду Network в главное меню на титульном экране
 * 
 * 

 * 
 * 
 * @param onlySameMap:b
 * @parent gameModeSettingsGroup
 * @type boolean
 * @text Ожидать переход на карту?
 * @default false
 * @desc Когда игрок перемещается на новую карту, он будет ждать, пока все игроки не переместятся на ту же карту.
 * 
 * 

 * 
 * 
 * @param isCustomStartMap:b
 * @parent onlySameMap:b
 * @type boolean
 * @text Пользовательский старт?
 * @default false
 * @desc Каждый персонаж может использовать свою собственную пользовательскую стартовую карту и позицию. Подробнее читайте в Вики.
 * 
 * 

 * 
 * 
 * @param singlePlayerAllowed:b
 * @parent gameModeSettingsGroup
 * @type boolean
 * @text Разрешена новая игра?
 * @default true
 * @desc Если ВЫКЛ, пункт меню "Новая игра" не будет отображаться в титульном меню
 * 
 * 

 * 
 * 
 * @param isReadyStatusCheck:b
 * @parent gameModeSettingsGroup
 * @type boolean
 * @text Проверять готовность?
 * @default false
 * @desc Если ВКЛ, каждый игрок должен установить статус Готов, прежде чем хост сможет запустить игровую комнату
 * 
 * 

 * 
 * 
 * @param roomFilter:b
 * @parent gameModeSettingsGroup
 * @type boolean
 * @text Фильтр комнат?
 * @on ON
 * @off OFF
 * @default false
 * @desc Если фильтр ВКЛ, вы можете видеть только эти (одинаковые) игровые комнаты в лобби
 * 
 * 

 * 
 * 
 * @param joinStartedAllowed:b
 * @parent gameModeSettingsGroup
 * @type boolean
 * @text Присоединение к игре разрешено?
 * @default false
 * @desc Если ВКЛ, игрок может присоединиться к комнатам с уже начавшейся игрой
 * 
 * 

 * 
 * 
 * @param joinStartedAndLoadedAllowed:b
 * @parent joinStartedAllowed:b
 * @type boolean
 * @text Присоединение к загруженной игре?
 * @default true
 * @desc Если ВКЛ, игрок может присоединиться к комнатам с начавшейся и загруженной из сохранения игрой
 * 
 * 
 * 

 * 
 * 
 * @param onJoinCE:int
 * @parent joinStartedAllowed:b
 * @text CE при присоединении игрока
 * @type common_event
 * @default 0
 * @desc Это общее событие будет вызвано, когда игрок присоединится к игре. CE вызывается ТОЛЬКО для этого игрока.
 * 
 * 

 * 
 * 
 * @param isJoinRandomOptionExists:b
 * @parent gameModeSettingsGroup
 * @type boolean
 * @text Опция Присоединиться к случайной комнате
 * @default true
 * @desc Показать опцию Присоединиться к случайной комнате?
 * 
 * 

 * 
 * 
 * @param saveLoadGame:b
 * @parent gameModeSettingsGroup
 * @type boolean
 * @text Сохранение и загрузка разрешены?
 * @on YES
 * @off NO
 * @default true
 * @desc Может ли игрок сохранять и загружать сетевую игру?
 * 
 * 

 * 
 * 
 * @param networkStatusIcons:b
 * @parent gameModeSettingsGroup
 * @type boolean
 * @text Показывать иконки сети?
 * @on YES
 * @off NO
 * @default true
 * @desc Иконки текущего состояния сети над игроками (меню, событие, битва и т. д.)
 * 
 * 

 * 
 * 
 * @param isMapEncountersGlobal:b
 * @parent gameModeSettingsGroup
 * @type boolean
 * @text Глобальные встречи?
 * @on YES, for all
 * @off NO, for player
 * @default false
 * @desc Являются ли встречи на карте для всех игроков на карте?
 * 
 * 

 * 
 * 
 * @param spacer|playerssettings @text‏‏‎ ‎@desc ===============================================
 * 
 * 

 * 
 * 
 * @param playersSettingsGroup
 * @text Игроки Настройки
 * 
 * 

 * 
 * 
 * @param actorsForNetwork:intA
 * @parent playersSettingsGroup
 * @type actor[]
 * @text Персонажи
 * @default ["1","2","3","4"]
 * @desc Доступные персонажи для игроков сетевой игры.
 * 
 * 

 * 
 * 
 * @param maxPlayersInRoom:int
 * @text Игроков в комнате
 * @parent playersSettingsGroup
 * @type number
 * @min 2
 * @default 4
 * @desc Максимальное количество игроков в одной комнате. Должно быть <= количеству персонажей. Макс 2 для BASIC версии.
 * 
 * 

 * 
 * 
 * @param isActorSelectionAllowed:b
 * @parent playersSettingsGroup
 * @text Выбор персонажа?
 * @type boolean
 * @default true
 * @desc Может ли игрок выбрать персонажа в лобби?
 * 
 * 

 * 
 * 
 * @param isSinglePlayerStartAllowed:b
 * @parent playersSettingsGroup
 * @text Один игрок начинает?
 * @type boolean
 * @default true
 * @desc Если в комнате только 1 игрок (хост), он может начать игру в одиночку?
 * 
 * 

 * 
 * 
 * @param playerActorNameType
 * @parent playersSettingsGroup
 * @text Имя игрока для персонажа
 * @type select
 * @option Not Show
 * @option Instead Name
 * @option Instead Nickname
 * @default Instead Nickname
 * @desc Показать имя сетевого игрока вместо имени его персонажа (или псевдонима)
 * 
 * 

 * 
 * 
 * @param playerLeaveGameCommonEvent:int
 * @parent playersSettingsGroup
 * @text CE при отключении игрока
 * @type common_event
 * @default 0
 * @desc Это общее событие будет вызвано, когда кто-то покинет (отключится) игру. 0 - ничего
 * 
 * 

 * 
 * 
 * @param isAllowCollsBetweenNetChars:b
 * @parent playersSettingsGroup
 * @text Столкновения игроков
 * @type boolean
 * @default false
 * @desc Разрешить столкновения на карте между персонажами игроков?
 * 
 * 

 * 
 * 
 * @param globalData:s
 * @text Глобальные данные
 * @type struct<LGlobalData>
 * @default {"globalVariablesIds:intA":"[]","globalSwitchesIds:intA":"[]"}
 * @desc Все эти данные будут автоматически синхронизированы между всеми игроками
 * 
 * 

 * 
 * 
 * @param spacer|othersettings @text‏‏‎ ‎@desc ===============================================
 * 
 * 
 * 

 * 
 * 
 * @param otherSettingsGroup
 * @text Другие настройки
 * 
 * 

 * 
 * 
 * @param textInputMaxLength:i
 * @text 最大输入长度
 * @parent otherSettingsGroup
 * @type number
 * @min 3
 * @default 12
 * @desc Максимальное количество символов в поле ввода (имя комнаты или игрока)
 * 
 * 

 * 
 * 
 * @param localeDB:struct
 * @text Локализация
 * @parent otherSettingsGroup
 * @type struct<LLocaleDB>
 * @default {"network":"Network","createRoom":"Create Room","joinRoom":"Join Room","joinRandomRoom":"Join Random Room","settings":"Settings","start":"Start","leave":"Leave","joinGame":"Join Game","ready":"Ready","character":"Character","close":"Close","welcome":"Welcome, %1","playersCount":"Players on server: %1"}
 * @desc Вы можете перевести или изменить встроенный текст плагина
 * 
 * 

 * 
 * 
 * @param spacer|endHolder @text‏‏‎ ‎@desc ===============================================
 * 

@command EventCommandSelector
@text Параметры команды
@desc Параметры сетевого запуска следующей команды события




@arg whoSelector
@text Кто может запустить
@type select
@option All
@option Master
@option Master Except
@option Actor List
@option Actor List Except
@default All




@arg actorList
@text Список персонажей
@type actor[]
@default []
@desc Список персонажей для 'Выполнить для', если вы выбрали 'Список персонажей' или 'За исключением списка персонажей'




@arg scope
@text Область
@type select
@option Same map
@option All world
@default Same map
@desc Для каких игроков будет выполнена виртуальная команда?




@arg executeMode
@text Режим выполнения
@type select
@option Auto
@option Virtual
@option Common Event
@default Auto
@desc Как эта команда будет выполняться для других игроков. Подробнее читайте в Wiki
@desc_CH 此命令将如何为其他玩家执行。有关更多信息，请阅读维基百科

@command EventStartOptions
@text Параметры события
@desc Параметры сетевого запуска события




@arg whoSelector
@text Кто может запустить
@type select
@option All
@option Master
@option Master Except
@option Actor List
@option Actor List Except
@default All




@arg actorList
@text Список персонажей
@type actor[]
@default []
@desc Список персонажей для 'Выполнить для', если вы выбрали 'Список персонажей' или 'За исключением списка персонажей'




@arg lockMode
@text Заблокировать событие?
@type boolean
@default false
@desc Если истина - событие будет заблокировано во время выполнения. Никто не сможет запустить заблокированное событие




@arg sharedMode
@text Общий режим
@type select
@option No
@option Strict
@option Optional
@desc Общее событие - запускается для всех игроков одновременно, синхронизированное выполнение команд
@default No


@command SharedBattle
@text Установить общую битву
@desc Сделать следующую битву общей - другой игрок сможет присоединиться к битве




@arg battleId
@text ИД
@default
@desc Уникальный идентификатор битвы. Пусто - битва НЕ будет общей (только локальной)
@desc_CH 独特的战斗编号。为空 - 非共享战斗（默认）

@command EMPTY_HOLDER
@text ‏
@desc
@default


 */
/*:zh-cn
 * @plugindesc (v.0.9 BETA)[PRO] Multiplayer for RPG Maker
 * @author Pheonix KageDesu
 * @target MZ MV
 * @url https://kdworkshop.net/plugins/alpha-net-z/
 *
 * 
 * @help
 * ---------------------------------------------------------------------------
 *
 包含的文件：
 * 插件: js/plugins/Alpha_NETZ.js
 * CSS : css/
 *      -anet_chat.css
 *      -anet.css
  * 图片: img/Alpha_NETZ/ *all files*
 * 数据（设置）：data/ANETZ/ 所有文件
 *
 * 中文翻译:古火乐(QQ:452901928)
 *
 *
 * 指南:
 * https://github.com/KageDesu/Alpha-NET-Z/wiki
 *
 * ---------------------------------------------------------------------------
 
 *
 * 如果 您喜欢我的插件，想要更多和更频繁的更新，请在以下平台上支持我：
 *
 * Boosty:
 *     https://boosty.to/kagedesu
 * Patreon:
 *      https://www.patreon.com/KageDesu
 * YouTube:
 *      https://www.youtube.com/channel/UCA3R61ojF5vp5tGwJ1YqdgQ?
 *
 *
 * License: Creative Commons 4.0 Attribution, Share Alike, Commercial
 *
 * @param ANETZ
 * @text ANETZ
 * 
 * 

 * 
 * 
 * @param connection:s
 * @text 连接
 * @type struct<LConnectionSettings>
 * @default {"serverIp":"anetzglobal.ru","serverPort":"3034","isHttpsConnection:b":"false"}
 * @desc 连接到服务器的配置
 * 
 * 

 * 
 * 
 * @param isCustomGameId:b
 * @parent connection:s
 * @type boolean
 * @text 使用自定义游戏ID？
 * @default false
 * @desc 您可以为您的游戏指定自己的（唯一）GameId。 只有具有相同gameId的游戏的玩家才能相互加入。
 * 
 * 

 * 
 * 
 * @param customGameId
 * @parent isCustomGameId:b
 * @text 自定义游戏ID
 * @default
 * @desc 不能为空。 应该是您游戏的唯一标识。 例如：SuperGame1000FromJohnDoe
 * 
 * 

 * 
 * 
 * @param isQuickDevConnectionAllowed:b
 * @parent connection:s
 * @type boolean
 * @text 允许快速连接？
 * @default false
 * @desc 适用于开发人员。 从标题菜单按C进行快速连接
 * 
 * 

 * 
 * 
 * @param isEndGameWhenHostIsLeave:b
 * @parent connection:s
 * @type boolean
 * @text 主机断开连接时结束？
 * @default true
 * @desc 如果为假，其他玩家将继续游戏（主机将被转移到另一个）
 * 
 * 

 * 
 * 
 * @param spacer|gamesettings @text‏‏‎ ‎@desc ===============================================
 * 
 * 

 * 
 * 
 * @param gameModeSettingsGroup
 * @text 多人设置
 * 
 * 

 * 
 * 
 * @param netGameTitleCmd:b
 * @parent gameModeSettingsGroup
 * @type boolean
 * @text 添加网络命令？
 * @default true
 * @desc 在标题屏幕的主菜单中添加网络命令
 * 
 * 

 * 
 * 
 * @param onlySameMap:b
 * @parent gameModeSettingsGroup
 * @type boolean
 * @text 等待地图传输？
 * @default false
 * @desc 当玩家传送到新地图时，他将等待，直到所有玩家都传送到同一张地图。
 * 
 * 

 * 
 * 
 * @param isCustomStartMap:b
 * @parent onlySameMap:b
 * @type boolean
 * @text 自定义开始？
 * @default false
 * @desc 每个角色都可以使用自己的自定义起始地图和位置。 阅读维基以获取更多信息。
 * 
 * 

 * 
 * 
 * @param singlePlayerAllowed:b
 * @parent gameModeSettingsGroup
 * @type boolean
 * @text 允许新游戏？
 * @default true
 * @desc 如果为假，则标题菜单中不会显示“新游戏”菜单项。
 * 
 * 

 * 
 * 
 * @param isReadyStatusCheck:b
 * @parent gameModeSettingsGroup
 * @type boolean
 * @text 检查准备好了吗？
 * @default false
 * @desc 如果为真，则每个玩家在主机可以启动游戏房间之前都应该设置就绪状态。
 * 
 * 

 * 
 * 
 * @param roomFilter:b
 * @parent gameModeSettingsGroup
 * @type boolean
 * @text 房间过滤器？
 * @on ON
 * @off OFF
 * @default false
 * @desc 如果过滤器打开，您只能在大厅中看到这些（相同的）游戏房间。
 * 
 * 

 * 
 * 
 * @param joinStartedAllowed:b
 * @parent gameModeSettingsGroup
 * @type boolean
 * @text 允许加入游戏？
 * @default false
 * @desc 如果为真，玩家可以加入已经开始游戏的房间
 * 
 * 

 * 
 * 
 * @param joinStartedAndLoadedAllowed:b
 * @parent joinStartedAllowed:b
 * @type boolean
 * @text 加入加载的游戏？
 * @default true
 * @desc 如果为真，玩家可以加入已从存档文件启动并加载的游戏房间
 * 
 * 
 * 

 * 
 * 
 * @param onJoinCE:int
 * @parent joinStartedAllowed:b
 * @text 加入玩家 CE
 * @type common_event
 * @default 0
 * @desc 当玩家加入游戏时，将调用该公共事件。 CE 仅针对该玩家调用。
 * 
 * 

 * 
 * 
 * @param isJoinRandomOptionExists:b
 * @parent gameModeSettingsGroup
 * @type boolean
 * @text 加入随机房间选项
 * @default true
 * @desc 显示加入随机房间选项？
 * 
 * 

 * 
 * 
 * @param saveLoadGame:b
 * @parent gameModeSettingsGroup
 * @type boolean
 * @text 允许保存和加载？
 * @on YES
 * @off NO
 * @default true
 * @desc 玩家可以保存和加载网络游戏吗？
 * 
 * 

 * 
 * 
 * @param networkStatusIcons:b
 * @parent gameModeSettingsGroup
 * @type boolean
 * @text 显示网络图标？
 * @on YES
 * @off NO
 * @default true
 * @desc 网络当前状态图标位于玩家上方（菜单、事件、战斗等...）
 * 
 * 

 * 
 * 
 * @param isMapEncountersGlobal:b
 * @parent gameModeSettingsGroup
 * @type boolean
 * @text 遭遇是全球性的吗？
 * @on YES, for all
 * @off NO, for player
 * @default false
 * @desc 地图遭遇是针对地图上的所有玩家吗？
 * 
 * 

 * 
 * 
 * @param spacer|playerssettings @text‏‏‎ ‎@desc ===============================================
 * 
 * 

 * 
 * 
 * @param playersSettingsGroup
 * @text 玩家设置
 * 
 * 

 * 
 * 
 * @param actorsForNetwork:intA
 * @parent playersSettingsGroup
 * @type actor[]
 * @text 角色
 * @default ["1","2","3","4"]
 * @desc 网络游戏玩家可用的角色。
 * 
 * 

 * 
 * 
 * @param maxPlayersInRoom:int
 * @text 每个房间的玩家
 * @parent playersSettingsGroup
 * @type number
 * @min 2
 * @default 4
 * @desc 一个房间的最大玩家数。 应该<=角色计数。 BASIC 版本最多 2 个。
 * 
 * 

 * 
 * 
 * @param isActorSelectionAllowed:b
 * @parent playersSettingsGroup
 * @text 角色选择？
 * @type boolean
 * @default true
 * @desc 玩家可以在大厅选择角色吗？
 * 
 * 

 * 
 * 
 * @param isSinglePlayerStartAllowed:b
 * @parent playersSettingsGroup
 * @text 一名玩家开始？
 * @type boolean
 * @default true
 * @desc 如果房间里只有 1 名玩家（主机），他可以独自开始游戏吗？
 * 
 * 

 * 
 * 
 * @param playerActorNameType
 * @parent playersSettingsGroup
 * @text 角色的玩家姓名
 * @type select
 * @option Not Show
 * @option Instead Name
 * @option Instead Nickname
 * @default Instead Nickname
 * @desc 显示网络玩家名称，而不是他的角色名称（或昵称）
 * 
 * 

 * 
 * 
 * @param playerLeaveGameCommonEvent:int
 * @parent playersSettingsGroup
 * @text 玩家断开连接 CE
 * @type common_event
 * @default 0
 * @desc 当有人离开（断开连接）游戏时，将调用该公共事件。 0 - 没什么
 * 
 * 

 * 
 * 
 * @param isAllowCollsBetweenNetChars:b
 * @parent playersSettingsGroup
 * @text 玩家碰撞
 * @type boolean
 * @default false
 * @desc 允许玩家角色之间在地图上的碰撞吗？
 * 
 * 

 * 
 * 
 * @param globalData:s
 * @text 全局数据
 * @type struct<LGlobalData>
 * @default {"globalVariablesIds:intA":"[]","globalSwitchesIds:intA":"[]"}
 * @desc 所有这些数据将自动在所有玩家之间同步
 * 
 * 

 * 
 * 
 * @param spacer|othersettings @text‏‏‎ ‎@desc ===============================================
 * 
 * 
 * 

 * 
 * 
 * @param otherSettingsGroup
 * @text 其他设置
 * 
 * 

 * 
 * 
 * @param textInputMaxLength:i
 * @text 最大输入长度
 * @parent otherSettingsGroup
 * @type number
 * @min 3
 * @default 12
 * @desc 输入字段（房间或玩家名称）最大字符数
 * 
 * 

 * 
 * 
 * @param localeDB:struct
 * @text 本地化
 * @parent otherSettingsGroup
 * @type struct<LLocaleDB>
 * @default {"network":"Network","createRoom":"Create Room","joinRoom":"Join Room","joinRandomRoom":"Join Random Room","settings":"Settings","start":"Start","leave":"Leave","joinGame":"Join Game","ready":"Ready","character":"Character","close":"Close","welcome":"Welcome, %1","playersCount":"Players on server: %1"}
 * @desc 您可以翻译或更改嵌入式插件文本
 * 
 * 

 * 
 * 
 * @param spacer|endHolder @text‏‏‎ ‎@desc ===============================================
 * 

@command EventCommandSelector
@text 命令选项
@desc 下一个事件命令的网络启动选项




@arg whoSelector
@text 谁可以启动
@type select
@option All
@option Master
@option Master Except
@option Actor List
@option Actor List Except
@default All




@arg actorList
@text 角色列表
@type actor[]
@default []
@desc 如果您选择“角色列表”或“角色列表除外”，则为“执行对象”的角色列表




@arg scope
@text 范围
@type select
@option Same map
@option All world
@default Same map
@desc 虚拟命令将为哪些玩家执行？




@arg executeMode
@text 执行模式
@type select
@option Auto
@option Virtual
@option Common Event
@default Auto
@desc 此命令将如何为其他玩家执行。有关更多信息，请阅读维基百科

@command EventStartOptions
@text 事件选项
@desc 事件网络启动选项




@arg whoSelector
@text 谁可以启动
@type select
@option All
@option Master
@option Master Except
@option Actor List
@option Actor List Except
@default All




@arg actorList
@text 角色列表
@type actor[]
@default []
@desc 如果您选择“角色列表”或“角色列表除外”，则为“执行对象”的角色列表




@arg lockMode
@text 锁定事件？
@type boolean
@default false
@desc 如果为真 - 事件在执行时将被锁定。没有人能启动锁定的事件




@arg sharedMode
@text 共享模式
@type select
@option No
@option Strict
@option Optional
@desc 共享事件 - 同时为所有玩家启动，同步命令执行
@default No


@command SharedBattle
@text 设为共享战斗
@desc 使下一个战斗处理命令在所有玩家之间共享




@arg battleId
@text 编号
@default
@desc 独特的战斗编号。为空 - 非共享战斗（默认）

@command EMPTY_HOLDER
@text ‏
@desc
@default


 */
/*~struct~LConnectionSettings:

@param serverIp
@text IP
@type combo
@option localhost
@option anetzglobal.ru
@option 195.161.41.20
@desc Server IP address (ip4) or domain name
@default anetzglobal.ru




@param serverPort
@text Port
@default 3034




@param isHttpsConnection:b
@text Is HTTPS (SSL) ?
@type boolean

@on Yes, https
@off No, http
@default false
@desc Is use secure connection via https protocol? anetzglobal.ru uses port 3035 for secure connection.

*/

/*~struct~LGlobalData:

@param globalVariablesIds:intA
@type variable[]
@text Variables
@default []
@desc Variables for auto synchronizaton




@param globalSwitchesIds:intA
@type switch[]
@text Switches
@default []
@desc Switches for auto synchronizaton
*/

/*~struct~LLocaleDB:

@param network
@default Network
*/

/*~struct~LConnectionSettings:ru

@param serverIp
@text IP
@type combo
@option localhost
@option anetzglobal.ru
@option 195.161.41.20
@desc IP-адрес сервера (ip4) или доменное имя
@default anetzglobal.ru




@param serverPort
@text Порт
@default 3034




@param isHttpsConnection:b
@text HTTPS (SSL) ?
@type boolean

@on Yes, https
@off No, http
@default false
@desc Использовать защищенное соединение через протокол https? anetzglobal.ru использует порт 3035 для защищенного соединения.

*/

/*~struct~LGlobalData:ru

@param globalVariablesIds:intA
@type variable[]
@text Переменные
@default []
@desc Переменные для автоматической синхронизации




@param globalSwitchesIds:intA
@type switch[]
@text Переключатели
@default []
@desc Переключатели для автоматической синхронизации
*/

/*~struct~LLocaleDB:ru

@param network
@default Network
*/

/*~struct~LConnectionSettings:zh-ch

@param serverIp
@text IP
@type combo
@option localhost
@option anetzglobal.ru
@option 195.161.41.20
@desc 服务器IP地址（ip4）或域名
@default anetzglobal.ru




@param serverPort
@text 端口
@default 3034




@param isHttpsConnection:b
@text HTTPS (SSL) ?
@type boolean

@on Yes, https
@off No, http
@default false
@desc 是否通过https协议使用安全连接？ anetzglobal.ru使用端口3035进行安全连接。

*/

/*~struct~LGlobalData:zh-ch

@param globalVariablesIds:intA
@type variable[]
@text 变量
@default []
@desc 自动同步的变量




@param globalSwitchesIds:intA
@type switch[]
@text 开关
@default []
@desc 自动同步的开关
*/

/*~struct~LLocaleDB:zh-ch

@param network
@default Network
*/




var Imported;
(function (Imported) {
    Imported.Alpha_NETZ = true;
})(Imported || (Imported = {}));
var ANET;
(function (ANET) {
    ANET.Version = "0.9 BETA";
    ANET.MinServerRev = 116; // * Необходимая ревизия сервера
    // Данный символ переопределяется в 1_DevSymbol_TEST как dev
    ANET._define = 'build'; // * By default -> build
    function isDEV() {
        return ANET._define === 'dev';
    }
    ANET.isDEV = isDEV;
    function isPro() {
        return true;
    }
    ANET.isPro = isPro;
    function isShowExtOutput() {
        return false;
    }
    ANET.isShowExtOutput = isShowExtOutput;
    //TODO: get rid of this
    function w(e, mgs) {
        console.warn("Alpha_NETZ: " + e);
    }
    ANET.w = w;
    function registerExtension(name) {
        ANET['LL'].extensionLoaded(name);
    }
    ANET.registerExtension = registerExtension;
    /**
     * Get NUI file from plugin
     * @param {string} name - Name of file
     * @returns {any} - File content
    */
    function GetNUIFile(name) {
        return window["$ANETZ_" + name];
    }
    ANET.GetNUIFile = GetNUIFile;
    /**
     * Link object to plugin scope level
     * @param {any} obj - Object to link
     * @param {string} name? - Name of object (optional)
     * @returns {void}
     *
    */
    function link(obj, name) {
        try {
            if ((name === null || name === void 0 ? void 0 : name.length) > 0) {
                this[name] = obj;
            }
            else {
                let _name = obj.name;
                if ((_name === null || _name === void 0 ? void 0 : _name.length) > 0) {
                    this[obj.name] = obj;
                }
                else {
                    console.warn("You try link object with empty name");
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    ANET.link = link;
    function extendLibrariesForExtensions(_kdx, _kdnui, _kColor, _knSprite) {
        window['NZKDX'] = _kdx;
        window['NZKDNUI'] = _kdnui;
        window['NZKColor'] = _kColor;
        window['NZKNSprite'] = _knSprite;
    }
    ANET.extendLibrariesForExtensions = extendLibrariesForExtensions;
})(ANET || (ANET = {}));


(function(){



/*
# ==========================================================================
# ==========================================================================
#
#   EMBEDDED PHEONIX KAGEDESU PLUGINS CORE LIBRARY
#   (This plugin may not use the entire code of this library)
#
# ==========================================================================
# ==========================================================================
 * 
 * 
 */



/*!
 * pixi-filters - v4.2.0
 * Compiled Fri, 05 Aug 2022 19:51:27 UTC
 *
 * pixi-filters is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var __filters=function(e,n,t,r,o,i,l,a){"use strict";var s=function(e,n){return(s=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])})(e,n)};function u(e,n){function t(){this.constructor=e}s(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)}var f=function(){return(f=Object.assign||function(e){for(var n,t=arguments,r=1,o=arguments.length;r<o;r++)for(var i in n=t[r])Object.prototype.hasOwnProperty.call(n,i)&&(e[i]=n[i]);return e}).apply(this,arguments)};Object.create;Object.create;var c="attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}",m=function(e){function n(n){var t=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform float gamma;\nuniform float contrast;\nuniform float saturation;\nuniform float brightness;\nuniform float red;\nuniform float green;\nuniform float blue;\nuniform float alpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (c.a > 0.0) {\n        c.rgb /= c.a;\n\n        vec3 rgb = pow(c.rgb, vec3(1. / gamma));\n        rgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb)), rgb, saturation), contrast);\n        rgb.r *= red;\n        rgb.g *= green;\n        rgb.b *= blue;\n        c.rgb = rgb * brightness;\n\n        c.rgb *= c.a;\n    }\n\n    gl_FragColor = c * alpha;\n}\n")||this;return t.gamma=1,t.saturation=1,t.contrast=1,t.brightness=1,t.red=1,t.green=1,t.blue=1,t.alpha=1,Object.assign(t,n),t}return u(n,e),n.prototype.apply=function(e,n,t,r){this.uniforms.gamma=Math.max(this.gamma,1e-4),this.uniforms.saturation=this.saturation,this.uniforms.contrast=this.contrast,this.uniforms.brightness=this.brightness,this.uniforms.red=this.red,this.uniforms.green=this.green,this.uniforms.blue=this.blue,this.uniforms.alpha=this.alpha,e.applyFilter(this,n,t,r)},n}(n.Filter),p=function(e){function n(n){void 0===n&&(n=.5);var t=e.call(this,c,"\nuniform sampler2D uSampler;\nvarying vec2 vTextureCoord;\n\nuniform float threshold;\n\nvoid main() {\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    // A simple & fast algorithm for getting brightness.\n    // It's inaccuracy , but good enought for this feature.\n    float _max = max(max(color.r, color.g), color.b);\n    float _min = min(min(color.r, color.g), color.b);\n    float brightness = (_max + _min) * 0.5;\n\n    if(brightness > threshold) {\n        gl_FragColor = color;\n    } else {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}\n")||this;return t.threshold=n,t}return u(n,e),Object.defineProperty(n.prototype,"threshold",{get:function(){return this.uniforms.threshold},set:function(e){this.uniforms.threshold=e},enumerable:!1,configurable:!0}),n}(n.Filter),d=function(e){function n(n,r,o){void 0===n&&(n=4),void 0===r&&(r=3),void 0===o&&(o=!1);var i=e.call(this,c,o?"\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec2 uOffset;\nuniform vec4 filterClamp;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample top right pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample bottom right pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample bottom left pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Average\n    color *= 0.25;\n\n    gl_FragColor = color;\n}\n":"\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec2 uOffset;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample top right pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample bottom right pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Sample bottom left pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Average\n    color *= 0.25;\n\n    gl_FragColor = color;\n}")||this;return i._kernels=[],i._blur=4,i._quality=3,i.uniforms.uOffset=new Float32Array(2),i._pixelSize=new t.Point,i.pixelSize=1,i._clamp=o,Array.isArray(n)?i.kernels=n:(i._blur=n,i.quality=r),i}return u(n,e),n.prototype.apply=function(e,n,t,r){var o,i=this._pixelSize.x/n._frame.width,l=this._pixelSize.y/n._frame.height;if(1===this._quality||0===this._blur)o=this._kernels[0]+.5,this.uniforms.uOffset[0]=o*i,this.uniforms.uOffset[1]=o*l,e.applyFilter(this,n,t,r);else{for(var a=e.getFilterTexture(),s=n,u=a,f=void 0,c=this._quality-1,m=0;m<c;m++)o=this._kernels[m]+.5,this.uniforms.uOffset[0]=o*i,this.uniforms.uOffset[1]=o*l,e.applyFilter(this,s,u,1),f=s,s=u,u=f;o=this._kernels[c]+.5,this.uniforms.uOffset[0]=o*i,this.uniforms.uOffset[1]=o*l,e.applyFilter(this,s,t,r),e.returnFilterTexture(a)}},n.prototype._updatePadding=function(){this.padding=Math.ceil(this._kernels.reduce((function(e,n){return e+n+.5}),0))},n.prototype._generateKernels=function(){var e=this._blur,n=this._quality,t=[e];if(e>0)for(var r=e,o=e/n,i=1;i<n;i++)r-=o,t.push(r);this._kernels=t,this._updatePadding()},Object.defineProperty(n.prototype,"kernels",{get:function(){return this._kernels},set:function(e){Array.isArray(e)&&e.length>0?(this._kernels=e,this._quality=e.length,this._blur=Math.max.apply(Math,e)):(this._kernels=[0],this._quality=1)},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"clamp",{get:function(){return this._clamp},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"pixelSize",{get:function(){return this._pixelSize},set:function(e){"number"==typeof e?(this._pixelSize.x=e,this._pixelSize.y=e):Array.isArray(e)?(this._pixelSize.x=e[0],this._pixelSize.y=e[1]):e instanceof t.Point?(this._pixelSize.x=e.x,this._pixelSize.y=e.y):(this._pixelSize.x=1,this._pixelSize.y=1)},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"quality",{get:function(){return this._quality},set:function(e){this._quality=Math.max(1,Math.round(e)),this._generateKernels()},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"blur",{get:function(){return this._blur},set:function(e){this._blur=e,this._generateKernels()},enumerable:!1,configurable:!0}),n}(n.Filter),h=function(e){function n(t){var o=e.call(this,c,"uniform sampler2D uSampler;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D bloomTexture;\nuniform float bloomScale;\nuniform float brightness;\n\nvoid main() {\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    color.rgb *= brightness;\n    vec4 bloomColor = vec4(texture2D(bloomTexture, vTextureCoord).rgb, 0.0);\n    bloomColor.rgb *= bloomScale;\n    gl_FragColor = color + bloomColor;\n}\n")||this;o.bloomScale=1,o.brightness=1,o._resolution=r.settings.FILTER_RESOLUTION,"number"==typeof t&&(t={threshold:t});var i=Object.assign(n.defaults,t);o.bloomScale=i.bloomScale,o.brightness=i.brightness;var l=i.kernels,a=i.blur,s=i.quality,u=i.pixelSize,f=i.resolution;return o._extractFilter=new p(i.threshold),o._extractFilter.resolution=f,o._blurFilter=l?new d(l):new d(a,s),o.pixelSize=u,o.resolution=f,o}return u(n,e),n.prototype.apply=function(e,n,t,r,o){var i=e.getFilterTexture();this._extractFilter.apply(e,n,i,1,o);var l=e.getFilterTexture();this._blurFilter.apply(e,i,l,1),this.uniforms.bloomScale=this.bloomScale,this.uniforms.brightness=this.brightness,this.uniforms.bloomTexture=l,e.applyFilter(this,n,t,r),e.returnFilterTexture(l),e.returnFilterTexture(i)},Object.defineProperty(n.prototype,"resolution",{get:function(){return this._resolution},set:function(e){this._resolution=e,this._extractFilter&&(this._extractFilter.resolution=e),this._blurFilter&&(this._blurFilter.resolution=e)},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"threshold",{get:function(){return this._extractFilter.threshold},set:function(e){this._extractFilter.threshold=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"kernels",{get:function(){return this._blurFilter.kernels},set:function(e){this._blurFilter.kernels=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"blur",{get:function(){return this._blurFilter.blur},set:function(e){this._blurFilter.blur=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"quality",{get:function(){return this._blurFilter.quality},set:function(e){this._blurFilter.quality=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"pixelSize",{get:function(){return this._blurFilter.pixelSize},set:function(e){this._blurFilter.pixelSize=e},enumerable:!1,configurable:!0}),n.defaults={threshold:.5,bloomScale:1,brightness:1,kernels:null,blur:8,quality:4,pixelSize:1,resolution:r.settings.FILTER_RESOLUTION},n}(n.Filter),g=function(e){function n(n){void 0===n&&(n=8);var t=e.call(this,c,"varying vec2 vTextureCoord;\n\nuniform vec4 filterArea;\nuniform float pixelSize;\nuniform sampler2D uSampler;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= filterArea.xy;\n    coord += filterArea.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= filterArea.zw;\n    coord /= filterArea.xy;\n\n    return coord;\n}\n\nvec2 pixelate(vec2 coord, vec2 size)\n{\n    return floor( coord / size ) * size;\n}\n\nvec2 getMod(vec2 coord, vec2 size)\n{\n    return mod( coord , size) / size;\n}\n\nfloat character(float n, vec2 p)\n{\n    p = floor(p*vec2(4.0, -4.0) + 2.5);\n\n    if (clamp(p.x, 0.0, 4.0) == p.x)\n    {\n        if (clamp(p.y, 0.0, 4.0) == p.y)\n        {\n            if (int(mod(n/exp2(p.x + 5.0*p.y), 2.0)) == 1) return 1.0;\n        }\n    }\n    return 0.0;\n}\n\nvoid main()\n{\n    vec2 coord = mapCoord(vTextureCoord);\n\n    // get the rounded color..\n    vec2 pixCoord = pixelate(coord, vec2(pixelSize));\n    pixCoord = unmapCoord(pixCoord);\n\n    vec4 color = texture2D(uSampler, pixCoord);\n\n    // determine the character to use\n    float gray = (color.r + color.g + color.b) / 3.0;\n\n    float n =  65536.0;             // .\n    if (gray > 0.2) n = 65600.0;    // :\n    if (gray > 0.3) n = 332772.0;   // *\n    if (gray > 0.4) n = 15255086.0; // o\n    if (gray > 0.5) n = 23385164.0; // &\n    if (gray > 0.6) n = 15252014.0; // 8\n    if (gray > 0.7) n = 13199452.0; // @\n    if (gray > 0.8) n = 11512810.0; // #\n\n    // get the mod..\n    vec2 modd = getMod(coord, vec2(pixelSize));\n\n    gl_FragColor = color * character( n, vec2(-1.0) + modd * 2.0);\n\n}\n")||this;return t.size=n,t}return u(n,e),Object.defineProperty(n.prototype,"size",{get:function(){return this.uniforms.pixelSize},set:function(e){this.uniforms.pixelSize=e},enumerable:!1,configurable:!0}),n}(n.Filter),v=function(e){function n(n){var t=e.call(this,c,"precision mediump float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform float transformX;\nuniform float transformY;\nuniform vec3 lightColor;\nuniform float lightAlpha;\nuniform vec3 shadowColor;\nuniform float shadowAlpha;\n\nvoid main(void) {\n    vec2 transform = vec2(1.0 / filterArea) * vec2(transformX, transformY);\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float light = texture2D(uSampler, vTextureCoord - transform).a;\n    float shadow = texture2D(uSampler, vTextureCoord + transform).a;\n\n    color.rgb = mix(color.rgb, lightColor, clamp((color.a - light) * lightAlpha, 0.0, 1.0));\n    color.rgb = mix(color.rgb, shadowColor, clamp((color.a - shadow) * shadowAlpha, 0.0, 1.0));\n    gl_FragColor = vec4(color.rgb * color.a, color.a);\n}\n")||this;return t._thickness=2,t._angle=0,t.uniforms.lightColor=new Float32Array(3),t.uniforms.shadowColor=new Float32Array(3),Object.assign(t,{rotation:45,thickness:2,lightColor:16777215,lightAlpha:.7,shadowColor:0,shadowAlpha:.7},n),t.padding=1,t}return u(n,e),n.prototype._updateTransform=function(){this.uniforms.transformX=this._thickness*Math.cos(this._angle),this.uniforms.transformY=this._thickness*Math.sin(this._angle)},Object.defineProperty(n.prototype,"rotation",{get:function(){return this._angle/t.DEG_TO_RAD},set:function(e){this._angle=e*t.DEG_TO_RAD,this._updateTransform()},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"thickness",{get:function(){return this._thickness},set:function(e){this._thickness=e,this._updateTransform()},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"lightColor",{get:function(){return o.rgb2hex(this.uniforms.lightColor)},set:function(e){o.hex2rgb(e,this.uniforms.lightColor)},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"lightAlpha",{get:function(){return this.uniforms.lightAlpha},set:function(e){this.uniforms.lightAlpha=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"shadowColor",{get:function(){return o.rgb2hex(this.uniforms.shadowColor)},set:function(e){o.hex2rgb(e,this.uniforms.shadowColor)},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"shadowAlpha",{get:function(){return this.uniforms.shadowAlpha},set:function(e){this.uniforms.shadowAlpha=e},enumerable:!1,configurable:!0}),n}(n.Filter),y=function(e){function n(n,o,s,u){void 0===n&&(n=2),void 0===o&&(o=4),void 0===s&&(s=r.settings.FILTER_RESOLUTION),void 0===u&&(u=5);var f,c,m=e.call(this)||this;return"number"==typeof n?(f=n,c=n):n instanceof t.Point?(f=n.x,c=n.y):Array.isArray(n)&&(f=n[0],c=n[1]),m.blurXFilter=new a.BlurFilterPass(!0,f,o,s,u),m.blurYFilter=new a.BlurFilterPass(!1,c,o,s,u),m.blurYFilter.blendMode=i.BLEND_MODES.SCREEN,m.defaultFilter=new l.AlphaFilter,m}return u(n,e),n.prototype.apply=function(e,n,t,r){var o=e.getFilterTexture();this.defaultFilter.apply(e,n,t,r),this.blurXFilter.apply(e,n,o,1),this.blurYFilter.apply(e,o,t,0),e.returnFilterTexture(o)},Object.defineProperty(n.prototype,"blur",{get:function(){return this.blurXFilter.blur},set:function(e){this.blurXFilter.blur=this.blurYFilter.blur=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"blurX",{get:function(){return this.blurXFilter.blur},set:function(e){this.blurXFilter.blur=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"blurY",{get:function(){return this.blurYFilter.blur},set:function(e){this.blurYFilter.blur=e},enumerable:!1,configurable:!0}),n}(n.Filter),b=function(e){function n(t){var r=e.call(this,c,"uniform float radius;\nuniform float strength;\nuniform vec2 center;\nuniform sampler2D uSampler;\nvarying vec2 vTextureCoord;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform vec2 dimensions;\n\nvoid main()\n{\n    vec2 coord = vTextureCoord * filterArea.xy;\n    coord -= center * dimensions.xy;\n    float distance = length(coord);\n    if (distance < radius) {\n        float percent = distance / radius;\n        if (strength > 0.0) {\n            coord *= mix(1.0, smoothstep(0.0, radius / distance, percent), strength * 0.75);\n        } else {\n            coord *= mix(1.0, pow(percent, 1.0 + strength * 0.75) * radius / distance, 1.0 - percent);\n        }\n    }\n    coord += center * dimensions.xy;\n    coord /= filterArea.xy;\n    vec2 clampedCoord = clamp(coord, filterClamp.xy, filterClamp.zw);\n    vec4 color = texture2D(uSampler, clampedCoord);\n    if (coord != clampedCoord) {\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\n    }\n\n    gl_FragColor = color;\n}\n")||this;return r.uniforms.dimensions=new Float32Array(2),Object.assign(r,n.defaults,t),r}return u(n,e),n.prototype.apply=function(e,n,t,r){var o=n.filterFrame,i=o.width,l=o.height;this.uniforms.dimensions[0]=i,this.uniforms.dimensions[1]=l,e.applyFilter(this,n,t,r)},Object.defineProperty(n.prototype,"radius",{get:function(){return this.uniforms.radius},set:function(e){this.uniforms.radius=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"strength",{get:function(){return this.uniforms.strength},set:function(e){this.uniforms.strength=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"center",{get:function(){return this.uniforms.center},set:function(e){this.uniforms.center=e},enumerable:!1,configurable:!0}),n.defaults={center:[.5,.5],radius:100,strength:1},n}(n.Filter),x=function(e){function t(n,t,r){void 0===t&&(t=!1),void 0===r&&(r=1);var o=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform sampler2D colorMap;\nuniform float _mix;\nuniform float _size;\nuniform float _sliceSize;\nuniform float _slicePixelSize;\nuniform float _sliceInnerSize;\nvoid main() {\n    vec4 color = texture2D(uSampler, vTextureCoord.xy);\n\n    vec4 adjusted;\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n        float innerWidth = _size - 1.0;\n        float zSlice0 = min(floor(color.b * innerWidth), innerWidth);\n        float zSlice1 = min(zSlice0 + 1.0, innerWidth);\n        float xOffset = _slicePixelSize * 0.5 + color.r * _sliceInnerSize;\n        float s0 = xOffset + (zSlice0 * _sliceSize);\n        float s1 = xOffset + (zSlice1 * _sliceSize);\n        float yOffset = _sliceSize * 0.5 + color.g * (1.0 - _sliceSize);\n        vec4 slice0Color = texture2D(colorMap, vec2(s0,yOffset));\n        vec4 slice1Color = texture2D(colorMap, vec2(s1,yOffset));\n        float zOffset = fract(color.b * innerWidth);\n        adjusted = mix(slice0Color, slice1Color, zOffset);\n\n        color.rgb *= color.a;\n    }\n    gl_FragColor = vec4(mix(color, adjusted, _mix).rgb, color.a);\n\n}")||this;return o.mix=1,o._size=0,o._sliceSize=0,o._slicePixelSize=0,o._sliceInnerSize=0,o._nearest=!1,o._scaleMode=null,o._colorMap=null,o._scaleMode=null,o.nearest=t,o.mix=r,o.colorMap=n,o}return u(t,e),t.prototype.apply=function(e,n,t,r){this.uniforms._mix=this.mix,e.applyFilter(this,n,t,r)},Object.defineProperty(t.prototype,"colorSize",{get:function(){return this._size},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"colorMap",{get:function(){return this._colorMap},set:function(e){var t;e&&(e instanceof n.Texture||(e=n.Texture.from(e)),(null===(t=e)||void 0===t?void 0:t.baseTexture)&&(e.baseTexture.scaleMode=this._scaleMode,e.baseTexture.mipmap=i.MIPMAP_MODES.OFF,this._size=e.height,this._sliceSize=1/this._size,this._slicePixelSize=this._sliceSize/this._size,this._sliceInnerSize=this._slicePixelSize*(this._size-1),this.uniforms._size=this._size,this.uniforms._sliceSize=this._sliceSize,this.uniforms._slicePixelSize=this._slicePixelSize,this.uniforms._sliceInnerSize=this._sliceInnerSize,this.uniforms.colorMap=e),this._colorMap=e)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"nearest",{get:function(){return this._nearest},set:function(e){this._nearest=e,this._scaleMode=e?i.SCALE_MODES.NEAREST:i.SCALE_MODES.LINEAR;var n=this._colorMap;n&&n.baseTexture&&(n.baseTexture._glTextures={},n.baseTexture.scaleMode=this._scaleMode,n.baseTexture.mipmap=i.MIPMAP_MODES.OFF,n._updateID++,n.baseTexture.emit("update",n.baseTexture))},enumerable:!1,configurable:!0}),t.prototype.updateColorMap=function(){var e=this._colorMap;e&&e.baseTexture&&(e._updateID++,e.baseTexture.emit("update",e.baseTexture),this.colorMap=e)},t.prototype.destroy=function(n){void 0===n&&(n=!1),this._colorMap&&this._colorMap.destroy(n),e.prototype.destroy.call(this)},t}(n.Filter),_=function(e){function n(n,t){void 0===n&&(n=0),void 0===t&&(t=1);var r=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec3 color;\nuniform float alpha;\n\nvoid main(void) {\n    vec4 currentColor = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = vec4(mix(currentColor.rgb, color.rgb, currentColor.a * alpha), currentColor.a);\n}\n")||this;return r._color=0,r._alpha=1,r.uniforms.color=new Float32Array(3),r.color=n,r.alpha=t,r}return u(n,e),Object.defineProperty(n.prototype,"color",{get:function(){return this._color},set:function(e){var n=this.uniforms.color;"number"==typeof e?(o.hex2rgb(e,n),this._color=e):(n[0]=e[0],n[1]=e[1],n[2]=e[2],this._color=o.rgb2hex(n))},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"alpha",{get:function(){return this._alpha},set:function(e){this.uniforms.alpha=e,this._alpha=e},enumerable:!1,configurable:!0}),n}(n.Filter),C=function(e){function n(n,t,r){void 0===n&&(n=16711680),void 0===t&&(t=0),void 0===r&&(r=.4);var o=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec3 originalColor;\nuniform vec3 newColor;\nuniform float epsilon;\nvoid main(void) {\n    vec4 currentColor = texture2D(uSampler, vTextureCoord);\n    vec3 colorDiff = originalColor - (currentColor.rgb / max(currentColor.a, 0.0000000001));\n    float colorDistance = length(colorDiff);\n    float doReplace = step(colorDistance, epsilon);\n    gl_FragColor = vec4(mix(currentColor.rgb, (newColor + colorDiff) * currentColor.a, doReplace), currentColor.a);\n}\n")||this;return o._originalColor=16711680,o._newColor=0,o.uniforms.originalColor=new Float32Array(3),o.uniforms.newColor=new Float32Array(3),o.originalColor=n,o.newColor=t,o.epsilon=r,o}return u(n,e),Object.defineProperty(n.prototype,"originalColor",{get:function(){return this._originalColor},set:function(e){var n=this.uniforms.originalColor;"number"==typeof e?(o.hex2rgb(e,n),this._originalColor=e):(n[0]=e[0],n[1]=e[1],n[2]=e[2],this._originalColor=o.rgb2hex(n))},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"newColor",{get:function(){return this._newColor},set:function(e){var n=this.uniforms.newColor;"number"==typeof e?(o.hex2rgb(e,n),this._newColor=e):(n[0]=e[0],n[1]=e[1],n[2]=e[2],this._newColor=o.rgb2hex(n))},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"epsilon",{get:function(){return this.uniforms.epsilon},set:function(e){this.uniforms.epsilon=e},enumerable:!1,configurable:!0}),n}(n.Filter),S=function(e){function n(n,t,r){void 0===t&&(t=200),void 0===r&&(r=200);var o=e.call(this,c,"precision mediump float;\n\nvarying mediump vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec2 texelSize;\nuniform float matrix[9];\n\nvoid main(void)\n{\n   vec4 c11 = texture2D(uSampler, vTextureCoord - texelSize); // top left\n   vec4 c12 = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - texelSize.y)); // top center\n   vec4 c13 = texture2D(uSampler, vec2(vTextureCoord.x + texelSize.x, vTextureCoord.y - texelSize.y)); // top right\n\n   vec4 c21 = texture2D(uSampler, vec2(vTextureCoord.x - texelSize.x, vTextureCoord.y)); // mid left\n   vec4 c22 = texture2D(uSampler, vTextureCoord); // mid center\n   vec4 c23 = texture2D(uSampler, vec2(vTextureCoord.x + texelSize.x, vTextureCoord.y)); // mid right\n\n   vec4 c31 = texture2D(uSampler, vec2(vTextureCoord.x - texelSize.x, vTextureCoord.y + texelSize.y)); // bottom left\n   vec4 c32 = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + texelSize.y)); // bottom center\n   vec4 c33 = texture2D(uSampler, vTextureCoord + texelSize); // bottom right\n\n   gl_FragColor =\n       c11 * matrix[0] + c12 * matrix[1] + c13 * matrix[2] +\n       c21 * matrix[3] + c22 * matrix[4] + c23 * matrix[5] +\n       c31 * matrix[6] + c32 * matrix[7] + c33 * matrix[8];\n\n   gl_FragColor.a = c22.a;\n}\n")||this;return o.uniforms.texelSize=new Float32Array(2),o.uniforms.matrix=new Float32Array(9),void 0!==n&&(o.matrix=n),o.width=t,o.height=r,o}return u(n,e),Object.defineProperty(n.prototype,"matrix",{get:function(){return this.uniforms.matrix},set:function(e){var n=this;e.forEach((function(e,t){n.uniforms.matrix[t]=e}))},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"width",{get:function(){return 1/this.uniforms.texelSize[0]},set:function(e){this.uniforms.texelSize[0]=1/e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"height",{get:function(){return 1/this.uniforms.texelSize[1]},set:function(e){this.uniforms.texelSize[1]=1/e},enumerable:!1,configurable:!0}),n}(n.Filter),F=function(e){function n(){return e.call(this,c,"precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    float lum = length(texture2D(uSampler, vTextureCoord.xy).rgb);\n\n    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n\n    if (lum < 1.00)\n    {\n        if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.75)\n    {\n        if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.50)\n    {\n        if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.3)\n    {\n        if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n}\n")||this}return u(n,e),n}(n.Filter),z=function(e){function n(t){var r=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec2 dimensions;\n\nconst float SQRT_2 = 1.414213;\n\nconst float light = 1.0;\n\nuniform float curvature;\nuniform float lineWidth;\nuniform float lineContrast;\nuniform bool verticalLine;\nuniform float noise;\nuniform float noiseSize;\n\nuniform float vignetting;\nuniform float vignettingAlpha;\nuniform float vignettingBlur;\n\nuniform float seed;\nuniform float time;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main(void)\n{\n    vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\n    vec2 dir = vec2(vTextureCoord.xy * filterArea.xy / dimensions - vec2(0.5, 0.5));\n    \n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n    vec3 rgb = gl_FragColor.rgb;\n\n    if (noise > 0.0 && noiseSize > 0.0)\n    {\n        pixelCoord.x = floor(pixelCoord.x / noiseSize);\n        pixelCoord.y = floor(pixelCoord.y / noiseSize);\n        float _noise = rand(pixelCoord * noiseSize * seed) - 0.5;\n        rgb += _noise * noise;\n    }\n\n    if (lineWidth > 0.0)\n    {\n        float _c = curvature > 0. ? curvature : 1.;\n        float k = curvature > 0. ?(length(dir * dir) * 0.25 * _c * _c + 0.935 * _c) : 1.;\n        vec2 uv = dir * k;\n\n        float v = (verticalLine ? uv.x * dimensions.x : uv.y * dimensions.y) * min(1.0, 2.0 / lineWidth ) / _c;\n        float j = 1. + cos(v * 1.2 - time) * 0.5 * lineContrast;\n        rgb *= j;\n        float segment = verticalLine ? mod((dir.x + .5) * dimensions.x, 4.) : mod((dir.y + .5) * dimensions.y, 4.);\n        rgb *= 0.99 + ceil(segment) * 0.015;\n    }\n\n    if (vignetting > 0.0)\n    {\n        float outter = SQRT_2 - vignetting * SQRT_2;\n        float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + vignettingBlur * SQRT_2), 0.0, 1.0);\n        rgb *= darker + (1.0 - darker) * (1.0 - vignettingAlpha);\n    }\n\n    gl_FragColor.rgb = rgb;\n}\n")||this;return r.time=0,r.seed=0,r.uniforms.dimensions=new Float32Array(2),Object.assign(r,n.defaults,t),r}return u(n,e),n.prototype.apply=function(e,n,t,r){var o=n.filterFrame,i=o.width,l=o.height;this.uniforms.dimensions[0]=i,this.uniforms.dimensions[1]=l,this.uniforms.seed=this.seed,this.uniforms.time=this.time,e.applyFilter(this,n,t,r)},Object.defineProperty(n.prototype,"curvature",{get:function(){return this.uniforms.curvature},set:function(e){this.uniforms.curvature=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"lineWidth",{get:function(){return this.uniforms.lineWidth},set:function(e){this.uniforms.lineWidth=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"lineContrast",{get:function(){return this.uniforms.lineContrast},set:function(e){this.uniforms.lineContrast=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"verticalLine",{get:function(){return this.uniforms.verticalLine},set:function(e){this.uniforms.verticalLine=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"noise",{get:function(){return this.uniforms.noise},set:function(e){this.uniforms.noise=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"noiseSize",{get:function(){return this.uniforms.noiseSize},set:function(e){this.uniforms.noiseSize=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"vignetting",{get:function(){return this.uniforms.vignetting},set:function(e){this.uniforms.vignetting=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"vignettingAlpha",{get:function(){return this.uniforms.vignettingAlpha},set:function(e){this.uniforms.vignettingAlpha=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"vignettingBlur",{get:function(){return this.uniforms.vignettingBlur},set:function(e){this.uniforms.vignettingBlur=e},enumerable:!1,configurable:!0}),n.defaults={curvature:1,lineWidth:1,lineContrast:.25,verticalLine:!1,noise:0,noiseSize:1,seed:0,vignetting:.3,vignettingAlpha:1,vignettingBlur:.3,time:0},n}(n.Filter),O=function(e){function n(n,t){void 0===n&&(n=1),void 0===t&&(t=5);var r=e.call(this,c,"precision mediump float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform vec4 filterArea;\nuniform sampler2D uSampler;\n\nuniform float angle;\nuniform float scale;\n\nfloat pattern()\n{\n   float s = sin(angle), c = cos(angle);\n   vec2 tex = vTextureCoord * filterArea.xy;\n   vec2 point = vec2(\n       c * tex.x - s * tex.y,\n       s * tex.x + c * tex.y\n   ) * scale;\n   return (sin(point.x) * sin(point.y)) * 4.0;\n}\n\nvoid main()\n{\n   vec4 color = texture2D(uSampler, vTextureCoord);\n   float average = (color.r + color.g + color.b) / 3.0;\n   gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);\n}\n")||this;return r.scale=n,r.angle=t,r}return u(n,e),Object.defineProperty(n.prototype,"scale",{get:function(){return this.uniforms.scale},set:function(e){this.uniforms.scale=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"angle",{get:function(){return this.uniforms.angle},set:function(e){this.uniforms.angle=e},enumerable:!1,configurable:!0}),n}(n.Filter),P=function(e){function i(o){var l=e.call(this)||this;l.angle=45,l._distance=5,l._resolution=r.settings.FILTER_RESOLUTION;var a=o?f(f({},i.defaults),o):i.defaults,s=a.kernels,u=a.blur,m=a.quality,p=a.pixelSize,h=a.resolution;l._tintFilter=new n.Filter(c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float alpha;\nuniform vec3 color;\n\nuniform vec2 shift;\nuniform vec4 inputSize;\n\nvoid main(void){\n    vec4 sample = texture2D(uSampler, vTextureCoord - shift * inputSize.zw);\n\n    // Premultiply alpha\n    sample.rgb = color.rgb * sample.a;\n\n    // alpha user alpha\n    sample *= alpha;\n\n    gl_FragColor = sample;\n}"),l._tintFilter.uniforms.color=new Float32Array(4),l._tintFilter.uniforms.shift=new t.Point,l._tintFilter.resolution=h,l._blurFilter=s?new d(s):new d(u,m),l.pixelSize=p,l.resolution=h;var g=a.shadowOnly,v=a.rotation,y=a.distance,b=a.alpha,x=a.color;return l.shadowOnly=g,l.rotation=v,l.distance=y,l.alpha=b,l.color=x,l._updatePadding(),l}return u(i,e),i.prototype.apply=function(e,n,t,r){var o=e.getFilterTexture();this._tintFilter.apply(e,n,o,1),this._blurFilter.apply(e,o,t,r),!0!==this.shadowOnly&&e.applyFilter(this,n,t,0),e.returnFilterTexture(o)},i.prototype._updatePadding=function(){this.padding=this.distance+2*this.blur},i.prototype._updateShift=function(){this._tintFilter.uniforms.shift.set(this.distance*Math.cos(this.angle),this.distance*Math.sin(this.angle))},Object.defineProperty(i.prototype,"resolution",{get:function(){return this._resolution},set:function(e){this._resolution=e,this._tintFilter&&(this._tintFilter.resolution=e),this._blurFilter&&(this._blurFilter.resolution=e)},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,"distance",{get:function(){return this._distance},set:function(e){this._distance=e,this._updatePadding(),this._updateShift()},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,"rotation",{get:function(){return this.angle/t.DEG_TO_RAD},set:function(e){this.angle=e*t.DEG_TO_RAD,this._updateShift()},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,"alpha",{get:function(){return this._tintFilter.uniforms.alpha},set:function(e){this._tintFilter.uniforms.alpha=e},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,"color",{get:function(){return o.rgb2hex(this._tintFilter.uniforms.color)},set:function(e){o.hex2rgb(e,this._tintFilter.uniforms.color)},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,"kernels",{get:function(){return this._blurFilter.kernels},set:function(e){this._blurFilter.kernels=e},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,"blur",{get:function(){return this._blurFilter.blur},set:function(e){this._blurFilter.blur=e,this._updatePadding()},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,"quality",{get:function(){return this._blurFilter.quality},set:function(e){this._blurFilter.quality=e},enumerable:!1,configurable:!0}),Object.defineProperty(i.prototype,"pixelSize",{get:function(){return this._blurFilter.pixelSize},set:function(e){this._blurFilter.pixelSize=e},enumerable:!1,configurable:!0}),i.defaults={rotation:45,distance:5,color:0,alpha:.5,shadowOnly:!1,kernels:null,blur:2,quality:3,pixelSize:1,resolution:r.settings.FILTER_RESOLUTION},i}(n.Filter),A=function(e){function n(n){void 0===n&&(n=5);var t=e.call(this,c,"precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float strength;\nuniform vec4 filterArea;\n\n\nvoid main(void)\n{\n\tvec2 onePixel = vec2(1.0 / filterArea);\n\n\tvec4 color;\n\n\tcolor.rgb = vec3(0.5);\n\n\tcolor -= texture2D(uSampler, vTextureCoord - onePixel) * strength;\n\tcolor += texture2D(uSampler, vTextureCoord + onePixel) * strength;\n\n\tcolor.rgb = vec3((color.r + color.g + color.b) / 3.0);\n\n\tfloat alpha = texture2D(uSampler, vTextureCoord).a;\n\n\tgl_FragColor = vec4(color.rgb * alpha, alpha);\n}\n")||this;return t.strength=n,t}return u(n,e),Object.defineProperty(n.prototype,"strength",{get:function(){return this.uniforms.strength},set:function(e){this.uniforms.strength=e},enumerable:!1,configurable:!0}),n}(n.Filter),T=function(e){function r(t){var o=e.call(this,c,"// precision highp float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform vec2 dimensions;\nuniform float aspect;\n\nuniform sampler2D displacementMap;\nuniform float offset;\nuniform float sinDir;\nuniform float cosDir;\nuniform int fillMode;\n\nuniform float seed;\nuniform vec2 red;\nuniform vec2 green;\nuniform vec2 blue;\n\nconst int TRANSPARENT = 0;\nconst int ORIGINAL = 1;\nconst int LOOP = 2;\nconst int CLAMP = 3;\nconst int MIRROR = 4;\n\nvoid main(void)\n{\n    vec2 coord = (vTextureCoord * filterArea.xy) / dimensions;\n\n    if (coord.x > 1.0 || coord.y > 1.0) {\n        return;\n    }\n\n    float cx = coord.x - 0.5;\n    float cy = (coord.y - 0.5) * aspect;\n    float ny = (-sinDir * cx + cosDir * cy) / aspect + 0.5;\n\n    // displacementMap: repeat\n    // ny = ny > 1.0 ? ny - 1.0 : (ny < 0.0 ? 1.0 + ny : ny);\n\n    // displacementMap: mirror\n    ny = ny > 1.0 ? 2.0 - ny : (ny < 0.0 ? -ny : ny);\n\n    vec4 dc = texture2D(displacementMap, vec2(0.5, ny));\n\n    float displacement = (dc.r - dc.g) * (offset / filterArea.x);\n\n    coord = vTextureCoord + vec2(cosDir * displacement, sinDir * displacement * aspect);\n\n    if (fillMode == CLAMP) {\n        coord = clamp(coord, filterClamp.xy, filterClamp.zw);\n    } else {\n        if( coord.x > filterClamp.z ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.x -= filterClamp.z;\n            } else if (fillMode == MIRROR) {\n                coord.x = filterClamp.z * 2.0 - coord.x;\n            }\n        } else if( coord.x < filterClamp.x ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.x += filterClamp.z;\n            } else if (fillMode == MIRROR) {\n                coord.x *= -filterClamp.z;\n            }\n        }\n\n        if( coord.y > filterClamp.w ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.y -= filterClamp.w;\n            } else if (fillMode == MIRROR) {\n                coord.y = filterClamp.w * 2.0 - coord.y;\n            }\n        } else if( coord.y < filterClamp.y ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.y += filterClamp.w;\n            } else if (fillMode == MIRROR) {\n                coord.y *= -filterClamp.w;\n            }\n        }\n    }\n\n    gl_FragColor.r = texture2D(uSampler, coord + red * (1.0 - seed * 0.4) / filterArea.xy).r;\n    gl_FragColor.g = texture2D(uSampler, coord + green * (1.0 - seed * 0.3) / filterArea.xy).g;\n    gl_FragColor.b = texture2D(uSampler, coord + blue * (1.0 - seed * 0.2) / filterArea.xy).b;\n    gl_FragColor.a = texture2D(uSampler, coord).a;\n}\n")||this;return o.offset=100,o.fillMode=r.TRANSPARENT,o.average=!1,o.seed=0,o.minSize=8,o.sampleSize=512,o._slices=0,o._offsets=new Float32Array(1),o._sizes=new Float32Array(1),o._direction=-1,o.uniforms.dimensions=new Float32Array(2),o._canvas=document.createElement("canvas"),o._canvas.width=4,o._canvas.height=o.sampleSize,o.texture=n.Texture.from(o._canvas,{scaleMode:i.SCALE_MODES.NEAREST}),Object.assign(o,r.defaults,t),o}return u(r,e),r.prototype.apply=function(e,n,t,r){var o=n.filterFrame,i=o.width,l=o.height;this.uniforms.dimensions[0]=i,this.uniforms.dimensions[1]=l,this.uniforms.aspect=l/i,this.uniforms.seed=this.seed,this.uniforms.offset=this.offset,this.uniforms.fillMode=this.fillMode,e.applyFilter(this,n,t,r)},r.prototype._randomizeSizes=function(){var e=this._sizes,n=this._slices-1,t=this.sampleSize,r=Math.min(this.minSize/t,.9/this._slices);if(this.average){for(var o=this._slices,i=1,l=0;l<n;l++){var a=i/(o-l),s=Math.max(a*(1-.6*Math.random()),r);e[l]=s,i-=s}e[n]=i}else{i=1;var u=Math.sqrt(1/this._slices);for(l=0;l<n;l++){s=Math.max(u*i*Math.random(),r);e[l]=s,i-=s}e[n]=i}this.shuffle()},r.prototype.shuffle=function(){for(var e=this._sizes,n=this._slices-1;n>0;n--){var t=Math.random()*n>>0,r=e[n];e[n]=e[t],e[t]=r}},r.prototype._randomizeOffsets=function(){for(var e=0;e<this._slices;e++)this._offsets[e]=Math.random()*(Math.random()<.5?-1:1)},r.prototype.refresh=function(){this._randomizeSizes(),this._randomizeOffsets(),this.redraw()},r.prototype.redraw=function(){var e,n=this.sampleSize,t=this.texture,r=this._canvas.getContext("2d");r.clearRect(0,0,8,n);for(var o=0,i=0;i<this._slices;i++){e=Math.floor(256*this._offsets[i]);var l=this._sizes[i]*n,a=e>0?e:0,s=e<0?-e:0;r.fillStyle="rgba("+a+", "+s+", 0, 1)",r.fillRect(0,o>>0,n,l+1>>0),o+=l}t.baseTexture.update(),this.uniforms.displacementMap=t},Object.defineProperty(r.prototype,"sizes",{get:function(){return this._sizes},set:function(e){for(var n=Math.min(this._slices,e.length),t=0;t<n;t++)this._sizes[t]=e[t]},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"offsets",{get:function(){return this._offsets},set:function(e){for(var n=Math.min(this._slices,e.length),t=0;t<n;t++)this._offsets[t]=e[t]},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"slices",{get:function(){return this._slices},set:function(e){this._slices!==e&&(this._slices=e,this.uniforms.slices=e,this._sizes=this.uniforms.slicesWidth=new Float32Array(e),this._offsets=this.uniforms.slicesOffset=new Float32Array(e),this.refresh())},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"direction",{get:function(){return this._direction},set:function(e){if(this._direction!==e){this._direction=e;var n=e*t.DEG_TO_RAD;this.uniforms.sinDir=Math.sin(n),this.uniforms.cosDir=Math.cos(n)}},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"red",{get:function(){return this.uniforms.red},set:function(e){this.uniforms.red=e},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"green",{get:function(){return this.uniforms.green},set:function(e){this.uniforms.green=e},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"blue",{get:function(){return this.uniforms.blue},set:function(e){this.uniforms.blue=e},enumerable:!1,configurable:!0}),r.prototype.destroy=function(){var e;null===(e=this.texture)||void 0===e||e.destroy(!0),this.texture=this._canvas=this.red=this.green=this.blue=this._sizes=this._offsets=null},r.defaults={slices:5,offset:100,direction:0,fillMode:0,average:!1,seed:0,red:[0,0],green:[0,0],blue:[0,0],minSize:8,sampleSize:512},r.TRANSPARENT=0,r.ORIGINAL=1,r.LOOP=2,r.CLAMP=3,r.MIRROR=4,r}(n.Filter),w=function(e){function n(t){var r=this,o=Object.assign({},n.defaults,t),i=o.outerStrength,l=o.innerStrength,a=o.color,s=o.knockout,u=o.quality,f=Math.round(o.distance);return(r=e.call(this,c,"varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nuniform float outerStrength;\nuniform float innerStrength;\n\nuniform vec4 glowColor;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform bool knockout;\n\nconst float PI = 3.14159265358979323846264;\n\nconst float DIST = __DIST__;\nconst float ANGLE_STEP_SIZE = min(__ANGLE_STEP_SIZE__, PI * 2.0);\nconst float ANGLE_STEP_NUM = ceil(PI * 2.0 / ANGLE_STEP_SIZE);\n\nconst float MAX_TOTAL_ALPHA = ANGLE_STEP_NUM * DIST * (DIST + 1.0) / 2.0;\n\nvoid main(void) {\n    vec2 px = vec2(1.0 / filterArea.x, 1.0 / filterArea.y);\n\n    float totalAlpha = 0.0;\n\n    vec2 direction;\n    vec2 displaced;\n    vec4 curColor;\n\n    for (float angle = 0.0; angle < PI * 2.0; angle += ANGLE_STEP_SIZE) {\n       direction = vec2(cos(angle), sin(angle)) * px;\n\n       for (float curDistance = 0.0; curDistance < DIST; curDistance++) {\n           displaced = clamp(vTextureCoord + direction * \n                   (curDistance + 1.0), filterClamp.xy, filterClamp.zw);\n\n           curColor = texture2D(uSampler, displaced);\n\n           totalAlpha += (DIST - curDistance) * curColor.a;\n       }\n    }\n    \n    curColor = texture2D(uSampler, vTextureCoord);\n\n    float alphaRatio = (totalAlpha / MAX_TOTAL_ALPHA);\n\n    float innerGlowAlpha = (1.0 - alphaRatio) * innerStrength * curColor.a;\n    float innerGlowStrength = min(1.0, innerGlowAlpha);\n    \n    vec4 innerColor = mix(curColor, glowColor, innerGlowStrength);\n\n    float outerGlowAlpha = alphaRatio * outerStrength * (1. - curColor.a);\n    float outerGlowStrength = min(1.0 - innerColor.a, outerGlowAlpha);\n\n    vec4 outerGlowColor = outerGlowStrength * glowColor.rgba;\n    \n    if (knockout) {\n      float resultAlpha = outerGlowAlpha + innerGlowAlpha;\n      gl_FragColor = vec4(glowColor.rgb * resultAlpha, resultAlpha);\n    }\n    else {\n      gl_FragColor = innerColor + outerGlowColor;\n    }\n}\n".replace(/__ANGLE_STEP_SIZE__/gi,""+(1/u/f).toFixed(7)).replace(/__DIST__/gi,f.toFixed(0)+".0"))||this).uniforms.glowColor=new Float32Array([0,0,0,1]),Object.assign(r,{color:a,outerStrength:i,innerStrength:l,padding:f,knockout:s}),r}return u(n,e),Object.defineProperty(n.prototype,"color",{get:function(){return o.rgb2hex(this.uniforms.glowColor)},set:function(e){o.hex2rgb(e,this.uniforms.glowColor)},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"outerStrength",{get:function(){return this.uniforms.outerStrength},set:function(e){this.uniforms.outerStrength=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"innerStrength",{get:function(){return this.uniforms.innerStrength},set:function(e){this.uniforms.innerStrength=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"knockout",{get:function(){return this.uniforms.knockout},set:function(e){this.uniforms.knockout=e},enumerable:!1,configurable:!0}),n.defaults={distance:10,outerStrength:4,innerStrength:0,color:16777215,quality:.1,knockout:!1},n}(n.Filter),D=function(e){function n(r){var o=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec2 dimensions;\n\nuniform vec2 light;\nuniform bool parallel;\nuniform float aspect;\n\nuniform float gain;\nuniform float lacunarity;\nuniform float time;\nuniform float alpha;\n\n${perlin}\n\nvoid main(void) {\n    vec2 coord = vTextureCoord * filterArea.xy / dimensions.xy;\n\n    float d;\n\n    if (parallel) {\n        float _cos = light.x;\n        float _sin = light.y;\n        d = (_cos * coord.x) + (_sin * coord.y * aspect);\n    } else {\n        float dx = coord.x - light.x / dimensions.x;\n        float dy = (coord.y - light.y / dimensions.y) * aspect;\n        float dis = sqrt(dx * dx + dy * dy) + 0.00001;\n        d = dy / dis;\n    }\n\n    vec3 dir = vec3(d, d, 0.0);\n\n    float noise = turb(dir + vec3(time, 0.0, 62.1 + time) * 0.05, vec3(480.0, 320.0, 480.0), lacunarity, gain);\n    noise = mix(noise, 0.0, 0.3);\n    //fade vertically.\n    vec4 mist = vec4(noise, noise, noise, 1.0) * (1.0 - coord.y);\n    mist.a = 1.0;\n    // apply user alpha\n    mist *= alpha;\n\n    gl_FragColor = texture2D(uSampler, vTextureCoord) + mist;\n\n}\n".replace("${perlin}","vec3 mod289(vec3 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289(vec4 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 permute(vec4 x)\n{\n    return mod289(((x * 34.0) + 1.0) * x);\n}\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\nvec3 fade(vec3 t)\n{\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n{\n    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n    vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\n    vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\n    vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\n    vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\n    vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\n    vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\n    vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\n    vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}\nfloat turb(vec3 P, vec3 rep, float lacunarity, float gain)\n{\n    float sum = 0.0;\n    float sc = 1.0;\n    float totalgain = 1.0;\n    for (float i = 0.0; i < 6.0; i++)\n    {\n        sum += totalgain * pnoise(P * sc, rep);\n        sc *= lacunarity;\n        totalgain *= gain;\n    }\n    return abs(sum);\n}\n"))||this;o.parallel=!0,o.time=0,o._angle=0,o.uniforms.dimensions=new Float32Array(2);var i=Object.assign(n.defaults,r);return o._angleLight=new t.Point,o.angle=i.angle,o.gain=i.gain,o.lacunarity=i.lacunarity,o.alpha=i.alpha,o.parallel=i.parallel,o.center=i.center,o.time=i.time,o}return u(n,e),n.prototype.apply=function(e,n,t,r){var o=n.filterFrame,i=o.width,l=o.height;this.uniforms.light=this.parallel?this._angleLight:this.center,this.uniforms.parallel=this.parallel,this.uniforms.dimensions[0]=i,this.uniforms.dimensions[1]=l,this.uniforms.aspect=l/i,this.uniforms.time=this.time,this.uniforms.alpha=this.alpha,e.applyFilter(this,n,t,r)},Object.defineProperty(n.prototype,"angle",{get:function(){return this._angle},set:function(e){this._angle=e;var n=e*t.DEG_TO_RAD;this._angleLight.x=Math.cos(n),this._angleLight.y=Math.sin(n)},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"gain",{get:function(){return this.uniforms.gain},set:function(e){this.uniforms.gain=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"lacunarity",{get:function(){return this.uniforms.lacunarity},set:function(e){this.uniforms.lacunarity=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"alpha",{get:function(){return this.uniforms.alpha},set:function(e){this.uniforms.alpha=e},enumerable:!1,configurable:!0}),n.defaults={angle:30,gain:.5,lacunarity:2.5,time:0,parallel:!0,center:[0,0],alpha:1},n}(n.Filter),j=function(e){function n(n,r,o){void 0===n&&(n=[0,0]),void 0===r&&(r=5),void 0===o&&(o=0);var i=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform vec2 uVelocity;\nuniform int uKernelSize;\nuniform float uOffset;\n\nconst int MAX_KERNEL_SIZE = 2048;\n\n// Notice:\n// the perfect way:\n//    int kernelSize = min(uKernelSize, MAX_KERNELSIZE);\n// BUT in real use-case , uKernelSize < MAX_KERNELSIZE almost always.\n// So use uKernelSize directly.\n\nvoid main(void)\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    if (uKernelSize == 0)\n    {\n        gl_FragColor = color;\n        return;\n    }\n\n    vec2 velocity = uVelocity / filterArea.xy;\n    float offset = -uOffset / length(uVelocity) - 0.5;\n    int k = uKernelSize - 1;\n\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\n        if (i == k) {\n            break;\n        }\n        vec2 bias = velocity * (float(i) / float(k) + offset);\n        color += texture2D(uSampler, vTextureCoord + bias);\n    }\n    gl_FragColor = color / float(uKernelSize);\n}\n")||this;return i.kernelSize=5,i.uniforms.uVelocity=new Float32Array(2),i._velocity=new t.ObservablePoint(i.velocityChanged,i),i.setVelocity(n),i.kernelSize=r,i.offset=o,i}return u(n,e),n.prototype.apply=function(e,n,t,r){var o=this.velocity,i=o.x,l=o.y;this.uniforms.uKernelSize=0!==i||0!==l?this.kernelSize:0,e.applyFilter(this,n,t,r)},Object.defineProperty(n.prototype,"velocity",{get:function(){return this._velocity},set:function(e){this.setVelocity(e)},enumerable:!1,configurable:!0}),n.prototype.setVelocity=function(e){if(Array.isArray(e)){var n=e[0],t=e[1];this._velocity.set(n,t)}else this._velocity.copyFrom(e)},n.prototype.velocityChanged=function(){this.uniforms.uVelocity[0]=this._velocity.x,this.uniforms.uVelocity[1]=this._velocity.y,this.padding=1+(Math.max(Math.abs(this._velocity.x),Math.abs(this._velocity.y))>>0)},Object.defineProperty(n.prototype,"offset",{get:function(){return this.uniforms.uOffset},set:function(e){this.uniforms.uOffset=e},enumerable:!1,configurable:!0}),n}(n.Filter),M=function(e){function n(n,t,r){void 0===t&&(t=.05),void 0===r&&(r=n.length);var o=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform float epsilon;\n\nconst int MAX_COLORS = %maxColors%;\n\nuniform vec3 originalColors[MAX_COLORS];\nuniform vec3 targetColors[MAX_COLORS];\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n\n    float alpha = gl_FragColor.a;\n    if (alpha < 0.0001)\n    {\n      return;\n    }\n\n    vec3 color = gl_FragColor.rgb / alpha;\n\n    for(int i = 0; i < MAX_COLORS; i++)\n    {\n      vec3 origColor = originalColors[i];\n      if (origColor.r < 0.0)\n      {\n        break;\n      }\n      vec3 colorDiff = origColor - color;\n      if (length(colorDiff) < epsilon)\n      {\n        vec3 targetColor = targetColors[i];\n        gl_FragColor = vec4((targetColor + colorDiff) * alpha, alpha);\n        return;\n      }\n    }\n}\n".replace(/%maxColors%/g,r.toFixed(0)))||this;return o._replacements=[],o._maxColors=0,o.epsilon=t,o._maxColors=r,o.uniforms.originalColors=new Float32Array(3*r),o.uniforms.targetColors=new Float32Array(3*r),o.replacements=n,o}return u(n,e),Object.defineProperty(n.prototype,"replacements",{get:function(){return this._replacements},set:function(e){var n=this.uniforms.originalColors,t=this.uniforms.targetColors,r=e.length;if(r>this._maxColors)throw new Error("Length of replacements ("+r+") exceeds the maximum colors length ("+this._maxColors+")");n[3*r]=-1;for(var i=0;i<r;i++){var l=e[i],a=l[0];"number"==typeof a?a=o.hex2rgb(a):l[0]=o.rgb2hex(a),n[3*i]=a[0],n[3*i+1]=a[1],n[3*i+2]=a[2];var s=l[1];"number"==typeof s?s=o.hex2rgb(s):l[1]=o.rgb2hex(s),t[3*i]=s[0],t[3*i+1]=s[1],t[3*i+2]=s[2]}this._replacements=e},enumerable:!1,configurable:!0}),n.prototype.refresh=function(){this.replacements=this._replacements},Object.defineProperty(n.prototype,"maxColors",{get:function(){return this._maxColors},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"epsilon",{get:function(){return this.uniforms.epsilon},set:function(e){this.uniforms.epsilon=e},enumerable:!1,configurable:!0}),n}(n.Filter),R=function(e){function n(t,r){void 0===r&&(r=0);var o=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec2 dimensions;\n\nuniform float sepia;\nuniform float noise;\nuniform float noiseSize;\nuniform float scratch;\nuniform float scratchDensity;\nuniform float scratchWidth;\nuniform float vignetting;\nuniform float vignettingAlpha;\nuniform float vignettingBlur;\nuniform float seed;\n\nconst float SQRT_2 = 1.414213;\nconst vec3 SEPIA_RGB = vec3(112.0 / 255.0, 66.0 / 255.0, 20.0 / 255.0);\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 Overlay(vec3 src, vec3 dst)\n{\n    // if (dst <= 0.5) then: 2 * src * dst\n    // if (dst > 0.5) then: 1 - 2 * (1 - dst) * (1 - src)\n    return vec3((dst.x <= 0.5) ? (2.0 * src.x * dst.x) : (1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)),\n                (dst.y <= 0.5) ? (2.0 * src.y * dst.y) : (1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)),\n                (dst.z <= 0.5) ? (2.0 * src.z * dst.z) : (1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)));\n}\n\n\nvoid main()\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n    vec3 color = gl_FragColor.rgb;\n\n    if (sepia > 0.0)\n    {\n        float gray = (color.x + color.y + color.z) / 3.0;\n        vec3 grayscale = vec3(gray);\n\n        color = Overlay(SEPIA_RGB, grayscale);\n\n        color = grayscale + sepia * (color - grayscale);\n    }\n\n    vec2 coord = vTextureCoord * filterArea.xy / dimensions.xy;\n\n    if (vignetting > 0.0)\n    {\n        float outter = SQRT_2 - vignetting * SQRT_2;\n        vec2 dir = vec2(vec2(0.5, 0.5) - coord);\n        dir.y *= dimensions.y / dimensions.x;\n        float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + vignettingBlur * SQRT_2), 0.0, 1.0);\n        color.rgb *= darker + (1.0 - darker) * (1.0 - vignettingAlpha);\n    }\n\n    if (scratchDensity > seed && scratch != 0.0)\n    {\n        float phase = seed * 256.0;\n        float s = mod(floor(phase), 2.0);\n        float dist = 1.0 / scratchDensity;\n        float d = distance(coord, vec2(seed * dist, abs(s - seed * dist)));\n        if (d < seed * 0.6 + 0.4)\n        {\n            highp float period = scratchDensity * 10.0;\n\n            float xx = coord.x * period + phase;\n            float aa = abs(mod(xx, 0.5) * 4.0);\n            float bb = mod(floor(xx / 0.5), 2.0);\n            float yy = (1.0 - bb) * aa + bb * (2.0 - aa);\n\n            float kk = 2.0 * period;\n            float dw = scratchWidth / dimensions.x * (0.75 + seed);\n            float dh = dw * kk;\n\n            float tine = (yy - (2.0 - dh));\n\n            if (tine > 0.0) {\n                float _sign = sign(scratch);\n\n                tine = s * tine / period + scratch + 0.1;\n                tine = clamp(tine + 1.0, 0.5 + _sign * 0.5, 1.5 + _sign * 0.5);\n\n                color.rgb *= tine;\n            }\n        }\n    }\n\n    if (noise > 0.0 && noiseSize > 0.0)\n    {\n        vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\n        pixelCoord.x = floor(pixelCoord.x / noiseSize);\n        pixelCoord.y = floor(pixelCoord.y / noiseSize);\n        // vec2 d = pixelCoord * noiseSize * vec2(1024.0 + seed * 512.0, 1024.0 - seed * 512.0);\n        // float _noise = snoise(d) * 0.5;\n        float _noise = rand(pixelCoord * noiseSize * seed) - 0.5;\n        color += _noise * noise;\n    }\n\n    gl_FragColor.rgb = color;\n}\n")||this;return o.seed=0,o.uniforms.dimensions=new Float32Array(2),"number"==typeof t?(o.seed=t,t=void 0):o.seed=r,Object.assign(o,n.defaults,t),o}return u(n,e),n.prototype.apply=function(e,n,t,r){var o,i;this.uniforms.dimensions[0]=null===(o=n.filterFrame)||void 0===o?void 0:o.width,this.uniforms.dimensions[1]=null===(i=n.filterFrame)||void 0===i?void 0:i.height,this.uniforms.seed=this.seed,e.applyFilter(this,n,t,r)},Object.defineProperty(n.prototype,"sepia",{get:function(){return this.uniforms.sepia},set:function(e){this.uniforms.sepia=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"noise",{get:function(){return this.uniforms.noise},set:function(e){this.uniforms.noise=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"noiseSize",{get:function(){return this.uniforms.noiseSize},set:function(e){this.uniforms.noiseSize=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"scratch",{get:function(){return this.uniforms.scratch},set:function(e){this.uniforms.scratch=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"scratchDensity",{get:function(){return this.uniforms.scratchDensity},set:function(e){this.uniforms.scratchDensity=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"scratchWidth",{get:function(){return this.uniforms.scratchWidth},set:function(e){this.uniforms.scratchWidth=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"vignetting",{get:function(){return this.uniforms.vignetting},set:function(e){this.uniforms.vignetting=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"vignettingAlpha",{get:function(){return this.uniforms.vignettingAlpha},set:function(e){this.uniforms.vignettingAlpha=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"vignettingBlur",{get:function(){return this.uniforms.vignettingBlur},set:function(e){this.uniforms.vignettingBlur=e},enumerable:!1,configurable:!0}),n.defaults={sepia:.3,noise:.3,noiseSize:1,scratch:.5,scratchDensity:.3,scratchWidth:1,vignetting:.3,vignettingAlpha:1,vignettingBlur:.3},n}(n.Filter),E=function(e){function n(t,r,o){void 0===t&&(t=1),void 0===r&&(r=0),void 0===o&&(o=.1);var i=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec2 thickness;\nuniform vec4 outlineColor;\nuniform vec4 filterClamp;\n\nconst float DOUBLE_PI = 3.14159265358979323846264 * 2.;\n\nvoid main(void) {\n    vec4 ownColor = texture2D(uSampler, vTextureCoord);\n    vec4 curColor;\n    float maxAlpha = 0.;\n    vec2 displaced;\n    for (float angle = 0.; angle <= DOUBLE_PI; angle += ${angleStep}) {\n        displaced.x = vTextureCoord.x + thickness.x * cos(angle);\n        displaced.y = vTextureCoord.y + thickness.y * sin(angle);\n        curColor = texture2D(uSampler, clamp(displaced, filterClamp.xy, filterClamp.zw));\n        maxAlpha = max(maxAlpha, curColor.a);\n    }\n    float resultAlpha = max(maxAlpha, ownColor.a);\n    gl_FragColor = vec4((ownColor.rgb + outlineColor.rgb * (1. - ownColor.a)) * resultAlpha, resultAlpha);\n}\n".replace(/\$\{angleStep\}/,n.getAngleStep(o)))||this;return i._thickness=1,i.uniforms.thickness=new Float32Array([0,0]),i.uniforms.outlineColor=new Float32Array([0,0,0,1]),Object.assign(i,{thickness:t,color:r,quality:o}),i}return u(n,e),n.getAngleStep=function(e){var t=Math.max(e*n.MAX_SAMPLES,n.MIN_SAMPLES);return(2*Math.PI/t).toFixed(7)},n.prototype.apply=function(e,n,t,r){this.uniforms.thickness[0]=this._thickness/n._frame.width,this.uniforms.thickness[1]=this._thickness/n._frame.height,e.applyFilter(this,n,t,r)},Object.defineProperty(n.prototype,"color",{get:function(){return o.rgb2hex(this.uniforms.outlineColor)},set:function(e){o.hex2rgb(e,this.uniforms.outlineColor)},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"thickness",{get:function(){return this._thickness},set:function(e){this._thickness=e,this.padding=e},enumerable:!1,configurable:!0}),n.MIN_SAMPLES=1,n.MAX_SAMPLES=100,n}(n.Filter),I=function(e){function n(n){void 0===n&&(n=10);var t=e.call(this,c,"precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform vec2 size;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= filterArea.xy;\n    coord += filterArea.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= filterArea.zw;\n    coord /= filterArea.xy;\n\n    return coord;\n}\n\nvec2 pixelate(vec2 coord, vec2 size)\n{\n\treturn floor( coord / size ) * size;\n}\n\nvoid main(void)\n{\n    vec2 coord = mapCoord(vTextureCoord);\n\n    coord = pixelate(coord, size);\n\n    coord = unmapCoord(coord);\n\n    gl_FragColor = texture2D(uSampler, coord);\n}\n")||this;return t.size=n,t}return u(n,e),Object.defineProperty(n.prototype,"size",{get:function(){return this.uniforms.size},set:function(e){"number"==typeof e&&(e=[e,e]),this.uniforms.size=e},enumerable:!1,configurable:!0}),n}(n.Filter),k=function(e){function n(n,t,r,o){void 0===n&&(n=0),void 0===t&&(t=[0,0]),void 0===r&&(r=5),void 0===o&&(o=-1);var i=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform float uRadian;\nuniform vec2 uCenter;\nuniform float uRadius;\nuniform int uKernelSize;\n\nconst int MAX_KERNEL_SIZE = 2048;\n\nvoid main(void)\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    if (uKernelSize == 0)\n    {\n        gl_FragColor = color;\n        return;\n    }\n\n    float aspect = filterArea.y / filterArea.x;\n    vec2 center = uCenter.xy / filterArea.xy;\n    float gradient = uRadius / filterArea.x * 0.3;\n    float radius = uRadius / filterArea.x - gradient * 0.5;\n    int k = uKernelSize - 1;\n\n    vec2 coord = vTextureCoord;\n    vec2 dir = vec2(center - coord);\n    float dist = length(vec2(dir.x, dir.y * aspect));\n\n    float radianStep = uRadian;\n    if (radius >= 0.0 && dist > radius) {\n        float delta = dist - radius;\n        float gap = gradient;\n        float scale = 1.0 - abs(delta / gap);\n        if (scale <= 0.0) {\n            gl_FragColor = color;\n            return;\n        }\n        radianStep *= scale;\n    }\n    radianStep /= float(k);\n\n    float s = sin(radianStep);\n    float c = cos(radianStep);\n    mat2 rotationMatrix = mat2(vec2(c, -s), vec2(s, c));\n\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\n        if (i == k) {\n            break;\n        }\n\n        coord -= center;\n        coord.y *= aspect;\n        coord = rotationMatrix * coord;\n        coord.y /= aspect;\n        coord += center;\n\n        vec4 sample = texture2D(uSampler, coord);\n\n        // switch to pre-multiplied alpha to correctly blur transparent images\n        // sample.rgb *= sample.a;\n\n        color += sample;\n    }\n\n    gl_FragColor = color / float(uKernelSize);\n}\n")||this;return i._angle=0,i.angle=n,i.center=t,i.kernelSize=r,i.radius=o,i}return u(n,e),n.prototype.apply=function(e,n,t,r){this.uniforms.uKernelSize=0!==this._angle?this.kernelSize:0,e.applyFilter(this,n,t,r)},Object.defineProperty(n.prototype,"angle",{get:function(){return this._angle},set:function(e){this._angle=e,this.uniforms.uRadian=e*Math.PI/180},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"center",{get:function(){return this.uniforms.uCenter},set:function(e){this.uniforms.uCenter=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"radius",{get:function(){return this.uniforms.uRadius},set:function(e){(e<0||e===1/0)&&(e=-1),this.uniforms.uRadius=e},enumerable:!1,configurable:!0}),n}(n.Filter),L=function(e){function n(t){var r=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform vec2 dimensions;\n\nuniform bool mirror;\nuniform float boundary;\nuniform vec2 amplitude;\nuniform vec2 waveLength;\nuniform vec2 alpha;\nuniform float time;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main(void)\n{\n    vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\n    vec2 coord = pixelCoord / dimensions;\n\n    if (coord.y < boundary) {\n        gl_FragColor = texture2D(uSampler, vTextureCoord);\n        return;\n    }\n\n    float k = (coord.y - boundary) / (1. - boundary + 0.0001);\n    float areaY = boundary * dimensions.y / filterArea.y;\n    float v = areaY + areaY - vTextureCoord.y;\n    float y = mirror ? v : vTextureCoord.y;\n\n    float _amplitude = ((amplitude.y - amplitude.x) * k + amplitude.x ) / filterArea.x;\n    float _waveLength = ((waveLength.y - waveLength.x) * k + waveLength.x) / filterArea.y;\n    float _alpha = (alpha.y - alpha.x) * k + alpha.x;\n\n    float x = vTextureCoord.x + cos(v * 6.28 / _waveLength - time) * _amplitude;\n    x = clamp(x, filterClamp.x, filterClamp.z);\n\n    vec4 color = texture2D(uSampler, vec2(x, y));\n\n    gl_FragColor = color * _alpha;\n}\n")||this;return r.time=0,r.uniforms.amplitude=new Float32Array(2),r.uniforms.waveLength=new Float32Array(2),r.uniforms.alpha=new Float32Array(2),r.uniforms.dimensions=new Float32Array(2),Object.assign(r,n.defaults,t),r}return u(n,e),n.prototype.apply=function(e,n,t,r){var o,i;this.uniforms.dimensions[0]=null===(o=n.filterFrame)||void 0===o?void 0:o.width,this.uniforms.dimensions[1]=null===(i=n.filterFrame)||void 0===i?void 0:i.height,this.uniforms.time=this.time,e.applyFilter(this,n,t,r)},Object.defineProperty(n.prototype,"mirror",{get:function(){return this.uniforms.mirror},set:function(e){this.uniforms.mirror=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"boundary",{get:function(){return this.uniforms.boundary},set:function(e){this.uniforms.boundary=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"amplitude",{get:function(){return this.uniforms.amplitude},set:function(e){this.uniforms.amplitude[0]=e[0],this.uniforms.amplitude[1]=e[1]},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"waveLength",{get:function(){return this.uniforms.waveLength},set:function(e){this.uniforms.waveLength[0]=e[0],this.uniforms.waveLength[1]=e[1]},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"alpha",{get:function(){return this.uniforms.alpha},set:function(e){this.uniforms.alpha[0]=e[0],this.uniforms.alpha[1]=e[1]},enumerable:!1,configurable:!0}),n.defaults={mirror:!0,boundary:.5,amplitude:[0,20],waveLength:[30,100],alpha:[1,1],time:0},n}(n.Filter),N=function(e){function n(n,t,r){void 0===n&&(n=[-10,0]),void 0===t&&(t=[0,10]),void 0===r&&(r=[0,0]);var o=e.call(this,c,"precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec2 red;\nuniform vec2 green;\nuniform vec2 blue;\n\nvoid main(void)\n{\n   gl_FragColor.r = texture2D(uSampler, vTextureCoord + red/filterArea.xy).r;\n   gl_FragColor.g = texture2D(uSampler, vTextureCoord + green/filterArea.xy).g;\n   gl_FragColor.b = texture2D(uSampler, vTextureCoord + blue/filterArea.xy).b;\n   gl_FragColor.a = texture2D(uSampler, vTextureCoord).a;\n}\n")||this;return o.red=n,o.green=t,o.blue=r,o}return u(n,e),Object.defineProperty(n.prototype,"red",{get:function(){return this.uniforms.red},set:function(e){this.uniforms.red=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"green",{get:function(){return this.uniforms.green},set:function(e){this.uniforms.green=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"blue",{get:function(){return this.uniforms.blue},set:function(e){this.uniforms.blue=e},enumerable:!1,configurable:!0}),n}(n.Filter),X=function(e){function n(t,r,o){void 0===t&&(t=[0,0]),void 0===o&&(o=0);var i=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\n\nuniform vec2 center;\n\nuniform float amplitude;\nuniform float wavelength;\n// uniform float power;\nuniform float brightness;\nuniform float speed;\nuniform float radius;\n\nuniform float time;\n\nconst float PI = 3.14159;\n\nvoid main()\n{\n    float halfWavelength = wavelength * 0.5 / filterArea.x;\n    float maxRadius = radius / filterArea.x;\n    float currentRadius = time * speed / filterArea.x;\n\n    float fade = 1.0;\n\n    if (maxRadius > 0.0) {\n        if (currentRadius > maxRadius) {\n            gl_FragColor = texture2D(uSampler, vTextureCoord);\n            return;\n        }\n        fade = 1.0 - pow(currentRadius / maxRadius, 2.0);\n    }\n\n    vec2 dir = vec2(vTextureCoord - center / filterArea.xy);\n    dir.y *= filterArea.y / filterArea.x;\n    float dist = length(dir);\n\n    if (dist <= 0.0 || dist < currentRadius - halfWavelength || dist > currentRadius + halfWavelength) {\n        gl_FragColor = texture2D(uSampler, vTextureCoord);\n        return;\n    }\n\n    vec2 diffUV = normalize(dir);\n\n    float diff = (dist - currentRadius) / halfWavelength;\n\n    float p = 1.0 - pow(abs(diff), 2.0);\n\n    // float powDiff = diff * pow(p, 2.0) * ( amplitude * fade );\n    float powDiff = 1.25 * sin(diff * PI) * p * ( amplitude * fade );\n\n    vec2 offset = diffUV * powDiff / filterArea.xy;\n\n    // Do clamp :\n    vec2 coord = vTextureCoord + offset;\n    vec2 clampedCoord = clamp(coord, filterClamp.xy, filterClamp.zw);\n    vec4 color = texture2D(uSampler, clampedCoord);\n    if (coord != clampedCoord) {\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\n    }\n\n    // No clamp :\n    // gl_FragColor = texture2D(uSampler, vTextureCoord + offset);\n\n    color.rgb *= 1.0 + (brightness - 1.0) * p * fade;\n\n    gl_FragColor = color;\n}\n")||this;return i.center=t,Object.assign(i,n.defaults,r),i.time=o,i}return u(n,e),n.prototype.apply=function(e,n,t,r){this.uniforms.time=this.time,e.applyFilter(this,n,t,r)},Object.defineProperty(n.prototype,"center",{get:function(){return this.uniforms.center},set:function(e){this.uniforms.center=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"amplitude",{get:function(){return this.uniforms.amplitude},set:function(e){this.uniforms.amplitude=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"wavelength",{get:function(){return this.uniforms.wavelength},set:function(e){this.uniforms.wavelength=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"brightness",{get:function(){return this.uniforms.brightness},set:function(e){this.uniforms.brightness=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"speed",{get:function(){return this.uniforms.speed},set:function(e){this.uniforms.speed=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"radius",{get:function(){return this.uniforms.radius},set:function(e){this.uniforms.radius=e},enumerable:!1,configurable:!0}),n.defaults={amplitude:30,wavelength:160,brightness:1,speed:500,radius:-1},n}(n.Filter),B=function(e){function n(n,t,r){void 0===t&&(t=0),void 0===r&&(r=1);var o=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform sampler2D uLightmap;\nuniform vec4 filterArea;\nuniform vec2 dimensions;\nuniform vec4 ambientColor;\nvoid main() {\n    vec4 diffuseColor = texture2D(uSampler, vTextureCoord);\n    vec2 lightCoord = (vTextureCoord * filterArea.xy) / dimensions;\n    vec4 light = texture2D(uLightmap, lightCoord);\n    vec3 ambient = ambientColor.rgb * ambientColor.a;\n    vec3 intensity = ambient + light.rgb;\n    vec3 finalColor = diffuseColor.rgb * intensity;\n    gl_FragColor = vec4(finalColor, diffuseColor.a);\n}\n")||this;return o._color=0,o.uniforms.dimensions=new Float32Array(2),o.uniforms.ambientColor=new Float32Array([0,0,0,r]),o.texture=n,o.color=t,o}return u(n,e),n.prototype.apply=function(e,n,t,r){var o,i;this.uniforms.dimensions[0]=null===(o=n.filterFrame)||void 0===o?void 0:o.width,this.uniforms.dimensions[1]=null===(i=n.filterFrame)||void 0===i?void 0:i.height,e.applyFilter(this,n,t,r)},Object.defineProperty(n.prototype,"texture",{get:function(){return this.uniforms.uLightmap},set:function(e){this.uniforms.uLightmap=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"color",{get:function(){return this._color},set:function(e){var n=this.uniforms.ambientColor;"number"==typeof e?(o.hex2rgb(e,n),this._color=e):(n[0]=e[0],n[1]=e[1],n[2]=e[2],n[3]=e[3],this._color=o.rgb2hex(n))},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"alpha",{get:function(){return this.uniforms.ambientColor[3]},set:function(e){this.uniforms.ambientColor[3]=e},enumerable:!1,configurable:!0}),n}(n.Filter),G=function(e){function n(n,r,o,i){void 0===n&&(n=100),void 0===r&&(r=600);var l=e.call(this,c,"varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float blur;\nuniform float gradientBlur;\nuniform vec2 start;\nuniform vec2 end;\nuniform vec2 delta;\nuniform vec2 texSize;\n\nfloat random(vec3 scale, float seed)\n{\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n    vec2 normal = normalize(vec2(start.y - end.y, end.x - start.x));\n    float radius = smoothstep(0.0, 1.0, abs(dot(vTextureCoord * texSize - start, normal)) / gradientBlur) * blur;\n\n    for (float t = -30.0; t <= 30.0; t++)\n    {\n        float percent = (t + offset - 0.5) / 30.0;\n        float weight = 1.0 - abs(percent);\n        vec4 sample = texture2D(uSampler, vTextureCoord + delta / texSize * percent * radius);\n        sample.rgb *= sample.a;\n        color += sample * weight;\n        total += weight;\n    }\n\n    color /= total;\n    color.rgb /= color.a + 0.00001;\n\n    gl_FragColor = color;\n}\n")||this;return l.uniforms.blur=n,l.uniforms.gradientBlur=r,l.uniforms.start=o||new t.Point(0,window.innerHeight/2),l.uniforms.end=i||new t.Point(600,window.innerHeight/2),l.uniforms.delta=new t.Point(30,30),l.uniforms.texSize=new t.Point(window.innerWidth,window.innerHeight),l.updateDelta(),l}return u(n,e),n.prototype.updateDelta=function(){this.uniforms.delta.x=0,this.uniforms.delta.y=0},Object.defineProperty(n.prototype,"blur",{get:function(){return this.uniforms.blur},set:function(e){this.uniforms.blur=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"gradientBlur",{get:function(){return this.uniforms.gradientBlur},set:function(e){this.uniforms.gradientBlur=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"start",{get:function(){return this.uniforms.start},set:function(e){this.uniforms.start=e,this.updateDelta()},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"end",{get:function(){return this.uniforms.end},set:function(e){this.uniforms.end=e,this.updateDelta()},enumerable:!1,configurable:!0}),n}(n.Filter),K=function(e){function n(){return null!==e&&e.apply(this,arguments)||this}return u(n,e),n.prototype.updateDelta=function(){var e=this.uniforms.end.x-this.uniforms.start.x,n=this.uniforms.end.y-this.uniforms.start.y,t=Math.sqrt(e*e+n*n);this.uniforms.delta.x=e/t,this.uniforms.delta.y=n/t},n}(G),q=function(e){function n(){return null!==e&&e.apply(this,arguments)||this}return u(n,e),n.prototype.updateDelta=function(){var e=this.uniforms.end.x-this.uniforms.start.x,n=this.uniforms.end.y-this.uniforms.start.y,t=Math.sqrt(e*e+n*n);this.uniforms.delta.x=-n/t,this.uniforms.delta.y=e/t},n}(G),W=function(e){function n(n,t,r,o){void 0===n&&(n=100),void 0===t&&(t=600);var i=e.call(this)||this;return i.tiltShiftXFilter=new K(n,t,r,o),i.tiltShiftYFilter=new q(n,t,r,o),i}return u(n,e),n.prototype.apply=function(e,n,t,r){var o=e.getFilterTexture();this.tiltShiftXFilter.apply(e,n,o,1),this.tiltShiftYFilter.apply(e,o,t,r),e.returnFilterTexture(o)},Object.defineProperty(n.prototype,"blur",{get:function(){return this.tiltShiftXFilter.blur},set:function(e){this.tiltShiftXFilter.blur=this.tiltShiftYFilter.blur=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"gradientBlur",{get:function(){return this.tiltShiftXFilter.gradientBlur},set:function(e){this.tiltShiftXFilter.gradientBlur=this.tiltShiftYFilter.gradientBlur=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"start",{get:function(){return this.tiltShiftXFilter.start},set:function(e){this.tiltShiftXFilter.start=this.tiltShiftYFilter.start=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"end",{get:function(){return this.tiltShiftXFilter.end},set:function(e){this.tiltShiftXFilter.end=this.tiltShiftYFilter.end=e},enumerable:!1,configurable:!0}),n}(n.Filter),Y=function(e){function n(t){var r=e.call(this,c,"varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float radius;\nuniform float angle;\nuniform vec2 offset;\nuniform vec4 filterArea;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= filterArea.xy;\n    coord += filterArea.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= filterArea.zw;\n    coord /= filterArea.xy;\n\n    return coord;\n}\n\nvec2 twist(vec2 coord)\n{\n    coord -= offset;\n\n    float dist = length(coord);\n\n    if (dist < radius)\n    {\n        float ratioDist = (radius - dist) / radius;\n        float angleMod = ratioDist * ratioDist * angle;\n        float s = sin(angleMod);\n        float c = cos(angleMod);\n        coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);\n    }\n\n    coord += offset;\n\n    return coord;\n}\n\nvoid main(void)\n{\n\n    vec2 coord = mapCoord(vTextureCoord);\n\n    coord = twist(coord);\n\n    coord = unmapCoord(coord);\n\n    gl_FragColor = texture2D(uSampler, coord );\n\n}\n")||this;return Object.assign(r,n.defaults,t),r}return u(n,e),Object.defineProperty(n.prototype,"offset",{get:function(){return this.uniforms.offset},set:function(e){this.uniforms.offset=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"radius",{get:function(){return this.uniforms.radius},set:function(e){this.uniforms.radius=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"angle",{get:function(){return this.uniforms.angle},set:function(e){this.uniforms.angle=e},enumerable:!1,configurable:!0}),n.defaults={radius:200,angle:4,padding:20,offset:new t.Point},n}(n.Filter),Z=function(e){function n(t){var r,o=Object.assign(n.defaults,t),i=o.maxKernelSize,l=function(e,n){var t={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&n.indexOf(r)<0&&(t[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var o=0;for(r=Object.getOwnPropertySymbols(e);o<r.length;o++)n.indexOf(r[o])<0&&Object.prototype.propertyIsEnumerable.call(e,r[o])&&(t[r[o]]=e[r[o]])}return t}(o,["maxKernelSize"]);return r=e.call(this,c,"varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform vec2 uCenter;\nuniform float uStrength;\nuniform float uInnerRadius;\nuniform float uRadius;\n\nconst float MAX_KERNEL_SIZE = ${maxKernelSize};\n\n// author: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand(vec2 co, float seed) {\n    const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n    highp float dt = dot(co + seed, vec2(a, b)), sn = mod(dt, 3.14159);\n    return fract(sin(sn) * c + seed);\n}\n\nvoid main() {\n\n    float minGradient = uInnerRadius * 0.3;\n    float innerRadius = (uInnerRadius + minGradient * 0.5) / filterArea.x;\n\n    float gradient = uRadius * 0.3;\n    float radius = (uRadius - gradient * 0.5) / filterArea.x;\n\n    float countLimit = MAX_KERNEL_SIZE;\n\n    vec2 dir = vec2(uCenter.xy / filterArea.xy - vTextureCoord);\n    float dist = length(vec2(dir.x, dir.y * filterArea.y / filterArea.x));\n\n    float strength = uStrength;\n\n    float delta = 0.0;\n    float gap;\n    if (dist < innerRadius) {\n        delta = innerRadius - dist;\n        gap = minGradient;\n    } else if (radius >= 0.0 && dist > radius) { // radius < 0 means it's infinity\n        delta = dist - radius;\n        gap = gradient;\n    }\n\n    if (delta > 0.0) {\n        float normalCount = gap / filterArea.x;\n        delta = (normalCount - delta) / normalCount;\n        countLimit *= delta;\n        strength *= delta;\n        if (countLimit < 1.0)\n        {\n            gl_FragColor = texture2D(uSampler, vTextureCoord);\n            return;\n        }\n    }\n\n    // randomize the lookup values to hide the fixed number of samples\n    float offset = rand(vTextureCoord, 0.0);\n\n    float total = 0.0;\n    vec4 color = vec4(0.0);\n\n    dir *= strength;\n\n    for (float t = 0.0; t < MAX_KERNEL_SIZE; t++) {\n        float percent = (t + offset) / MAX_KERNEL_SIZE;\n        float weight = 4.0 * (percent - percent * percent);\n        vec2 p = vTextureCoord + dir * percent;\n        vec4 sample = texture2D(uSampler, p);\n\n        // switch to pre-multiplied alpha to correctly blur transparent images\n        // sample.rgb *= sample.a;\n\n        color += sample * weight;\n        total += weight;\n\n        if (t > countLimit){\n            break;\n        }\n    }\n\n    color /= total;\n    // switch back from pre-multiplied alpha\n    // color.rgb /= color.a + 0.00001;\n\n    gl_FragColor = color;\n}\n".replace("${maxKernelSize}",i.toFixed(1)))||this,Object.assign(r,l),r}return u(n,e),Object.defineProperty(n.prototype,"center",{get:function(){return this.uniforms.uCenter},set:function(e){this.uniforms.uCenter=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"strength",{get:function(){return this.uniforms.uStrength},set:function(e){this.uniforms.uStrength=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"innerRadius",{get:function(){return this.uniforms.uInnerRadius},set:function(e){this.uniforms.uInnerRadius=e},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"radius",{get:function(){return this.uniforms.uRadius},set:function(e){(e<0||e===1/0)&&(e=-1),this.uniforms.uRadius=e},enumerable:!1,configurable:!0}),n.defaults={strength:.1,center:[0,0],innerRadius:0,radius:-1,maxKernelSize:32},n}(n.Filter);return e.AdjustmentFilter=m,e.AdvancedBloomFilter=h,e.AsciiFilter=g,e.BevelFilter=v,e.BloomFilter=y,e.BulgePinchFilter=b,e.CRTFilter=z,e.ColorMapFilter=x,e.ColorOverlayFilter=_,e.ColorReplaceFilter=C,e.ConvolutionFilter=S,e.CrossHatchFilter=F,e.DotFilter=O,e.DropShadowFilter=P,e.EmbossFilter=A,e.GlitchFilter=T,e.GlowFilter=w,e.GodrayFilter=D,e.KawaseBlurFilter=d,e.MotionBlurFilter=j,e.MultiColorReplaceFilter=M,e.OldFilmFilter=R,e.OutlineFilter=E,e.PixelateFilter=I,e.RGBSplitFilter=N,e.RadialBlurFilter=k,e.ReflectionFilter=L,e.ShockwaveFilter=X,e.SimpleLightmapFilter=B,e.TiltShiftAxisFilter=G,e.TiltShiftFilter=W,e.TiltShiftXFilter=K,e.TiltShiftYFilter=q,e.TwistFilter=Y,e.ZoomBlurFilter=Z,Object.defineProperty(e,"__esModule",{value:!0}),e}({},PIXI,PIXI,PIXI,PIXI.utils,PIXI,PIXI.filters,PIXI.filters);Object.assign(PIXI.filters,__filters);
//# sourceMappingURL=pixi-filters.js.map


// Generated by CoffeeScript 2.6.1
// ==========================================================================
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ KDCore.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
// * LIBRARY WITH MZ AND MZ SUPPORT
//! {OUTER FILE}

//?rev 23.11.24
var KDCore;

window.Imported = window.Imported || {};

Imported.KDCore = true;

KDCore = KDCore || {};

// * Двузначные числа нельзя в версии, сравнение идёт по первой цифре поулчается (3.43 - нельзя, можно 3.4.3)
//%[МЕНЯТЬ ПРИ ИЗМЕНЕНИИ]
KDCore._fileVersion = '3.6.2';

KDCore.nuiVersion = '1.4.1';

// * Методы и библиотеки данной версии
KDCore._loader = 'loader_' + KDCore._fileVersion;

KDCore[KDCore._loader] = [];

// * Добавить библиотеку на загрузку
KDCore.registerLibraryToLoad = function(lib) {
  return KDCore[KDCore._loader].push(lib);
};

if ((KDCore.Version != null) && KDCore.Version >= KDCore._fileVersion) {
  // * ПРОПУСКАЕМ ЗАГРУЗКУ, так как уже загруженна более новая
  console.log('XDev KDCore ' + KDCore._fileVersion + ' skipped by new or exists version');
  KDCore._requireLoadLibrary = false;
} else {
  KDCore.Version = KDCore._fileVersion;
  KDCore.LIBS = KDCore.LIBS || {};
  KDCore.register = function(library) {
    return this.LIBS[library.name] = library;
  };
  window.KDCore = KDCore;
  // * ТРЕБУЕТСЯ ЗАГРУЗКА БИБЛИОТЕК
  KDCore._requireLoadLibrary = true;
}


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  Array.prototype.delete = function() {
    var L, a, ax, what;
    what = void 0;
    a = arguments;
    L = a.length;
    ax = void 0;
    while (L && this.length) {
      what = a[--L];
      while ((ax = this.indexOf(what)) !== -1) {
        this.splice(ax, 1);
      }
    }
    return this;
  };
  Array.prototype.max = function() {
    return Math.max.apply(null, this);
  };
  Array.prototype.min = function() {
    return Math.min.apply(null, this);
  };
  Array.prototype.sample = function() {
    if (this.length === 0) {
      return [];
    }
    return this[KDCore.SDK.rand(0, this.length - 1)];
  };
  Array.prototype.first = function() {
    return this[0];
  };
  Array.prototype.last = function() {
    return this[this.length - 1];
  };
  Array.prototype.shuffle = function() {
    var k, n, v;
    n = this.length;
    while (n > 1) {
      n--;
      k = KDCore.SDK.rand(0, n + 1);
      v = this[k];
      this[k] = this[n];
      this[n] = v;
    }
  };
  Array.prototype.count = function() {
    return this.length;
  };
  Array.prototype.isEmpty = function() {
    return this.length === 0;
  };
  // * Ищет элемент, у которого поле ID == id
  Array.prototype.getById = function(id) {
    return this.getByField('id', id);
  };
  // * Ищет элемент, у которого поле FIELD (имя поля) == value
  Array.prototype.getByField = function(field, value) {
    var e;
    try {
      return this.find(function(item) {
        return item[field] === value;
      });
    } catch (error) {
      e = error;
      console.warn(e);
      return null;
    }
  };
  Object.defineProperty(Array.prototype, "delete", {
    enumerable: false
  });
  Object.defineProperty(Array.prototype, "max", {
    enumerable: false
  });
  Object.defineProperty(Array.prototype, "min", {
    enumerable: false
  });
  Object.defineProperty(Array.prototype, "sample", {
    enumerable: false
  });
  Object.defineProperty(Array.prototype, "first", {
    enumerable: false
  });
  Object.defineProperty(Array.prototype, "last", {
    enumerable: false
  });
  Object.defineProperty(Array.prototype, "shuffle", {
    enumerable: false
  });
  Object.defineProperty(Array.prototype, "count", {
    enumerable: false
  });
  Object.defineProperty(Array.prototype, "isEmpty", {
    enumerable: false
  });
  Object.defineProperty(Array.prototype, "getById", {
    enumerable: false
  });
  return Object.defineProperty(Array.prototype, "getByField", {
    enumerable: false
  });
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  Number.prototype.do = function(method) {
    return KDCore.SDK.times(this, method);
  };
  Number.prototype.clamp = function(min, max) {
    return Math.min(Math.max(this, min), max);
  };
  return Number.prototype.any = function(number) {
    return (number != null) && typeof number === 'number' && number > 0;
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  String.prototype.toCss = function() {
    return KDCore.Color.FromHex(this).CSS;
  };
  String.prototype.toCSS = function() {
    return this.toCss();
  };
  String.prototype.isEmpty = function() {
    return this.length === 0 || !this.trim();
  };
  String.isNullOrEmpty = function(str) {
    if (str != null) {
      return str.toString().isEmpty();
    } else {
      return true;
    }
  };
  String.any = function(str) {
    return !String.isNullOrEmpty(str);
  };
  return String.prototype.replaceAll = function(search, replacement) {
    var target;
    target = this;
    return target.split(search).join(replacement);
  };
});


KDCore.registerLibraryToLoad(() => {
    /**
     * Checks if the RPG Maker version is MV.
     * @returns {boolean} True if the RPG Maker version is MV, otherwise false.
     */
    KDCore.isMV = () => Utils.RPGMAKER_NAME.includes("MV");
    /**
     * Checks if the RPG Maker version is MZ.
     * @returns {boolean} True if the RPG Maker version is MZ, otherwise false.
     */
    KDCore.isMZ = () => !KDCore.isMV();
    /**
     * Logs warnings to the console.
     * @param {...any[]} args - The arguments to log as warnings.
     */
    KDCore.warning = (...args) => {
        args.forEach(element => {
            console.warn(element);
        });
    };
    /**
     * Generates a random string of the specified length.
     * @param {number} length - The length of the generated string.
     * @returns {string} The generated string.
     */
    KDCore.makeId = (length) => {
        let result = '';
        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        const charactersLength = characters.length;
        for (let i = 0; i < length; i++) {
            result += characters.charAt(Math.floor(Math.random() * charactersLength));
        }
        return result;
    };
    //@[DEPREACTED]
    /**
     * Generates a random string of the specified length.
     * @deprecated Use makeId instead.
     * @param {number} length - The length of the generated string.
     * @returns {string} The generated string.
     */
    KDCore.makeid = (length) => KDCore.makeId(length);
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var SDK;
  //?[DEPRECATED]
  // * SDK
  //------------------------------------------------------------------------------
  SDK = function() {
    throw new Error('This is a static class');
  };
  SDK.rand = function(min, max) {
    return Math.round(Math.random() * (max - min)) + min;
  };
  SDK.setConstantToObject = function(object, constantName, constantValue) {
    object[constantName] = constantValue;
    if (typeof object[constantName] === 'object') {
      Object.freeze(object[constantName]);
    }
    Object.defineProperty(object, constantName, {
      writable: false
    });
  };
  SDK.convertBitmapToBase64Data = function(bitmap) {
    return bitmap._canvas.toDataURL('image/png');
  };
  SDK.times = function(times, method) {
    var i, results;
    i = 0;
    results = [];
    while (i < times) {
      method(i);
      results.push(i++);
    }
    return results;
  };
  SDK.toGlobalCoord = function(layer, coordSymbol = 'x') {
    var node, t;
    t = layer[coordSymbol];
    node = layer;
    while (node) {
      t -= node[coordSymbol];
      node = node.parent;
    }
    return (t * -1) + layer[coordSymbol];
  };
  SDK.canvasToLocalX = function(layer, x) {
    while (layer) {
      x -= layer.x;
      layer = layer.parent;
    }
    return x;
  };
  SDK.canvasToLocalY = function(layer, y) {
    while (layer) {
      y -= layer.y;
      layer = layer.parent;
    }
    return y;
  };
  SDK.isInt = function(n) {
    return Number(n) === n && n % 1 === 0;
  };
  SDK.isFloat = function(n) {
    return Number(n) === n && n % 1 !== 0;
  };
  SDK.checkSwitch = function(switchValue) {
    if (switchValue === 'A' || switchValue === 'B' || switchValue === 'C' || switchValue === 'D') {
      return true;
    }
    return false;
  };
  SDK.toNumber = function(string, none = 0) {
    var number;
    if (string == null) {
      return none;
    }
    number = Number(string);
    if (isNaN(number)) {
      return none;
    }
    return number;
  };
  SDK.isString = function(value) {
    return typeof value === "string";
  };
  SDK.isArray = function(value) {
    return Array.isArray(value);
  };
  //@[EXTEND]
  return KDCore.SDK = SDK;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var __alias_Bitmap_blt_kdCore, __alias_Bitmap_fillAll_kdCore;
  //@[ALIAS]
  __alias_Bitmap_fillAll_kdCore = Bitmap.prototype.fillAll;
  Bitmap.prototype.fillAll = function(color) {
    if (color instanceof KDCore.Color) {
      return this.fillRect(0, 0, this.width, this.height, color.CSS);
    } else {
      return __alias_Bitmap_fillAll_kdCore.call(this, color);
    }
  };
  //@[ALIAS]
  __alias_Bitmap_blt_kdCore = Bitmap.prototype.blt;
  Bitmap.prototype.blt = function(source, sx, sy, sw, sh, dx, dy, dw, dh) {
    if (this._needModBltDWH > 0) {
      dh = dw = this._needModBltDWH;
      __alias_Bitmap_blt_kdCore.call(this, source, sx, sy, sw, sh, dx, dy, dw, dh);
      this._needModBltDWH = null;
    } else {
      __alias_Bitmap_blt_kdCore.call(this, ...arguments);
    }
  };
  Bitmap.prototype.drawIcon = function(x, y, icon, size = 32, noSmoth = false) {
    var bitmap;
    bitmap = null;
    if (icon instanceof Bitmap) {
      bitmap = icon;
    } else {
      bitmap = KDCore.BitmapSrc.LoadFromIconIndex(icon).bitmap;
    }
    this._context.imageSmoothingEnabled = !noSmoth;
    this.drawOnMe(bitmap, x, y, size, size);
    this._context.imageSmoothingEnabled = true;
  };
  Bitmap.prototype.drawOnMe = function(bitmap, x = 0, y = 0, sw = 0, sh = 0) {
    if (sw <= 0) {
      sw = bitmap.width;
    }
    if (sh <= 0) {
      sh = bitmap.height;
    }
    this.blt(bitmap, 0, 0, bitmap.width, bitmap.height, x, y, sw, sh);
  };
  Bitmap.prototype.drawInMe = function(bitmap) {
    return Bitmap.prototype.drawOnMe(bitmap, 0, 0, this.width, this.height);
  };
  return Bitmap.prototype.drawTextFull = function(text, position = 'center') {
    return this.drawText(text, 0, 0, this.width, this.height, position);
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  //?[NEW]
  return DataManager.pkdRegisterNUIFile = function(folder, name) {
    var _name, src;
    _name = "$" + folder + "_" + name;
    src = folder + "/" + name + ".json";
    return DataManager._databaseFiles.push({
      name: _name,
      src: src
    });
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  KDCore.EasingFuncs = KDCore.EasingFuncs || {};
  return (function() {
    var _;
    _ = KDCore.EasingFuncs;
    _.linear = function(t, b, c, d) {
      return c * t / d + b;
    };
    _.easeInQuad = function(t, b, c, d) {
      return c * (t /= d) * t + b;
    };
    _.easeOutQuad = function(t, b, c, d) {
      return -c * (t /= d) * (t - 2) + b;
    };
    _.easeInOutQuad = function(t, b, c, d) {
      if ((t /= d / 2) < 1) {
        return c / 2 * t * t + b;
      } else {
        return -c / 2 * ((--t) * (t - 2) - 1) + b;
      }
    };
    _.easeInCubic = function(t, b, c, d) {
      return c * (t /= d) * t * t + b;
    };
    _.easeOutCubic = function(t, b, c, d) {
      return c * ((t = t / d - 1) * t * t + 1) + b;
    };
    return _.easeInOutCubic = function(t, b, c, d) {
      if ((t /= d / 2) < 1) {
        return c / 2 * t * t * t + b;
      } else {
        return c / 2 * ((t -= 2) * t * t + 2) + b;
      }
    };
  })();
});


// Generated by CoffeeScript 2.6.1
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_CharacterBase.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_CharacterBase.prototype;
  // * Нахожусь ли Я в точке по диагонале (рядом), относительно char
  _.kdInDiagonalPointRelativeTo = function(char) {
    var e, x, y;
    try {
      if (char == null) {
        return false;
      }
      ({x, y} = char);
      if (x === this.x - 1 && ((y === this.y - 1) || (y === this.y + 1))) {
        return true; // * left up or down
      }
      if (x === this.x + 1 && (y === this.y - 1 || y === this.y + 1)) {
        return true; // * right up or down
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
    return false;
  };
})();

// ■ END Game_CharacterBase.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  // * В MZ нету данной функции, а она часто используется в моих плагинах
  if (!KDCore.isMZ()) {
    return;
  }
  //?[NEW] (from MV)
  return ImageManager.loadEmptyBitmap = function() {
    if (this._emptyBitmap != null) {
      return this._emptyBitmap;
    } else {
      return new Bitmap();
    }
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var _input_onKeyDown, _input_onKeyUp, i, j, k, l;
  Input.KeyMapperPKD = {};
//Numbers
  for (i = j = 48; j <= 57; i = ++j) {
    Input.KeyMapperPKD[i] = String.fromCharCode(i);
  }
//Letters Upper
  for (i = k = 65; k <= 90; i = ++k) {
    Input.KeyMapperPKD[i] = String.fromCharCode(i).toLowerCase();
  }
//Letters Lower (for key code events)
  for (i = l = 97; l <= 122; i = ++l) {
    Input.KeyMapperPKD[i] = String.fromCharCode(i).toLowerCase();
  }
  
  //@[ALIAS]
  _input_onKeyDown = Input._onKeyDown;
  Input._onKeyDown = function(event) {
    _input_onKeyDown.call(this, event);
    if (Input.keyMapper[event.keyCode]) {
      return;
    }
    Input._setStateWithMapperPKD(event.keyCode);
  };
  //@[ALIAS]
  _input_onKeyUp = Input._onKeyUp;
  Input._onKeyUp = function(event) {
    _input_onKeyUp.call(this, event);
    if (Input.keyMapper[event.keyCode]) {
      return;
    }
    Input._setStateWithMapperPKD(event.keyCode, false);
  };
  //?NEW
  Input._setStateWithMapperPKD = function(keyCode, state = true) {
    var symbol;
    symbol = Input.KeyMapperPKD[keyCode];
    if (symbol != null) {
      return this._currentState[symbol] = state;
    }
  };
  //?NEW
  Input.isCancel = function() {
    return Input.isTriggered('cancel') || TouchInput.isCancelled();
  };
  //?NEW
  return TouchInput.toPoint = function() {
    return new KDCore.Point(TouchInput.x, TouchInput.y);
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  PluginManager.getPluginParametersByRoot = function(rootName) {
    var pluginParameters, property;
    for (property in this._parameters) {
      if (this._parameters.hasOwnProperty(property)) {
        pluginParameters = this._parameters[property];
        if (PluginManager.isPluginParametersContentKey(pluginParameters, rootName)) {
          return pluginParameters;
        }
      }
    }
    return PluginManager.parameters(rootName);
  };
  return PluginManager.isPluginParametersContentKey = function(pluginParameters, key) {
    return pluginParameters[key] != null;
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var ___Sprite_alias_Move_KDCORE_2;
  Sprite.prototype.moveToCenter = function(dx = 0, dy = 0) {
    return this.move(-this.bitmap.width / 2 + dx, -this.bitmap.height / 2 + dy);
  };
  Sprite.prototype.setStaticAnchor = function(floatX = 1, floatY = 1) {
    this.x -= Math.round(this.width * floatX);
    this.y -= Math.round(this.height * floatY);
  };
  Sprite.prototype.moveToParentCenter = function() {
    if (!this.parent) {
      return;
    }
    return this.move(this.parent.width / 2, this.parent.height / 2);
  };
  ___Sprite_alias_Move_KDCORE_2 = Sprite.prototype.move;
  Sprite.prototype.move = function(x, y) {
    if (x instanceof Array) {
      return ___Sprite_alias_Move_KDCORE_2.call(this, x[0], x[1]);
    } else if (x instanceof KDCore.Point || ((x != null ? x.x : void 0) != null)) {
      return ___Sprite_alias_Move_KDCORE_2.call(this, x.x, x.y);
    } else if ((x != null) && (x._x != null)) {
      return ___Sprite_alias_Move_KDCORE_2.call(this, x._x, x._y);
    } else {
      return ___Sprite_alias_Move_KDCORE_2.call(this, x, y);
    }
  };
  Sprite.prototype.isContainsPoint = function(point) {
    var rect, rx, ry;
    if (this.width === 0 || this.height === 0) {
      return false;
    }
    rx = KDCore.SDK.toGlobalCoord(this, 'x');
    ry = KDCore.SDK.toGlobalCoord(this, 'y');
    rect = this._getProperFullRect(rx, ry);
    return rect.contains(point.x, point.y);
  };
  // * Возвращает Rect с учётом Scale и Anchor спрайта
  Sprite.prototype._getProperFullRect = function(rx, ry) {
    var height, width, x, y;
    width = this.width * Math.abs(this.scale.x);
    height = this.height * Math.abs(this.scale.y);
    x = rx - this.anchor.x * width;
    y = ry - this.anchor.y * height;
    if (this.anchor.x === 0 && this.scale.x < 0) {
      x += this.width * this.scale.x;
    }
    if (this.anchor.y === 0 && this.scale.y < 0) {
      y += this.height * this.scale.y;
    }
    return new PIXI.Rectangle(x, y, width, height);
  };
  Sprite.prototype.fillAll = function(color) {
    if (color != null) {
      return this.bitmap.fillAll(color);
    } else {
      return this.fillAll(KDCore.Color.WHITE);
    }
  };
  return Sprite.prototype.removeFromParent = function() {
    if (this.parent != null) {
      return this.parent.removeChild(this);
    }
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  return TouchInput.toMapPoint = function() {
    return this.toPoint().convertToMap();
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  KDCore.Utils = KDCore.Utils || {};
  return (function() {
    var _;
    _ = KDCore.Utils;
    _.getJDataById = function(id, source) {
      var d, j, len;
      for (j = 0, len = source.length; j < len; j++) {
        d = source[j];
        if (d.id === id) {
          return d;
        }
      }
      return null;
    };
    _.hasMeta = function(symbol, obj) {
      return (obj != null) && (obj.meta != null) && (obj.meta[symbol] != null);
    };
    _.getValueFromMeta = function(symbol, obj) {
      if (!_.hasMeta(symbol, obj)) {
        return null;
      }
      return obj.meta[symbol];
    };
    _.getNumberFromMeta = function(symbol, obj) {
      var value;
      if (!_.hasMeta(symbol, obj)) {
        return null;
      }
      if (obj.meta[symbol] === true) {
        return 0;
      } else {
        value = KDCore.SDK.toNumber(obj.meta[symbol], 0);
      }
      return value;
    };
    _.isSceneMap = function() {
      try {
        return !SceneManager.isSceneChanging() && SceneManager._scene instanceof Scene_Map;
      } catch (error) {
        return false;
      }
    };
    _.isMapScene = function() {
      return this.isSceneMap();
    };
    _.isSceneBattle = function() {
      try {
        return !SceneManager.isSceneChanging() && SceneManager._scene instanceof Scene_Battle;
      } catch (error) {
        return false;
      }
    };
    _.isBattleScene = function() {
      return this.isSceneBattle();
    };
    _.getEventCommentValue = function(commentCode, list) {
      var comment, e, i, item;
      try {
        if (list && list.length > 1) {
          i = 0;
          while (i < list.length) {
            item = list[i++];
            if (!item) {
              continue;
            }
            if (item.code === 108) {
              comment = item.parameters[0];
              if (comment.contains(commentCode)) {
                return comment;
              }
            }
          }
        }
      } catch (error) {
        e = error;
        console.warn(e);
      }
      return null;
    };
    _.getEventCommentValueArray = function(commentCode, list) {
      var comment, comments, e, i, item;
      try {
        comments = [];
        if (list && list.length > 1) {
          i = 0;
          while (i < list.length) {
            item = list[i++];
            if (!item) {
              continue;
            }
            if (item.code === 108) {
              comment = item.parameters[0];
              if (comment.contains(commentCode)) {
                comments.push(comment);
              }
            }
          }
        }
      } catch (error) {
        e = error;
        console.warn(e);
      }
      return comments;
    };
    _.getPositionPointFromJSON = function(jsonSettings) {
      return _.convertPositionPointFromJSON(jsonSettings.position);
    };
    _.convertPositionPointFromJSON = function(position) {
      var e, x, y;
      try {
        x = position[0];
        y = position[1];
        if (!KDCore.SDK.isInt(x)) {
          x = eval(x);
        }
        if (!KDCore.SDK.isInt(y)) {
          y = eval(y);
        }
        return new KDCore.Point(x, y);
      } catch (error) {
        e = error;
        console.warn('Utils.getPositionPointFromJSON', e);
        return KDCore.Point.Empty;
      }
    };
    _.jsonPos = function(jsonPosition) {
      return _.convertPositionPointFromJSON(jsonPosition);
    };
    _.jsonPosXY = function(jsonPosition) {
      var e, x, y;
      try {
        ({x, y} = jsonPosition);
        return new KDCore.Point(eval(x), eval(y));
      } catch (error) {
        e = error;
        console.warn('Utils.jsonPosXY', e);
        return KDCore.Point.Empty;
      }
    };
    _.getVar = function(id) {
      return $gameVariables.value(id);
    };
    _.setVar = function(id, value) {
      return $gameVariables.setValue(id, value);
    };
    _.addToVar = function(id, value) {
      var prevVal;
      prevVal = _.getVar(id);
      return _.setVar(id, prevVal + value);
    };
    _.playSE = function(seFileName, pitch = 100, volume = 100) {
      var sound;
      if (seFileName == null) {
        return;
      }
      if (seFileName === "") {
        return;
      }
      sound = {
        name: seFileName,
        pan: 0,
        pitch: pitch,
        volume: volume
      };
      AudioManager.playStaticSe(sound);
    };
    _.getItemTypeId = function(item) {
      if (DataManager.isWeapon(item)) {
        return 1;
      } else if (DataManager.isArmor(item)) {
        return 2;
      }
      return 0;
    };
    _.getItemByType = function(itemId, typeId) {
      var data, e;
      try {
        if ((typeId != null) && !isFinite(typeId) && KDCore.SDK.isString(typeId) && String.any(typeId)) {
          if (typeId[0] === "w") {
            typeId = 1;
          } else if (typeId[0] === "a") {
            typeId = 2;
          } else {
            typeId = 0;
          }
        }
        data = [$dataItems, $dataWeapons, $dataArmors];
        return data[typeId][itemId];
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return null;
      }
    };
    _.loadFont = function(name) {
      if (typeof FontManager === "undefined" || FontManager === null) {
        return;
      }
      if (String.isNullOrEmpty(name)) {
        return;
      }
      if (FontManager._states[name] != null) {
        return;
      }
      FontManager.load(name, name + ".ttf");
    };
    _.convertTimeShort = function(seconds) {
      var e;
      try {
        if (seconds > 59) {
          return Math.floor(seconds / 60) + 'm';
        } else {
          return seconds;
        }
      } catch (error) {
        e = error;
        console.warn(e);
        return seconds;
      }
    };
    _.isPointInScreen = function(point, margin = 10) {
      var maxH, maxW, screenMargin, x, y;
      ({x, y} = point);
      maxW = Graphics.width;
      maxH = Graphics.height;
      // * Граница от краёв экрана
      screenMargin = margin;
      if (x < screenMargin) {
        return false;
      }
      if (y < screenMargin) {
        return false;
      }
      if (x > (maxW - screenMargin)) {
        return false;
      }
      if (y > (maxH - screenMargin)) {
        return false;
      }
      return true;
    };
    // * Ассинхронная загрузка изображения, возвращает bitmap, когда загружен
    // * Пример использования loadImageAsync(a, b).then(метод)
    // в метод будет передан bitmap первым аргументом
    _.loadImageAsync = async function(folder, filename) {
      var promise;
      promise = new Promise(function(resolve, reject) {
        var b;
        b = ImageManager.loadBitmap("img/" + folder + "/", filename);
        return b.addLoadListener(function() {
          return resolve(b);
        });
      });
      return (await promise);
    };
    // * Преобразовать расширенное значение
    // * Значение может быть X -> X
    // * "X" -> X (цифра)
    // * "X,Y,Z,..." -> [X, Y, Z]
    // * "[X, Y, Z,...]" -> [X, Y, Z]
    // * "X|V" -> из переменной X
    // * [Y] -> случайное число из массива (рекурсивно)
    //@[2.8.1] since
    _.getEValue = function(value) {
      var e, items, randomValue, variableId;
      try {
        if (value == null) {
          return null;
        }
        if (KDCore.SDK.isString(value)) {
          if (isFinite(value)) { // * Число представленно строкой
            return Number(value);
          }
          // * Массив представлен строкой (может быть без квадратных скобок)
          if (value.contains(',') || (value.contains("[") && value.contains("]"))) {
            value = value.replace("[", "");
            value = value.replace("]", "");
            // * Преобразуем в число или строку (например если extended |V)
            items = value.split(",").map(function(item) {
              var itemT;
              itemT = item.trim();
              if (isFinite(itemT)) {
                return Number(itemT);
              } else {
                return itemT;
              }
            });
            // * Вызываем снова эту функцию, но уже с массивом
            return KDCore.Utils.getEValue(items);
          }
          if (value.contains("|V")) {
            variableId = parseInt(value);
            return $gameVariables.value(variableId);
          }
          return value; // * Просто значение в итоге
        } else if (KDCore.SDK.isArray(value)) {
          randomValue = value.sample();
          return KDCore.Utils.getEValue(randomValue);
        } else {
          return value;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return value;
      }
    };
    //@[2.8.2] since
    _.isChanceIsGood = function(chance) {
      var e;
      try {
        if (chance > 1) {
          chance /= 100;
        }
        return chance > Math.random();
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return false;
      }
    };
    //@[2.8.2] since
    //KEY:w:3:1:50 , KEY:i:10:2:1|V
    //OUTPUT: [GameItem, COUNT]
    _.parseItemFromConditionStr = function(conditionLine) {
      var amount, e, itemChance, itemId, parts, typeId;
      try {
        if (!conditionLine.contains(":")) {
          return null;
        }
        parts = conditionLine.split(":");
        typeId = parts[1];
        itemId = KDCore.Utils.getEValue(parts[2]);
        amount = KDCore.Utils.getEValue(parts[3]);
        if (amount <= 0) {
          return null;
        }
        try {
          itemChance = String.any(parts[4]) ? parts[4] : 100;
          itemChance = KDCore.Utils.getEValue(itemChance) / 100;
        } catch (error) {
          e = error;
          KDCore.warning(e);
          itemChance = 0;
        }
        if (itemChance <= 0) {
          return null;
        }
        if (KDCore.Utils.isChanceIsGood(itemChance)) {
          return [KDCore.Utils.getItemByType(itemId, typeId), amount];
        } else {
          return null;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return null;
      }
    };
    //@[3.2.1] since
    _.isValidCE = function(commonEventId) {
      var e;
      try {
        return commonEventId > 0 && ($dataCommonEvents[commonEventId] != null);
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return false;
      }
    };
    //@[3.2.1] since
    _.startCE = function(commonEventId) {
      var e;
      try {
        if (this.isValidCE(commonEventId)) {
          return $gameTemp.reserveCommonEvent(commonEventId);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    //@[3.2.1] since
    _.checkSwitch = function(value) {
      if (value == null) {
        return false;
      }
      if (isFinite(value)) {
        return false;
      }
      return KDCore.SDK.checkSwitch(value);
    };
    //@[3.2.1] since
    // * Вызвать с задержкой в time миллисекунд
    // * Не забываем про bind
    _.callDelayed = function(method, time = 1) {
      var e;
      try {
        if (method == null) {
          return;
        }
        setTimeout((function() {
          var e;
          try {
            return method();
          } catch (error) {
            e = error;
            return KDCore.warning(e);
          }
        }), time);
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    };
    //@[3.2.1] since
    //<meta:1,2,3,4> -> [1,2,3,4]
    _.getArrayOfNumbersFromMeta = function(symbol, obj) {
      var e, values;
      try {
        values = this.getArrayOfValuesFromMeta(symbol, obj);
        return values.map(function(v) {
          return Number(v);
        });
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return [];
      }
    };
    //@[3.2.1] since
    //<meta:a,b,c> -> ["a", "b", "c"]
    //<meta:a> -> ["a"]
    _.getArrayOfValuesFromMeta = function(symbol, obj) {
      var e, items, values;
      try {
        values = this.getValueFromMeta(symbol, obj);
        if (String.any(values)) {
          if (values.contains(',')) {
            items = values.split(',');
            return items || [];
          } else {
            return [values];
          }
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return [];
      }
    };
    //@[3.2.1] since
    // * Когда содержит одинаковый набор ключей
    //<meta:value1>
    //<meta:value2>
    //...
    // -> [value1,value2,...]
    _.getArrayOfValuesOfSameMeta = function(symbol, obj) {
      var e, j, len, line, lines, result;
      try {
        if (!this.hasMeta(symbol, obj)) {
          return [];
        }
        lines = obj.note.split("\n").filter(function(l) {
          return l.contains(symbol);
        });
        result = [];
        for (j = 0, len = lines.length; j < len; j++) {
          line = lines[j];
          try {
            line = line.replace("<" + symbol + ":", "");
            line = line.replace(">", "");
            result.push(line);
          } catch (error) {
            e = error;
            KDCore.warning(e);
          }
        }
        return result;
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return [];
    };
    //@[3.2.7] since
    _.getIndexIn2DArrayByIJ = function(row, col, cols) {
      return row * cols + col;
    };
    //@[3.2.7] since
    // * row - строка
    // * col - столбец
    _.getIJByIndexIn2DArray = function(index, cols) {
      var col, e, row;
      try {
        row = Math.floor(index / cols);
        col = index % cols;
        return [row, col];
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return [0, 0];
      }
    };
    //@[3.2.7] since
    _.isSwitchIsTRUE = function(switchId) {
      var e;
      if (switchId == null) {
        return true;
      }
      if (switchId <= 0) {
        return true;
      }
      try {
        return $gameSwitches.value(switchId) === true;
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return false;
    };
    //@[3.5] since
    _.convertBindingValue = function(sourceObj, bindingValue, element = null) {
      var e;
      try {
        return KDCore.UI.Builder._convertBindingValue(...arguments);
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return null;
    };
    //@[3.5] since
    _.getRealSpriteSize = function(forField = 'x', sprite = null) {
      var e, h, w;
      try {
        if (sprite == null) {
          return 0;
        }
        if (forField === 'x' || forField === 'width') {
          if (sprite.realWidth != null) {
            w = sprite.realWidth();
          } else {
            w = sprite.width;
          }
          return w;
        } else if (forField === 'y' || forField === 'height') {
          if (sprite.realHeight != null) {
            h = sprite.realHeight();
          } else {
            h = sprite.height;
          }
          return h;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return 0;
    };
    //@[3.5] since
    _.string2hex = function(string) {
      var e;
      try {
        if (typeof string === 'string' && string[0] === '#') {
          string = string.substr(1);
        }
        return parseInt(string, 16);
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return 0xffffff;
    };
    //@[3.5] since
    _.convertDP = function(value = 0, isHalf = false) {
      var d, e, mod, modX, modY;
      try {
        if (Graphics.width === 816 && Graphics.height === 624) {
          return value;
        }
        modX = Graphics.width / 816;
        modY = Graphics.height / 624;
        // Aprox
        mod = (modX + modY) / 2;
        if (mod === 0) {
          return 0;
        }
        if (isHalf === true) {
          if (mod < 1) {
            d = 1 - mod;
            mod += d / 2;
          } else if (mod > 1) {
            d = mod - 1;
            mod = 1 + (d / 2);
          }
        }
        return Math.round(value * mod);
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return 0;
    };
    //@[3.5.6] since
    _.getValueWithDP = function(value) {
      var dpValue, e, negative, r, result, resultValue;
      try {
        if (typeof value === "string") {
          value = value.trim();
          // * Replace all HDP and DP
          if (value.contains("hdp") || value.contains("dp")) {
            if (value[0] === '-') {
              value = value.replace("-", "");
              negative = true;
            } else {
              negative = false;
            }
            if (value.contains("hdp")) {
              r = new RegExp("(\\d+)hdp", "g");
              result = r.exec(value);
              dpValue = Number(result[1]);
              resultValue = KDCore.Utils.convertDP(dpValue, true);
              value = value.replace(/(\d+)hdp/, resultValue);
            } else if (value.contains("dp")) {
              r = new RegExp("(\\d+)dp", "g");
              result = r.exec(value);
              dpValue = Number(result[1]);
              resultValue = KDCore.Utils.convertDP(dpValue, false);
              value = value.replace(/(\d+)dp/, resultValue);
            }
          }
          value = parseInt(value);
          if (negative) {
            value = -value;
          }
        }
        return value;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return 0;
      }
    };
    //@[2.9.7] since
    // * Shrink number 100000 to "100k" and ect, returns STRING
    _.formatNumberToK = function(num) {
      var e;
      try {
        if (num >= 1000000000) {
          return (num / 1000000000).toFixed(1).replace(/\.0$/, '') + 'G';
        }
        if (num >= 1000000) {
          return (num / 1000000).toFixed(1).replace(/\.0$/, '') + 'M';
        }
        if (num >= 1000) {
          return (num / 1000).toFixed(1).replace(/\.0$/, '') + 'K';
        }
        return num;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return num;
      }
    };
  })();
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  return Window_Base.prototype.drawFaceWithCustomSize = function(faceName, faceIndex, x, y, finalSize) {
    this.contents._needModBltDWH = finalSize;
    this.drawFace(faceName, faceIndex, x, y);
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Window_Selectable.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var ALIAS__select, _;
    //@[DEFINES]
    _ = Window_Selectable.prototype;
    //@[ALIAS]
    ALIAS__select = _.select;
    _.select = function(index) {
      var e;
      ALIAS__select.call(this, ...arguments);
      try {
        return this._pOnSelectionChanged(index);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._pOnSelectionChanged = function(newIndex) {
      var e;
      try {
        if (this._pkdLastSelectedIndex == null) {
          this._pkdLastSelectedIndex = newIndex;
          return this.pOnSelectionChanged();
        } else {
          if (this._pkdLastSelectedIndex !== newIndex) {
            this._pkdLastSelectedIndex = newIndex;
            return this.pOnSelectionChanged();
          }
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.safeSelect = function(index = 0) {
      var e;
      try {
        if (this.maxItems() > index) {
          return this.select(index);
        } else {
          return this.select(-1);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    
    // * Called only when new (different) index is selected
    _.pOnSelectionChanged = function() {};
  })();
});

// ■ END Window_Selectable.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  return (function() {    // * Input Extension: KDGamepad
    //------------------------------------------------------------------------------
    // * Поддержка расширенного управления через геймпад (свой модуль)
    var ALIAS___updateGamepadState, _;
    //@[DEFINES]
    _ = Input;
    // * Активировать работу модуля KDGamepad
    _.activateExtendedKDGamepad = function() {
      return _._kdIsGamepadExtended = true;
    };
    //@[ALIAS]
    ALIAS___updateGamepadState = _._updateGamepadState;
    _._updateGamepadState = function(gamepad) {
      if (Input._kdIsGamepadExtended === true) {
        KDGamepad.update();
      }
      if ((typeof $gameTemp !== "undefined" && $gameTemp !== null ? $gameTemp.__kdgpStopDefaultGamepad : void 0) === true) {
        return;
      }
      // * Режим перемещения без DPad
      // * В оригинале игрок также ходит по DPad клавишам, что может быть не удобно
      // * например при работе с инвентарём
      if (KDGamepad.isNoDPadMoving()) {
        if (KDGamepad.isDPadAny()) {
          Input.clear();
          return;
        }
      }
      ALIAS___updateGamepadState.call(this, gamepad);
    };
    window.KDGamepad = function() {
      return new Error("This is static class");
    };
    window.addEventListener("gamepadconnected", function(event) {
      var e;
      try {
        return KDGamepad.refresh();
      } catch (error) {
        // * Можно напрямую
        //unless KDGamepad.isExists()
        //    if event.gamepad? and event.gamepad.mapping == 'standard'
        //        KDGamepad.init(event.gamepad)
        e = error;
        KDCore.warning(e);
        return KDGamepad.stop();
      }
    });
    window.addEventListener("gamepaddisconnected", function(event) {
      var e;
      if (!KDGamepad.isExists()) {
        return;
      }
      try {
        if ((event.gamepad != null) && event.gamepad === KDGamepad.gamepad) {
          return KDGamepad.stop();
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return KDGamepad.stop();
      }
    });
    KDGamepad.stopDefaultGamepad = function() {
      $gameTemp.__kdgpStopDefaultGamepad = true;
    };
    KDGamepad.resumeDefaultGamepad = function() {
      $gameTemp.__kdgpStopDefaultGamepad = null;
    };
    // * Ссылка на геймпад
    KDGamepad.gamepad = null;
    // * Подключён ли Gamepad ?
    KDGamepad.isExists = function() {
      return KDGamepad.gamepad != null;
    };
    // * Инициализация состояния кнопок
    // * Этот метод вызывается автоматически из Refresh или при подключении Gamepad
    KDGamepad.init = function(gamepad) {
      KDGamepad.gamepad = gamepad;
      this._isActive = true;
      this.buttonNames = [
        'A', // 0
        'B', // 1
        'X', // 2
        'Y', // 3
        'LB', // 4
        'RB', // 5
        'LTrigger', // 6
        'RTrigger', // 7
        'Back', // 8
        'Start', // 9
        'LStick', // 10
        'RStick', // 11
        'dUp', // 12
        'dDown', // 13
        'dLeft', // 14
        'dRight' // 15
      ];
      this.reset();
    };
    // * Аналог Input.clear
    KDGamepad.clear = function() {
      return KDGamepad.reset();
    };
    // * Сбросить состояние кнопок
    KDGamepad.reset = function() {
      this.leftStick = {
        x: 0,
        y: 0
      };
      this.rightStick = {
        x: 0,
        y: 0
      };
      this.buttons = {};
      this.buttonsPressed = {};
      this.prevButtons = {};
    };
    
    // * Остановить учёт геймпада
    KDGamepad.stop = function() {
      KDGamepad.reset();
      KDGamepad.gamepad = null;
    };
    // * Функция проверки что нажата кнопка на геймпаде
    KDGamepad._buttonPressed = function(gamepad, index) {
      var b, e;
      try {
        if (!gamepad || !gamepad.buttons || index >= gamepad.buttons.length) {
          return false;
        }
        b = gamepad.buttons[index];
        if (b == null) {
          return false;
        }
        if (typeof b === 'object') {
          // * Можно упростить
          return b.pressed;
        }
        return b === 1.0;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return false;
      }
    };
    // * Каждый кадр (обновление состояний)
    KDGamepad.update = function() {
      var e, gp, i, isDown, j, len, name, ref;
      if (!KDGamepad.isActive()) {
        return;
      }
      KDGamepad.refresh();
      if (!KDGamepad.isExists()) {
        return;
      }
      try {
        gp = KDGamepad.gamepad;
        ref = this.buttonNames;
        // * Проверка состояний кнопок
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          name = ref[i];
          this.buttons[name] = false;
          isDown = KDGamepad._buttonPressed(gp, i);
          if (isDown === true) {
            this.prevButtons[name] = true;
          } else {
            // * Срабатываение только при нажал - отпустил
            if (this.prevButtons[name] === true) {
              this.buttons[name] = true;
              this.prevButtons[name] = false;
            }
          }
        }
        // * Проверка стиков
        this.leftStick.x = gp.axes[0];
        this.leftStick.y = gp.axes[1];
        this.rightStick.x = gp.axes[2];
        this.rightStick.y = gp.axes[3];
      } catch (error) {
        e = error;
        KDCore.warning(e);
        KDGamepad.stop();
      }
    };
    // * Обновить и проверить состояние Gamepad
    // * Надо каждый раз это вызывать
    KDGamepad.refresh = function() {
      var e, gamepads, gp, i, isGamepadRefreshed, j, ref;
      try {
        isGamepadRefreshed = false;
        if (navigator.getGamepads) {
          gamepads = navigator.getGamepads();
        } else if (navigator.webkitGetGamepads) {
          gamepads = navigator.webkitGetGamepads();
        }
        if (gamepads != null) {
          for (i = j = 0, ref = gamepads.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
            gp = gamepads[i];
            if ((gp != null) && gp.mapping === 'standard') {
              isGamepadRefreshed = true;
              if (KDGamepad.buttonNames != null) {
                KDGamepad.gamepad = gp;
              } else {
                KDGamepad.init(gp);
              }
              break;
            }
          }
        }
        if (!isGamepadRefreshed) {
          // * Если не был найден не один gamepad - отключаем систему
          KDGamepad.stop();
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        KDGamepad.stop();
      }
    };
    // * Любое нажатие кнопки
    KDGamepad.isKeyAny = function(name) {
      return KDGamepad.isKey(name) || KDGamepad.isKeyPressed(name);
    };
    // * Нажата ли кнопка (trigger нажал - отпустил)
    KDGamepad.isKey = function(name) {
      if (!KDGamepad.isExists()) {
        return false;
      }
      if (this.buttons == null) {
        return false;
      }
      return this.buttons[name] === true;
    };
    // * Нажата ли кнопка (continues зажата)
    KDGamepad.isKeyPressed = function(name) {
      if (!KDGamepad.isExists()) {
        return false;
      }
      if (this.buttons == null) {
        return false;
      }
      return this.prevButtons[name] === true;
    };
    KDGamepad.isDPadAny = function() {
      return KDGamepad.isKeyAny("dLeft") || KDGamepad.isKeyAny("dRight") || KDGamepad.isKeyAny("dUp") || KDGamepad.isKeyAny("dDown");
    };
    KDGamepad.isActive = function() {
      return this._isActive === true;
    };
    // * Временно отключить обработку KDGamepad
    KDGamepad.setActive = function(_isActive) {
      this._isActive = _isActive;
      if (KDGamepad.isActive()) {
        KDGamepad.refresh();
      } else {
        KDGamepad.stop();
      }
    };
    // * Отключить перемещение игрока на DPad
    KDGamepad.setNoDPadMovingMode = function(_noDpadMoving) {
      this._noDpadMoving = _noDpadMoving;
    };
    return KDGamepad.isNoDPadMoving = function() {
      return this._noDpadMoving === true;
    };
  })();
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var BitmapSrc;
  BitmapSrc = (function() {
    //?[DEPRECATED]
    class BitmapSrc {
      constructor() {
        this.bitmap = null;
      }

      static LoadFromIconIndex(iconIndex) {
        var bs, icon_bitmap, iconset, ph, pw, sx, sy;
        bs = new BitmapSrc();
        if (BitmapSrc.CACHE[iconIndex] == null) {
          iconset = ImageManager.loadSystem('IconSet');
          if (KDCore.isMV()) {
            pw = Window_Base._iconWidth;
            ph = Window_Base._iconHeight;
          } else {
            pw = ImageManager.iconWidth;
            ph = ImageManager.iconHeight;
          }
          sx = iconIndex % 16 * pw;
          sy = Math.floor(iconIndex / 16) * ph;
          icon_bitmap = new Bitmap(pw, ph);
          icon_bitmap.addLoadListener(function() {
            icon_bitmap.blt(iconset, sx, sy, pw, ph, 0, 0);
          });
          BitmapSrc.CACHE[iconIndex] = icon_bitmap;
        }
        bs.bitmap = BitmapSrc.CACHE[iconIndex];
        return bs;
      }

      static LoadFromImageFolder(filename) {
        var bs;
        bs = new BitmapSrc();
        bs.bitmap = ImageManager.loadPicture(filename);
        return bs;
      }

      static LoadFromBase64(data, name) {
        var bs;
        bs = new BitmapSrc();
        if (name != null) {
          if (BitmapSrc.CACHE[name] != null) {
            bs.bitmap = BitmapSrc.CACHE[name];
          } else {
            BitmapSrc.CACHE[name] = Bitmap.load(data);
            bs.bitmap = BitmapSrc.CACHE[name];
          }
        } else {
          bs.bitmap = Bitmap.load(data);
        }
        return bs;
      }

      static LoadFromMemory(symbol) {
        var bs;
        bs = new BitmapSrc();
        if (BitmapSrc.CACHE[symbol] != null) {
          bs.bitmap = BitmapSrc.CACHE[symbol];
        } else {
          bs.bitmap = ImageManager.loadEmptyBitmap();
        }
        return bs;
      }

    };

    BitmapSrc.CACHE = {};

    return BitmapSrc;

  }).call(this);
  //@[EXTEND]
  return KDCore.BitmapSrc = BitmapSrc;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Changer;
  // * Класс который может плавно изменять какой-либо параметр
  // * Работает в стиле chain методов

    // * ------------------ ПРИМЕР ----------------------------------

    // * Меняем прозрачность 4 раза, туда-сюда, затем выводим done в консоль

    //@changer = new KDCore.Changer(someSprite)
  //@changer.change('opacity').from(255)
  //            .to(0).step(5).speed(1).delay(30).repeat(4).reverse()
  //            .start().done(() -> console.log('done'))
  //@changer.update()

    // * -------------------------------------------------------------
  Changer = class Changer {
    constructor(obj) {
      this.obj = obj;
      // * Количество кадров, в которые будет обновление
      this._field = null; // * название поля
      this._speed = 1; // * frames
      this._step = 1; // * шаг изменения значения
      this._from = 0; // * Начальное значение
      this._to = 0; // * Конечное значение
      this._thread = null;
      this._orienation = true; // * Направление + или - step (true = +)
      this._delay = 0; // * Задержка старта
      this._changer = null; // * Ссылка на следующий changer
      this._isRepeat = false; // * Надо ли поторить себя снова
      this._onDoneMethod = null; // * Метод будет выполнен в конце (при завершении)
      this._isPrepared = false; // * Элемента был подготовлен (установлено значение from)
    }

    start() {
      if (this._field == null) {
        return;
      }
      if (this._from === this._to) {
        return;
      }
      if (this._delay > 0) {
        this._delayThread = new KDCore.TimedUpdate(this._delay, this._startThread.bind(this));
        this._delayThread.once();
      } else {
        this._startThread();
      }
      return this;
    }

    isStarted() {
      return (this._thread != null) || (this._delayThread != null);
    }

    from(_from) {
      this._from = _from;
      return this;
    }

    to(_to) {
      this._to = _to;
      return this;
    }

    step(_step) {
      this._step = _step;
      return this;
    }

    speed(_speed) {
      this._speed = _speed;
      return this;
    }

    change(_field) {
      this._field = _field;
      return this;
    }

    // * Снова повторить (не совместим с then)
    // * Если ничего не указать, или <= 0 -> то бескончно
    repeat(_repeatCount = 0) {
      this._repeatCount = _repeatCount;
      if (this._repeatCount <= 0) {
        this._repeatCount = null;
      }
      this._isRepeat = true;
      this._changer = null;
      return this;
    }

    // * Снова повторить, но поменять местами to и from (работает только с repeat >= 2)
    reverse() {
      this._isReverse = true;
      return this;
    }

    isDone() {
      if (!this._isPrepared) {
        // * Чтобы не было выхода пока ждёт Delay
        return false;
      }
      // * Если от 255 до 0 (например)
      if (this._orienation === false) {
        // * То может быть меньше нуля (т.к. @step динамический)
        return this.value() <= this._to;
      } else {
        return this.value() >= this._to;
      }
    }

    value() {
      return this.obj[this._field];
    }

    stop() {
      this._thread = null;
      this._delayThread = null;
      if (this._changer == null) {
        // * Если есть связанный Changer, то не выполняем метод завршения
        return this._callDoneMethod();
      }
    }

    // * При ожидании, значения устанавливаются не сразу
    delay(_delay) {
      this._delay = _delay;
      return this;
    }

    // * Выполнить другой Changer после этого
    // * Не совместим с Repeat
    // * НЕЛЬЗЯ зацикливать, не будет работать
    // * Соединённый не надо обновлять вне, он обновляется в этом
    then(_changer) {
      this._changer = _changer;
      this._isRepeat = false;
      return this;
    }

    // * Этот метод будт выполнене в конце
    done(_onDoneMethod) {
      this._onDoneMethod = _onDoneMethod;
      return this;
    }

    // * Шаг можно выполнить и в ручную
    makeStep() {
      if (!this.isStarted()) {
        this._prepare();
      }
      this._makeStep();
      return this;
    }

    update() {
      var ref;
      if (this.isStarted()) {
        if (this._delay > 0) {
          if ((ref = this._delayThread) != null) {
            ref.update();
          }
        }
        if (this._thread != null) {
          this._updateMainThread();
        }
      } else {
        // * Если хоть раз был запущен
        if (this._isBeenStarted === true) {
          if (this._changer != null) {
            this._updateChainedChanger();
          }
        }
      }
    }

    static CreateForOpacityUp(sprite, step = 35, onDone = null, isAutoStart = true) {
      var changer;
      changer = new Changer(sprite);
      changer.change('opacity').from(0).to(255).step(step);
      changer.done(function() {
        sprite.opacity = 255;
        if (onDone != null) {
          return onDone();
        }
      });
      if (isAutoStart) {
        changer.start();
      }
      return changer;
    }

    static CreateForOpacityDown(sprite, step = 35, onDone = null, isAutoStart = true) {
      var changer;
      changer = new Changer(sprite);
      changer.change('opacity').from(sprite.opacity).to(0).step(step);
      changer.done(function() {
        sprite.opacity = 0;
        if (onDone != null) {
          return onDone();
        }
      });
      if (isAutoStart) {
        changer.start();
      }
      return changer;
    }

  };
  (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Changer.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = Changer.prototype;
    _._prepare = function() {
      if (this._field == null) {
        return;
      }
      this._orienation = this._from < this._to;
      if (!this._orienation) {
        this._step *= -1;
      }
      // * Устанавливаем начальное значение
      this.obj[this._field] = this._from;
      this._isPrepared = true;
    };
    _._makeStep = function() {
      var value;
      if (this.isDone()) {
        return;
      }
      value = this.value();
      value += this._step;
      this.obj[this._field] = value;
    };
    _._startThread = function() {
      this._prepare();
      if (this.isDone()) {
        return;
      }
      this._thread = new KDCore.TimedUpdate(this._speed, this._makeStep.bind(this));
      return this._isBeenStarted = true;
    };
    _._updateChainedChanger = function() {
      if (this._changer.isStarted()) {
        this._changer.update();
        if (this._changer.isDone()) {
          this._callDoneMethod();
          this._changer.stop();
          return this._changer = null;
        }
      } else {
        return this._changer.start();
      }
    };
    _._restart = function() {
      if (!this._isCanRepeatMore()) {
        return;
      }
      if (this._repeatCount == null) {
        // * Если указано! число повторений, то onDone метод не вызываем
        this._callDoneMethod();
      }
      if (this._isReverse === true) {
        this._swapFromTo();
      }
      this._prepare();
      return this.start();
    };
    _._swapFromTo = function() {
      var t;
      t = this._from;
      this._from = this._to;
      this._to = t;
      // * Инвентируем число step
      this._step *= -1;
    };
    _._callDoneMethod = function() {
      if (this._onDoneMethod != null) {
        return this._onDoneMethod();
      }
    };
    _._isCanRepeatMore = function() {
      if (this._repeatCount == null) {
        return true;
      }
      this._repeatCount--;
      if (this._repeatCount <= 0) {
        this.stop();
        return false;
      }
      return true;
    };
    _._updateMainThread = function() {
      this._thread.update();
      if (this.isDone()) {
        if (this._isRepeat === true) {
          this._restart();
        } else {
          if (this._changer != null) {
            this._updateChainedChanger();
          }
          this.stop();
        }
      }
    };
  })();
  // ■ END Changer.coffee
  //---------------------------------------------------------------------------

  //@[EXTEND]
  return KDCore.Changer = Changer;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Color;
  Color = (function() {
    //rev 29.04.2024
    class Color {
      constructor(r1 = 255, g1 = 255, b1 = 255, a1 = 255) {
        this.r = r1;
        this.g = g1;
        this.b = b1;
        this.a = a1;
      }

      getLightestColor(lightLevel) {
        var bf, newColor, p;
        bf = 0.3 * this.R + 0.59 * this.G + 0.11 * this.B;
        p = 0;
        newColor = [0, 0, 0, 0];
        if (bf - lightLevel >= 0) {
          if (bf >= 0) {
            p = Math.abs(bf - lightLevel) / lightLevel;
          }
          newColor = this.ARR.map(function(c) {
            return c - (p * c);
          });
        } else {
          if (bf >= 0) {
            p = (lightLevel - bf) / (255 - bf);
          }
          newColor = this.ARR.map(function(c) {
            return [(255 - c) * p + c, 255].min();
          });
        }
        return new Color(newColor[0], newColor[1], newColor[2], newColor[3]);
      }

      clone() {
        return this.reAlpha(this.a);
      }

      reAlpha(newAlpha) {
        return new Color(this.r, this.g, this.b, newAlpha || 255);
      }

      static AddConstantColor(name, color) {
        color.toHex();
        color.toArray();
        color.toCSS();
        KDCore.SDK.setConstantToObject(Color, name, color);
      }

      toHex() {
        var b, g, r;
        if (this._colorHex != null) {
          return this._colorHex;
        }
        r = Math.floor(this.r).toString(16).padZero(2);
        g = Math.floor(this.g).toString(16).padZero(2);
        b = Math.floor(this.b).toString(16).padZero(2);
        return this._colorHex = '#' + r + g + b;
      }

      toArray() {
        if (this._colorArray != null) {
          return this._colorArray;
        }
        return this._colorArray = [this.r, this.g, this.b, this.a];
      }

      toCSS() {
        var na, nb, ng, nr;
        if (this._colorCss != null) {
          return this._colorCss;
        }
        nr = Math.round(this.r);
        ng = Math.round(this.g);
        nb = Math.round(this.b);
        na = this.a / 255;
        return this._colorCss = `rgba(${nr},${ng},${nb},${na})`;
      }

      toNumber() {
        return Number(this.toHex().replace("#", "0x"));
      }

      static Random() {
        var a, b, c;
        a = KDCore.SDK.rand(1, 254);
        b = KDCore.SDK.rand(1, 254);
        c = KDCore.SDK.rand(1, 254);
        return new Color(a, b, c, 255);
      }

      static FromHex(hexString) {
        var color, result, shorthandRegex;
        //Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
        shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hexString = hexString.replace(shorthandRegex, function(m, r, g, b) {
          return r + r + g + g + b + b;
        });
        result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hexString);
        color = null;
        if (result != null) {
          color = {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
          };
        }
        if (color != null) {
          return new Color(color.r, color.g, color.b, 255);
        } else {
          return Color.NONE;
        }
      }

    };

    Object.defineProperties(Color.prototype, {
      R: {
        get: function() {
          return this.r;
        },
        configurable: true
      },
      G: {
        get: function() {
          return this.g;
        },
        configurable: true
      },
      B: {
        get: function() {
          return this.b;
        },
        configurable: true
      },
      A: {
        get: function() {
          return this.a;
        },
        configurable: true
      },
      ARR: {
        get: function() {
          return this.toArray();
        },
        configurable: true
      },
      CSS: {
        get: function() {
          return this.toCSS();
        },
        configurable: true
      },
      HEX: {
        get: function() {
          return this.toHex();
        },
        configurable: true
      },
      OX: {
        get: function() {
          return this.toNumber();
        },
        configurable: true
      }
    });

    Color.AddConstantColor('NONE', new Color(0, 0, 0, 0));

    Color.AddConstantColor('BLACK', new Color(0, 0, 0, 255));

    Color.AddConstantColor('WHITE', new Color(255, 255, 255, 255));

    Color.AddConstantColor('RED', new Color(255, 0, 0, 255));

    Color.AddConstantColor('GREEN', new Color(0, 255, 0, 255));

    Color.AddConstantColor('BLUE', new Color(0, 0, 255, 255));

    Color.AddConstantColor('AQUA', new Color(128, 255, 255, 255));

    Color.AddConstantColor('MAGENTA', new Color(128, 0, 128, 255));

    Color.AddConstantColor('YELLOW', new Color(255, 255, 0, 255));

    Color.AddConstantColor('ORANGE', new Color(255, 128, 0, 255));

    return Color;

  }).call(this);
  //@[EXTEND]
  return KDCore.Color = Color;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Color, DevLog, __TMP_LOGS__;
  Color = KDCore.Color;
  __TMP_LOGS__ = [];
  DevLog = class DevLog {
    constructor(prefix = "") {
      this.prefix = prefix;
      this._isShow = typeof DEV !== 'undefined';
      this._color = Color.BLACK;
      this._backColor = Color.WHITE;
      __TMP_LOGS__.push(this);
    }

    on() {
      this._isShow = true;
      return this;
    }

    off() {
      this._isShow = false;
      return this;
    }

    applyRandomColors() {
      this.applyRandomWithoutBackgroundColors();
      this.setBackColor(Color.Random());
      return this;
    }

    applyRandomWithoutBackgroundColors() {
      this.setColor(Color.Random());
      return this;
    }

    setColor(color) {
      this._color = color;
      return this;
    }

    setBackColor(backColor) {
      this._backColor = backColor;
      return this;
    }

    applyLibraryColors() {
      this.setColors(new Color(22, 120, 138, 0), Color.BLACK);
      return this;
    }

    setColors(color, backColor) {
      this.setColor(color);
      this.setBackColor(backColor);
      return this;
    }

    applyExtensionColors() {
      this.setColors(new Color(22, 143, 137, 0), Color.BLACK.getLightestColor(60));
      return this;
    }

    applyWarningColors() {
      this.setColors(Color.ORANGE, Color.BLACK.getLightestColor(100));
      return this;
    }

    p(text) {
      if (!this._isShow) {
        return;
      }
      if (text == null) {
        console.log("");
      }
      this._printText(text);
    }

    _printText(text) {
      text = this.prefix + " : " + text;
      if (this._isUsingColor()) {
        return this._printTextWithColors(text);
      } else {
        return console.log(text);
      }
    }

    _isUsingColor() {
      return this._color !== Color.BLACK || this._backColor !== Color.WHITE;
    }

    _printTextWithColors(text) {
      var args;
      args = ['%c' + text, `color: ${this._color.HEX} ; background: ${this._backColor.HEX};`];
      return window.console.log.apply(console, args);
    }

    static CreateForLib(library) {
      var dlog;
      dlog = new DevLog(library.name);
      dlog.applyLibraryColors();
      return dlog;
    }

    static EnableAllLogs() {
      return __TMP_LOGS__.forEach(function(log) {
        return log.on();
      });
    }

  };
  //@[EXTEND]
  return KDCore.DevLog = DevLog;
});


// Generated by CoffeeScript 2.6.1
// * Класс для глобального события игры (НЕ события на карте)
KDCore.registerLibraryToLoad(function() {
  //@[AUTO EXTEND]
  return KDCore.GEvent = class GEvent {
    constructor(name) {
      this.name = name;
      this.clear();
    }

    addListener(listener, isSingle = false) {
      if (listener == null) {
        return;
      }
      if (isSingle === true) {
        this.listeners = [listener];
      } else {
        this.listeners.push(listener);
      }
    }

    removeListener(listener) {
      if (listener == null) {
        return;
      }
      return this.listener.delete(listener);
    }

    call() {
      var i, l, len, ref;
      ref = this.listeners;
      for (i = 0, len = ref.length; i < len; i++) {
        l = ref[i];
        l();
      }
    }

    clear() {
      return this.listeners = [];
    }

  };
});


// Generated by CoffeeScript 2.6.1
// * Менеджер для управления глобальными событиями игры (GEvent) (НЕ события на карте)
KDCore.registerLibraryToLoad(function() {
  var GEventsManager;
  // * Данный менеджер глобальный, т.е. с ним работают ВСЕ плагины, которые его используют!
  GEventsManager = function() {};
  (function() {
    var _;
    _ = GEventsManager;
    // * Существует ли событие с данным именем
    _.isEventExists = function(gEventName) {
      return this._getEventByName(gEventName) != null;
    };
    // * Получить список всех зарегестрированных событий (имён)
    _.getAllEvents = function() {
      if (this.events == null) {
        return [];
      }
      return this.events.map(function(ev) {
        return ev.name;
      });
    };
    // * Зарегестрировать событие (используется только имя события)
    _.register = function(gEventName) {
      if (this.events == null) {
        this.events = [];
      }
      this.events.push(new KDCore.GEvent(gEventName));
    };
    // * Подписаться на событие (имя события) и слушатель
    // * если isSingle == true - то у события может быть только один исполнитель
    _.subscribeFor = function(evName, listener, isSingle = false) {
      var ref;
      return (ref = this._getEventByName(evName)) != null ? ref.addListener(listener, isSingle) : void 0;
    };
    // * Подписаться на событие (уникально) для объекта
    // * Т.е. при вызове этого метода ещё раз, если объект
    // * уже подписан на событие, ничего не будет (без дубликатов)
    //? ВНИМАНИЕ ! Если объект подписался через subscribeForX, то
    // выполнив clear по данному evName, он уже не подпишится!
    _.subscribeForX = function(context, evName, listener) {
      var e, key;
      try {
        key = "__kdCoreGEvent_" + evName;
        if (context[key] == null) {
          this.subscribeFor(evName, listener);
          return context[key] = true;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    // * Вызвать событие (по имени)
    _.call = function(evName) {
      var ref;
      return (ref = this._getEventByName(evName)) != null ? ref.call() : void 0;
    };
    _.clear = function(evName) {
      var ref;
      return (ref = this._getEventByName(evName)) != null ? ref.clear() : void 0;
    };
    _._getEventByName = function(name) {
      if (!this.events) {
        return null;
      }
      return this.events.find(function(ev) {
        return ev.name === name;
      });
    };
  })();
  //@[EXTEND]
  return KDCore.GEventsManager = GEventsManager;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  //@[AUTO EXTEND]
  return KDCore.MapAnchorPoint = class MapAnchorPoint {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this._realX = this.x;
      this._realY = this.y;
    }

    shiftY() {
      return 0;
    }

    jumpHeight() {
      return 0;
    }

    scrolledX() {
      return Game_CharacterBase.prototype.scrolledX.call(this);
    }

    scrolledY() {
      return Game_CharacterBase.prototype.scrolledY.call(this);
    }

    screenX() {
      return Game_CharacterBase.prototype.screenX.call(this);
    }

    screenY() {
      return Game_CharacterBase.prototype.screenY.call(this);
    }

    moveTo(x, y) {
      this.x = x;
      this.y = y;
      this._realX = this.x;
      this._realY = this.y;
    }

  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  //@[AUTO EXTEND]
  //?[DEPRECATED]
  return KDCore.ParametersManager = class ParametersManager {
    constructor(pluginName) {
      this.pluginName = pluginName;
      this._cache = {};
      this._parameters = PluginManager.getPluginParametersByRoot(this.pluginName);
    }

    isLoaded() {
      return (this._parameters != null) && this._parameters.hasOwnProperty(this.pluginName);
    }

    isHasParameter(name) {
      return this._parameters[name] != null;
    }

    getString(name) {
      return this._parameters[name];
    }

    convertField(object, fieldName) {
      var e;
      try {
        object[fieldName] = JSON.parse(object[fieldName] || 'false');
      } catch (error) {
        e = error;
        console.error('Error while convert field ' + e.name);
        object[fieldName] = false;
      }
      return object;
    }

    convertImage(object, fieldName) {
      return object[fieldName] = this.loadImage(object[fieldName]);
    }

    loadImage(filename, smooth) {
      var e, path;
      try {
        if (filename) {
          path = filename.split('/');
          filename = path.last();
          path = path.first() + '/';
          return ImageManager.loadBitmap('img/' + path, filename, 0, smooth || true);
        } else {
          return ImageManager.loadEmptyBitmap();
        }
      } catch (error) {
        e = error;
        console.error(e);
        return ImageManager.loadEmptyBitmap();
      }
    }

    getFromCacheOrInit(name, func) {
      var object;
      if (!this.isInCache(name)) {
        if (func != null) {
          object = func.call(this);
          this.putInCache(name, object);
        }
      }
      return this.getFromCache(name);
    }

    isInCache(name) {
      return this._cache.hasOwnProperty(name);
    }

    putInCache(name, object) {
      return this._cache[name] = object;
    }

    getFromCache(name) {
      return this._cache[name];
    }

    getNumber(name) {
      var number;
      number = this.getObject(name);
      if (KDCore.SDK.isInt(number)) {
        return number;
      }
      return 0;
    }

    getObject(name) {
      if (this.isHasParameter(name)) {
        return JSON.parse(this.getString(name) || '{}');
      } else {
        return {};
      }
    }

    getBoolean(name) {
      if (this.isHasParameter(name)) {
        return JSON.parse(this.getString(name) || false);
      } else {
        return false;
      }
    }

    getBooleanFromCacheWithDefault(name, defaultValue) {
      if (this.isHasParameter(name)) {
        return this.getBooleanFromCache(name);
      } else {
        return defaultValue;
      }
    }

    getNumberFromCacheWithDefault(name, defaultValue) {
      if (this.isHasParameter(name)) {
        return this.getNumberFromCache(name);
      } else {
        return defaultValue;
      }
    }

    getStringFromCacheWithDefault(name, defaultValue) {
      if (this.isHasParameter(name)) {
        return this.getStringFromCache(name);
      } else {
        return defaultValue;
      }
    }

    getBooleanFromCache(name) {
      return this.getFromCacheOrInit(name, function() {
        return this.getBoolean(name);
      });
    }

    getNumberFromCache(name) {
      return this.getFromCacheOrInit(name, function() {
        return this.getNumber(name);
      });
    }

    getStringFromCache(name) {
      return this.getFromCacheOrInit(name, function() {
        return this.getString(name);
      });
    }

  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  //@[AUTO EXTEND]
  return KDCore.ParamLoader = class ParamLoader {
    constructor(pluginName) {
      this.pluginName = pluginName;
      this.paramsRaw = PluginManager.getPluginParametersByRoot(this.pluginName);
      this.params = this.parseParameters(this.paramsRaw);
    }

    parseParameters(paramSet) {
      var clearKey, key, params, typeKey, value;
      params = {};
      for (key in paramSet) {
        value = paramSet[key];
        KDCore.__ppNameToParseNext = key;
        clearKey = this.parseKey(key);
        typeKey = this.parseKeyType(key);
        params[clearKey] = this.parseParamItem(typeKey, value);
      }
      return params;
    }

    parseKey(keyRaw) {
      return keyRaw.split(":")[0];
    }

    parseKeyType(keyRaw) {
      return keyRaw.split(":")[1];
    }

    writeDetailedError() {
      var e;
      try {
        if (!String.any(KDCore.__ppNameToParseNext)) {
          return;
        }
        return console.warn("Please, check Plugin Parameter " + KDCore.__ppNameToParseNext + " in plugin " + this.pluginName);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    // * Проверка, загружены ли параметры плагина
    isLoaded() {
      return (this.paramsRaw != null) && this.paramsRaw.hasOwnProperty(this.pluginName);
    }

    // * Имя параметра без ключа
    isHasParameter(paramName) {
      return this.params[paramName] != null;
    }

    
      // * Возвращает значение параметра (def - по умолчанию, если не найден)
    getParam(paramName, def) {
      var value;
      if (this.isHasParameter(paramName)) {
        value = this.params[paramName];
        if (value != null) {
          return value;
        }
      }
      return def;
    }

    // * Данные ключи должны идти после названия параметра через :
    // * Пример: @param ShowDelay:int, @param TestBool:bool
    // * Текстовые параметры, которые надо вернуть как есть, можно без типа (text, file, combo, ...)
    parseParamItem(type, item) {
      var e;
      if (type == null) {
        return item;
      }
      try {
        switch (type) {
          case "int":
          case "i":
            return Number(item);
          case "intA":
            return this.parseArray(item, "int");
          case "bool":
          case "b":
          case "e":
            return eval(item);
          case "struct":
          case "s":
            return this.parseStruct(item);
          case "structA":
            return this.parseStructArray(item);
          case "str":
            return item;
          case "strA":
            return this.parseArray(item, "str");
          case "note":
            return this.parseNote(item);
          case "css":
            return item.toCss();
          case "color":
            return KDCore.Color.FromHex(item);
          case "json":
          case "j":
            return this.parseJson(item);
          case "jA":
            return this.parseArray(item, 'json');
          default:
            return item;
        }
      } catch (error) {
        e = error;
        console.warn(e);
        this.writeDetailedError();
        return item;
      }
    }

    parseArray(items, type) {
      var e, elements, i, len, p, parsed;
      try {
        elements = [];
        parsed = JsonEx.parse(items);
        for (i = 0, len = parsed.length; i < len; i++) {
          p = parsed[i];
          try {
            elements.push(this.parseParamItem(type, p));
          } catch (error) {
            e = error;
            console.warn(e);
          }
        }
      } catch (error) {
        e = error;
        console.warn(e);
        this.writeDetailedError();
      }
      return elements;
    }

    parseStruct(item) {
      var e, parsed;
      try {
        if (item == null) {
          return null;
        }
        if (!String.any(item)) {
          return null;
        }
        parsed = JsonEx.parse(item);
        if (parsed != null) {
          return this.parseParameters(parsed);
        }
      } catch (error) {
        e = error;
        console.warn(e);
        this.writeDetailedError();
      }
      return null;
    }

    parseStructArray(items) {
      var e, elements, i, len, p, parsed;
      try {
        elements = [];
        parsed = JsonEx.parse(items);
        for (i = 0, len = parsed.length; i < len; i++) {
          p = parsed[i];
          try {
            elements.push(this.parseStruct(p));
          } catch (error) {
            e = error;
            console.warn(e);
            this.writeDetailedError();
          }
        }
      } catch (error) {
        e = error;
        console.warn(e);
        this.writeDetailedError();
      }
      return elements;
    }

    parseNote(item) {
      var e, parsed;
      try {
        parsed = JsonEx.parse(item);
        if (parsed != null) {
          return parsed;
        }
      } catch (error) {
        e = error;
        console.warn(e);
        this.writeDetailedError();
      }
      return item;
    }

    parseJson(item) {
      var cx, e, element, elements, i, json, key, len, parsed, value;
      try {
        json = {};
        parsed = JsonEx.parse(item);
        elements = parsed.split('\n');
        for (i = 0, len = elements.length; i < len; i++) {
          element = elements[i];
          cx = "{" + element + "}";
          try {
            item = JsonEx.parse(cx);
            for (key in item) {
              value = item[key];
              json[key] = value;
            }
          } catch (error) {
            e = error;
            KDCore.warning("Parameter " + element + " have syntax errors, ignored");
          }
        }
        return json;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        this.writeDetailedError();
        return null; // * Чтобы default value был возвращён
      }
    }

  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Point;
  Point = (function() {
    class Point {
      constructor(_x = 0, _y = 0) {
        this._x = _x;
        this._y = _y;
      }

      clone() {
        return new Point(this._x, this._y);
      }

      toString() {
        return "[" + this._x + " ; " + this._y + "]";
      }

      isSame(anotherPoint) {
        return this.x === anotherPoint.x && this.y === anotherPoint.y;
      }

      convertToCanvas() {
        return new Point(Graphics.pageToCanvasX(this._x), Graphics.pageToCanvasY(this._y));
      }

      convertToMap() {
        return new Point($gameMap.canvasToMapX(this._x), $gameMap.canvasToMapY(this._y));
      }

      convertToScreen() {
        return new Point(this.screenX(), this.screenY());
      }

      screenX() {
        var t, tw;
        t = $gameMap.adjustX(this._x);
        tw = $gameMap.tileWidth();
        return Math.round(t * tw + tw / 2);
      }

      screenY() {
        var t, th;
        t = $gameMap.adjustY(this._y);
        th = $gameMap.tileHeight();
        return Math.round(t * th + th);
      }

      round() {
        return new Point(Math.round(this._x), Math.round(this._y));
      }

      floor() {
        return new Point(Math.floor(this._x), Math.floor(this._y));
      }

      mapPointOnScreen() {
        var nx, ny;
        nx = (this._x * $gameMap.tileWidth()) - ($gameMap.displayX() * $gameMap.tileWidth());
        ny = (this._y * $gameMap.tileHeight()) - ($gameMap.displayY() * $gameMap.tileHeight());
        return new Point(nx, ny);
      }

      multiplyBy(val) {
        return new Point(this._x * val, this._y * val);
      }

      simple() {
        return new PIXI.Point(this.x, this.y);
      }

      delta(point) {
        var dx, dy;
        dx = point.x - this._x;
        dy = point.y - this._y;
        return new KDCore.Point(dx, dy);
      }

      static _getEmpty() {
        if (Point._emptyPoint == null) {
          Point._emptyPoint = new Point(0, 0);
        }
        return Point._emptyPoint;
      }

    };

    Object.defineProperties(Point.prototype, {
      x: {
        get: function() {
          return this._x;
        },
        configurable: true
      },
      y: {
        get: function() {
          return this._y;
        },
        configurable: true
      }
    });

    Object.defineProperties(Point, {
      Empty: {
        get: function() {
          return Point._getEmpty();
        },
        configurable: false
      }
    });

    Array.prototype.toPoint = function() {
      return new Point(this[0], this[1]);
    };

    Object.defineProperty(Array.prototype, "toPoint", {
      enumerable: false
    });

    Sprite.prototype.toPoint = function() {
      return new Point(this.x, this.y);
    };

    Game_CharacterBase.prototype.toPoint = function() {
      return new Point(this.x, this.y);
    };

    return Point;

  }).call(this);
  //@[EXTEND]
  return KDCore.Point = Point;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  return KDCore.Sprite = (function(superClass) {
    //rev 07.05.22

      //@[AUTO EXTEND]
    class Sprite extends superClass {
      constructor() {
        super(...arguments);
        this.pHandledIndex = 0;
        this._create2();
        return;
      }

      _create2() {} // * FOR CHILDRENS

      pIsSupportKeyboardHandle() {
        return false;
      }

      pIsVerticalKeyboardNavigation() {
        return true;
      }

      pIsFreeKeyboardNavigation() {
        return false;
      }

      // * For Childrens
      isLoaded() {
        return true;
      }

      isNotHaveBounds() {
        return this._isNotHaveBounds === true;
      }

      realWidth() {
        var child;
        if (this.isNotHaveBounds()) {
          return 0;
        }
        if (this.width === 0) {
          child = this.zeroChild();
          if (child != null) {
            if (child.realWidth != null) {
              return child.realWidth();
            } else {
              return child.width;
            }
          }
        }
        return this.width;
      }

      realHeight() {
        var child;
        if (this.isNotHaveBounds()) {
          return 0;
        }
        if (this.height === 0) {
          child = this.zeroChild();
          if (child != null) {
            if (child.realHeight != null) {
              return child.realHeight();
            } else {
              return child.height;
            }
          }
        }
        return this.height;
      }

      dataBindings() {
        return {
          x: function(v) {
            if (v != null) {
              return this.setPosition(v, this.y);
            }
          },
          y: function(v) {
            if (v != null) {
              return this.setPosition(this.x, v);
            }
          },
          position: function(v) {
            if (v != null) {
              return this.setPosition(v);
            }
          },
          anchor: function(v) {
            if (v != null) {
              return this.setCommonAnchor(v);
            }
          },
          animation: function(v) {
            if (v != null) {
              return this.addAnimationRule(v);
            }
          },
          opacity: function(v) {
            if (v != null) {
              return this.opacity = v;
            }
          },
          visible: function(v) {
            if (v != null) {
              return this.visible = v;
            }
          },
          scale: function(v) {
            if (v != null) {
              return this.scale.set(v);
            }
          },
          rotation: function(v) {
            if (v != null) {
              return this.rotation = v;
            }
          },
          centeredScale: function(v) {
            if (v != null) {
              return this.setCenteredScale(v);
            }
          },
          physicalBounds: function(v) {
            if (v != null) {
              return this._isNotHaveBounds = !v;
            }
          }
        };
      }

      setCenteredScale(value) {
        var e;
        try {
          if (!this.isLoaded()) {
            this._requireFunc('setCenteredScale', arguments);
            return;
          }
          this._refreshAnchoredCenter();
          return this._scaleFactor = value;
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      callBinding(binding, value) {
        var e, func;
        try {
          func = this.dataBindings()[binding];
          if (func != null) {
            return func.call(this, value);
          } else {
            return console.warn("Binding " + binding + " not found!");
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      refreshBindings(dataObject = null, recursive = true) {
        var child, e, j, len, ref, results;
        try {
          if (dataObject == null) {
            dataObject = this;
          }
          KDCore.UI.Builder.RefreshBindings(this, dataObject);
          if (recursive === true) {
            ref = this.children;
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              child = ref[j];
              try {
                if (child.refreshBindings != null) {
                  results.push(child.refreshBindings(dataObject, true));
                } else {
                  results.push(void 0);
                }
              } catch (error) {
                e = error;
                results.push(KDCore.warning(e));
              }
            }
            return results;
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      uiConstant(name) {
        var e;
        try {
          if (this.uiConstants != null) {
            return this.uiConstants[name];
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        return null;
      }

      addLoadListener(listener) {
        var e;
        try {
          if (listener == null) {
            return;
          }
          if (this.isLoaded()) {
            try {
              return listener();
            } catch (error) {
              e = error;
              return KDCore.warning(e);
            }
          } else {
            return this._addLoadListener(listener);
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      setPosition(x = 0, y = null, bindedObj = null) {
        var _x, _y, e;
        try {
          if (!this.isLoaded()) {
            this._requireFunc('setPosition', arguments);
            return;
          }
          // * Check first Argument as Object
          if (typeof x === 'object') {
            if (x.x != null) {
              _x = x.x;
              if (x.y != null) {
                _y = x.y;
              }
              x = _x;
              y = _y;
            } else if (x.position != null) {
              this.setPosition(x.position, null, bindedObj);
              return;
            } else if (x.margins != null) {
              this.setPosition(x.margins, null, bindedObj);
              return;
            }
          }
          if (typeof x === 'string') {
            this.x = this._getValueByStr(x, 'x', bindedObj);
            if (y == null) {
              y = x;
            }
          } else {
            this.x = x; // * Number
          }
          if (typeof y === 'string') {
            return this.y = this._getValueByStr(y, 'y', bindedObj);
          } else {
            if (y != null) {
              return this.y = y;
            }
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _getValueByStr(value = '0', forField = 'x', owner = null) {
        var dpValue, e, exValue, parentRefSize, percentValue, r, result, resultValue, v;
        try {
          if (typeof value === 'number') {
            return value;
          }
          if (isFinite(value)) {
            return Number(value);
          }
          if (typeof value !== 'string') {
            return 0;
          }
          // * NO REPLACEMENT
          if (value[0] === '$' || value[0] === '@') {
            v = KDCore.Utils.convertBindingValue(owner, value, this);
            return this._getValueByStr(v, forField, owner);
          }
          if (value.contains("prevX")) {
            value = value.replace("prevX", this._getPreviousChildData('x'));
            return this._getValueByStr(value, forField, owner);
          }
          if (value.contains("prevY")) {
            value = value.replace("prevY", this._getPreviousChildData('y'));
            return this._getValueByStr(value, forField, owner);
          }
          if (value.contains("prevHeight")) {
            value = value.replace("prevHeight", this._getPreviousChildData('height'));
            return this._getValueByStr(value, forField, owner);
          }
          if (value.contains("prevWidth")) {
            value = value.replace("prevWidth", this._getPreviousChildData('width'));
            return this._getValueByStr(value, forField, owner);
          }
          if (value.contains("prevEndX")) {
            value = value.replace("prevEndX", "prevX + prevWidth");
            return this._getValueByStr(value, forField, owner);
          }
          if (value.contains("prevEndY")) {
            value = value.replace("prevEndY", "prevY + prevHeight");
            return this._getValueByStr(value, forField, owner);
          }
          if (value.contains("end")) {
            value = value.replace("end", "100%");
          }
          if (value.contains("begin")) {
            if (forField === 'y') {
              value = value.replace("begin", "-height");
            } else {
              value = value.replace("begin", "-width");
            }
          }
          if (value.contains("right")) {
            value = value.replace("right", "100% - width");
            return this._getValueByStr(value, forField, owner);
          }
          if (value.contains("left")) {
            value = value.replace("left", "0");
            return this._getValueByStr(value, forField, owner);
          }
          if (value.contains("top")) {
            value = value.replace("top", "0");
            return this._getValueByStr(value, forField, owner);
          }
          if (value.contains("bottom")) {
            value = value.replace("bottom", "100% - height");
            return this._getValueByStr(value, forField, owner);
          }
          // * Replace all X%
          if (value.contains("%")) {
            r = new RegExp("(\\d+)%", "g");
            result = r.exec(value);
            while ((result != null)) {
              percentValue = Number(result[1]);
              resultValue = 0;
              if (this.parent != null) {
                parentRefSize = KDCore.Utils.getRealSpriteSize(forField, this.parent);
                resultValue = parentRefSize * (percentValue / 100.0);
              }
              value = value.replace(/(\d+)%/, resultValue);
              result = r.exec(value);
            }
          }
          // * Replace all HDP
          if (value.contains("hdp")) {
            r = new RegExp("(\\d+)hdp", "g");
            result = r.exec(value);
            while ((result != null)) {
              dpValue = Number(result[1]);
              resultValue = KDCore.Utils.convertDP(dpValue, true);
              value = value.replace(/(\d+)hdp/, resultValue);
              result = r.exec(value);
            }
          }
          // * Replace all DP
          if (value.contains("dp")) {
            r = new RegExp("(\\d+)dp", "g");
            result = r.exec(value);
            while ((result != null)) {
              dpValue = Number(result[1]);
              resultValue = KDCore.Utils.convertDP(dpValue, false);
              value = value.replace(/(\d+)dp/, resultValue);
              result = r.exec(value);
            }
          }
          if (value.contains('center')) {
            v = this._getValueByStr('50%', forField, owner);
            exValue = KDCore.Utils.getRealSpriteSize(forField, this);
            exValue = v - (exValue / 2);
            value = value.replace("center", exValue);
            return this._getValueByStr(value, forField, owner);
          }
          if (value.contains("height")) {
            exValue = KDCore.Utils.getRealSpriteSize("height", this);
            value = value.replace("height", exValue);
            return this._getValueByStr(value, forField, owner);
          }
          if (value.contains("width")) {
            exValue = KDCore.Utils.getRealSpriteSize("width", this);
            value = value.replace("width", exValue);
            return this._getValueByStr(value, forField, owner);
          }
          v = eval(value);
          return this._getValueByStr(v, forField, owner);
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        return 0;
      }

      _getPreviousChildData(forField) {
        var e, myIndex, prevChild;
        try {
          if (this.parent == null) {
            return 0;
          }
          if (this.parent.children.length <= 1) {
            return 0;
          }
          myIndex = this.parent.children.indexOf(this);
          prevChild = this.parent.children[myIndex - 1];
          if (prevChild == null) {
            return 0;
          }
          if (forField === "x") {
            return prevChild.x;
          } else if (forField === "y") {
            return prevChild.y;
          } else {
            return KDCore.Utils.getRealSpriteSize(forField, prevChild);
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        return 0;
      }

      setCommonAnchor(x, y) {
        var c, e, j, len, ref;
        try {
          if (y == null) {
            y = x;
          }
          this.anchor.x = x;
          this.anchor.y = y;
          ref = this.children;
          for (j = 0, len = ref.length; j < len; j++) {
            c = ref[j];
            if (c == null) {
              continue;
            }
            if (c.setCommonAnchor != null) {
              c.setCommonAnchor(x, y);
            } else {
              if (c.anchor == null) {
                continue;
              }
              c.anchor.x = x;
              c.anchor.y = y;
            }
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
      }

      zeroChild() {
        return this.children[0];
      }

      appear(step, delay = 0) {
        this.opacity = 0;
        this._opChanger = KDCore.Changer.CreateForOpacityUp(this, step, () => {
          this._opChanger = null;
          return this._updateOpChanger = function() {}; // * EMPTY
        }, false); // * Not autostart for Delay
        if (delay > 0) {
          this._opChanger.delay(delay);
        }
        this._opChanger.start();
        this._updateOpChanger = () => {
          var ref;
          return (ref = this._opChanger) != null ? ref.update() : void 0;
        };
      }

      disapper(step, delay = 0) {
        this._opChanger = KDCore.Changer.CreateForOpacityDown(this, step, () => {
          this._opChanger = null;
          return this._updateOpChanger = function() {}; // * EMPTY
        }, false); // * Not autostart for Delay
        if (delay > 0) {
          this._opChanger.delay(delay);
        }
        this._opChanger.start();
        this._updateOpChanger = () => {
          var ref;
          return (ref = this._opChanger) != null ? ref.update() : void 0;
        };
      }

      moveWithAnimation(dx, dy, duration = 30, easingType = 2) {
        var e;
        try {
          this._moveAnimationItem = new Game_Picture();
          this._moveAnimationItem._x = this.x;
          this._moveAnimationItem._y = this.y;
          this._moveAnimationItem.move(0, this.x + dx, this.y + dy, 1, 1, 255, 0, duration, easingType);
          this.updateMovingAnimation = this.updateMovingAnimationBody;
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
      }

      assignTooltip(content, params) {
        if (this._tooltip != null) {
          this.removeChild(this._tooltip);
        }
        this._tooltip = new KDCore.UI.Sprite_UITooltip(params);
        this._tooltip.addContent(content);
        this.updateTooltip = this.updateTooltipBody;
      }

      destroyTooltip() {
        if (this._tooltip == null) {
          return;
        }
        this.hideTooltip();
        this.removeChild(this._tooltip);
        this._tooltip = null;
        return this.updateTooltip = function() {}; // * EMPTY
      }

      showTooltip() {
        if (this._tooltip == null) {
          return;
        }
        // * Position 0, 0, becouse cursorRelative by default
        this._tooltip.activateTooltip(0, 0, this);
      }

      hideTooltip() {
        if (this._tooltip == null) {
          return;
        }
        this._tooltip.deactivateTooltip();
      }

      //@[DYNAMIC]
      updateTooltip() {} // * EMPTY

      updateTooltipBody() {
        if (this.isUnderMouse()) {
          if (this._tooltip.isTooltipActive()) {

          } else {
            if (this.isReady() && this.visible === true && this.opacity >= 255) {
              return this.showTooltip();
            }
          }
        } else {
          if (this._tooltip.isTooltipActive()) {
            return this.hideTooltip();
          }
        }
      }

      //@[DYNAMIC]
      updateMovingAnimation() {} // * EMPTY

      updateMovingAnimationBody() {
        var e;
        try {
          if (this._moveAnimationItem == null) {
            return;
          }
          this._moveAnimationItem.update();
          this.x = this._moveAnimationItem._x;
          this.y = this._moveAnimationItem._y;
          if (this._moveAnimationItem._duration <= 0) {
            this._moveAnimationItem = null;
            this.updateMovingAnimation = function() {};
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
          this.updateMovingAnimation = function() {};
        }
      }

      addAnimationRule(rule) {
        var e, r;
        try {
          if (rule == null) {
            return;
          }
          if (this._animationRules == null) {
            this._animationRules = [];
          }
          if (typeof rule === 'object' && (rule.animationConfig != null) && (rule.update != null)) {
            r = rule;
          } else {
            r = new KDCore.AnimationRule(rule, this);
          }
          this._animationRules.push(r);
          return r;
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        return null;
      }

      setAnimationRule(rule) {
        var e;
        try {
          this._animationRules = [];
          return this.addAnimationRule(rule);
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        return null;
      }

      isShouldAlwaysKeepCenter() {
        return this.__anchoredCenterX != null;
      }

      // * For Animation Rule (callback)
      onBeforeChangeScaleFactor() {
        var e;
        try {
          if (this.isShouldAlwaysKeepCenter()) {
            return this._refreshAnchoredCenter();
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      update() {
        super.update();
        this._updateOpChanger();
        this.updateTooltip();
        if (this.updateMovingAnimation != null) {
          this.updateMovingAnimation();
        }
        if (this.pIsHandlerActive()) {
          this._pHandleKeyboardInputs();
        }
        if (this.devdrag === true) {
          this._pUpdateDevDrag();
        }
        if (this._animationRules != null) {
          this._pUpdateAnimationRules();
        }
        if (this._scaleFactor != null) {
          this._pUpdateScaleFactor();
        }
      }

      _pUpdateScaleFactor() {
        var e;
        try {
          if (this.scale.x !== this._scaleFactor || this.scale.y !== this._scaleFactor) {
            this.scale.set(this._scaleFactor);
            if (this.isShouldAlwaysKeepCenter()) {
              return this._refreshRelativeCenterPosition();
            }
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _refreshAnchoredCenter() {
        var e;
        try {
          if (this.__lastCenterBaseX !== this.x || this.__lastCenterBaseY !== this.y) {
            this.__lastCenterBaseX = this.x;
            this.__lastCenterBaseY = this.y;
          }
          this.__anchoredCenterX = this.__lastCenterBaseX + this.realWidth() / 2;
          return this.__anchoredCenterX = this.__lastCenterBaseY + this.realHeight() / 2;
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _refreshRelativeCenterPosition() {
        var e, newHeight, newWidth;
        try {
          // Смещение позиции для сохранения центра
          newWidth = this.realWidth() * this.scale.x;
          newHeight = this.realHeight() * this.scale.y;
          this.x = this.__anchoredCenterX - newWidth / 2;
          return this.y = this.__anchoredCenterX - newHeight / 2;
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _pUpdateAnimationRules() {
        var e, j, len, ref, results, rule;
        try {
          ref = this._animationRules;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            rule = ref[j];
            rule.update();
            results.push(rule.applyAnimation(this));
          }
          return results;
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      //@[DYNAMIC]
      _updateOpChanger() {} // * EMPTY

      b() {
        return this.bitmap;
      }

      clear() {
        return this.bitmap.clear();
      }

      add() {
        return this.addChild(...arguments);
      }

      bNew(w, h) {
        if (h == null) {
          h = w;
        }
        return this.bitmap = new Bitmap(w, h);
      }

      bImg(filename, sourceFolder) {
        var getterFunc;
        getterFunc = function(filename) {
          return ImageManager.loadPicture(filename);
        };
        if (sourceFolder != null) {
          getterFunc = function(filename) {
            return ImageManager.loadBitmap("img/" + sourceFolder + "/", filename);
          };
        }
        return this.bitmap = getterFunc(filename);
      }

      onReady(method) {
        if (method != null) {
          return this.bitmap.addLoadListener(method);
        }
      }

      drawText() {
        return this.bitmap.drawText(...arguments);
      }

      drawTextFull(text, position = "center") {
        if (this.textSettingsPosition != null) {
          position = this.textSettingsPosition;
        }
        return this.bitmap.drawTextFull(text, position);
      }

      //?DEPRECATED
      drawTextWithSettings(text) {
        this.clear();
        this.drawTextFull(text, this.textSettingsPosition);
      }

      //? x, y, icon, size
      drawIcon() {
        return this.bitmap.drawIcon(...arguments);
      }

      moveByJson(settings) {
        var pos;
        pos = KDCore.Utils.getPositionPointFromJSON(settings);
        return this.move(pos.x, pos.y);
      }

      applyTextSettingsByJson(sprite, settings) {
        this.applyTextSettingsByExtraSettings(sprite, settings.text);
      }

      applyTextSettingsByExtraSettings(sprite, s) {
        sprite.move(s.marginX, s.marginY);
        sprite.b().fontSize = s.fontSize;
        sprite.b().textColor = KDCore.Color.FromHex(s.textColor).CSS;
        sprite.b().outlineWidth = s.outlineWidth;
        if (s.outlineColor != null) {
          sprite.b().outlineColor = KDCore.Color.FromHex(s.outlineColor).CSS;
        }
        if (s.fontFace != null) {
          sprite.b().fontFace = s.fontFace;
        }
        sprite.b().fontItalic = s.fontItalic;
        sprite.visible = s.visible;
      }

      isReady() {
        var i, j, ref;
        if (this.bitmap != null) {
          if (!this.bitmap.isReady()) {
            return false;
          }
        }
        for (i = j = 0, ref = this.children.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          if (!this.children[i].bitmap.isReady()) {
            return false;
          }
        }
        return true;
      }

      isCheckAlpha() {
        return false;
      }

      inPosition(point) {
        var e, gx, gy, pixel, result, x, y;
        result = this.isContainsPoint(point);
        if (result && this.isCheckAlpha()) {
          try {
            ({x, y} = point);
            gx = KDCore.SDK.toGlobalCoord(this, 'x');
            gy = KDCore.SDK.toGlobalCoord(this, 'y');
            pixel = this.bitmap.getAlphaPixel(x - gx, y - gy);
            result = pixel > 100;
          } catch (error) {
            e = error;
            KDCore.warning(e);
            result = true; // * ignor Alpha if error
          }
        }
        return result;
      }

      isUnderMouse() {
        return this.inPosition(TouchInput);
      }

      // * Из параметров плагина
      applyFontParam(font) {
        var b;
        if (font == null) {
          return;
        }
        b = this.b();
        if (font.size != null) {
          b.fontSize = font.size;
        }
        if (!String.isNullOrEmpty(font.face)) {
          b.fontFace = font.face;
        }
        if (font.italic != null) {
          b.fontItalic = font.italic;
        }
      }

      applyOutlineParam(outline) {
        var b;
        if (outline == null) {
          return;
        }
        b = this.b();
        if (outline.width != null) {
          b.outlineWidth = outline.width;
        }
        if (!String.isNullOrEmpty(outline.color)) {
          b.outlineColor = outline.color;
        }
      }

      activateHandlerManagment() {
        var e;
        try {
          if (this.pIsFreeKeyboardNavigation()) {
            this.handleUpAction = this.freeSelectUpHandlerItem;
            this.handleDownAction = this.freeSelectDownHandlerItem;
            this.handleRightAction = this.freeSelectRightHandlerItem;
            this.handleLeftAction = this.freeSelectLeftHandlerItem;
          } else {
            this.handleUpAction = this.selectPreviousHandlerItem;
            this.handleDownAction = this.selectNextHandlerItem;
          }
          return this._handleManagerActive = true;
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      deactivateHandlerManagment() {
        var ref;
        this._handleManagerActive = false;
        this.handleUpAction = function() {}; // * EMPTY
        this.handleDownAction = function() {}; // * EMPTY
        this.handleRightAction = function() {}; // * EMPTY
        this.handleLeftAction = function() {}; // * EMPTY
        if ((ref = $gameTemp.__pkdActiveKeyboardHandler) != null) {
          ref.pDeactivateHandler();
        }
        $gameTemp.__pkdActiveKeyboardHandler = null;
      }

      addChild(item) {
        var c, handlers;
        c = super.addChild(...arguments);
        if (item instanceof KDCore.Sprite && (item.pIsSupportKeyboardHandle != null) && item.pIsSupportKeyboardHandle()) {
          handlers = this._pGetAllHandlers();
          item.pHandledIndex = handlers.length - 1;
        }
        return c;
      }

      pIsAnyHandlerSelected() {
        return $gameTemp.__pkdActiveKeyboardHandler != null;
      }

      selectPreviousHandlerItem() {
        var e;
        try {
          if (!this.pIsAnyHandlerSelected()) {
            return this._trySelectHandler(0);
          } else {
            return this._trySelectHandler(this._selectedHandlerIndex() - 1);
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _selectedHandlerIndex() {
        return $gameTemp.__pkdActiveKeyboardHandler.pHandledIndex;
      }

      _trySelectHandler(index) {
        var e, handlerItemToSelect;
        try {
          handlerItemToSelect = this._pGetAllHandlers().find(function(i) {
            return i.pHandledIndex === index;
          });
          if (handlerItemToSelect != null) {
            handlerItemToSelect.pActivateHandler();
          }
          return this._pOnHandled();
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _pGetAllHandlers() {
        return this.children.filter(function(i) {
          return i instanceof KDCore.Sprite && (i.pIsSupportKeyboardHandle != null) && i.pIsSupportKeyboardHandle();
        });
      }

      selectNextHandlerItem() {
        var e;
        try {
          if (!this.pIsAnyHandlerSelected()) {
            return this._trySelectHandler(0);
          } else {
            return this._trySelectHandler(this._selectedHandlerIndex() + 1);
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      activeItemFilterOptions() {
        return {
          distance: 15,
          outerStrength: 4
        };
      }

      pIsHandlerActive() {
        return this._handleManagerActive === true || this._handlerActive === true;
      }

      destroy() {
        if ($gameTemp.__pkdActiveKeyboardHandler === this) {
          $gameTemp.__pkdActiveKeyboardHandler = null;
        }
        return super.destroy();
      }

      _pOnHandled() {
        return Input.clear();
      }

      _pHandleKeyL(ignoreNavigation = false) {
        var e;
        try {
          if (this.pIsVerticalKeyboardNavigation() || ignoreNavigation) {
            if (this.handleLeftAction != null) {
              this.handleLeftAction();
              return this._pOnHandled();
            }
          } else {
            return this._pHandleKeyU(true);
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _pHandleKeyR(ignoreNavigation = false) {
        var e;
        try {
          if (this.pIsVerticalKeyboardNavigation() || ignoreNavigation) {
            if (this.handleRightAction != null) {
              this.handleRightAction();
              return this._pOnHandled();
            }
          } else {
            return this._pHandleKeyD(true);
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _pHandleKeyU(ignoreNavigation = false) {
        var e;
        try {
          if (this.pIsVerticalKeyboardNavigation() || ignoreNavigation) {
            if (this.handleUpAction != null) {
              this.handleUpAction();
              return this._pOnHandled();
            }
          } else {
            return this._pHandleKeyL(true);
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _pHandleKeyD(ignoreNavigation = false) {
        var e;
        try {
          if (this.pIsVerticalKeyboardNavigation() || ignoreNavigation) {
            if (this.handleDownAction != null) {
              this.handleDownAction();
              return this._pOnHandled();
            }
          } else {
            return this._pHandleKeyR(true);
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _pHandleKeyOK() {
        var e;
        try {
          if (this.handleOKAction != null) {
            this.handleOKAction();
            return this._pOnHandled();
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      pActivateHandler() {
        if (!this.pIsSupportKeyboardHandle()) {
          return;
        }
        if (($gameTemp.__pkdActiveKeyboardHandler != null) && $gameTemp.__pkdActiveKeyboardHandler !== this) {
          $gameTemp.__pkdActiveKeyboardHandler.pDeactivateHandler();
        }
        this._handlerActive = true;
        this._activateHandlerVisually();
        $gameTemp.__pkdActiveKeyboardHandler = this;
      }

      _activateHandlerVisually() {
        var e;
        try {
          //@filters = [new PIXI.filters.OutlineFilter(0.8, 0x99ff99, 0.5)]
          //@filters = [new PIXI.filters.GlowFilter(2, 0.8, 0, 0x09f9, 0.5)]
          return this.filters = [new PIXI.filters.GlowFilter(this.activeItemFilterOptions())];
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      pDeactivateHandler() {
        if ($gameTemp.__pkdActiveKeyboardHandler === this) {
          $gameTemp.__pkdActiveKeyboardHandler = null;
        }
        this._handlerActive = false;
        this.filters = [];
      }

      _pHandleKeyboardInputs() {
        var e;
        try {
          if (Input.isTriggered('left')) {
            return this._pHandleKeyL();
          } else if (Input.isTriggered('right')) {
            return this._pHandleKeyR();
          } else if (Input.isTriggered('up')) {
            return this._pHandleKeyU();
          } else if (Input.isTriggered('down')) {
            return this._pHandleKeyD();
          } else if (Input.isTriggered('ok')) {
            return this._pHandleKeyOK();
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      pSelectedHandlerItem() {
        return $gameTemp.__pkdActiveKeyboardHandler;
      }

      freeSelectUpHandlerItem() {
        var allItems, e, item;
        try {
          allItems = this._pGetAllHandlers();
          if (allItems.length === 0) {
            return;
          }
          if (this.pIsAnyHandlerSelected()) {
            item = this._pGetClosestItemToYx(this.pSelectedHandlerItem().x, -this.pSelectedHandlerItem().y, allItems);
            if (item != null) {
              item.pActivateHandler();
            }
          } else {
            allItems[0].pActivateHandler();
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        return this._pOnHandled();
      }

      freeSelectDownHandlerItem() {
        var allItems, e, item;
        try {
          allItems = this._pGetAllHandlers();
          if (allItems.length === 0) {
            return;
          }
          if (this.pIsAnyHandlerSelected()) {
            item = this._pGetClosestItemToYx(this.pSelectedHandlerItem().x, this.pSelectedHandlerItem().y, allItems);
            if (item != null) {
              item.pActivateHandler();
            }
          } else {
            allItems[0].pActivateHandler();
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        return this._pOnHandled();
      }

      freeSelectRightHandlerItem() {
        var allItems, e, item;
        try {
          allItems = this._pGetAllHandlers();
          if (allItems.length === 0) {
            return;
          }
          if (this.pIsAnyHandlerSelected()) {
            // * We should find item by X,Y position
            // * If we search in RIGHT direction, we should find closest item with X > currentX, but on the same Y
            // * If we can't find such item, we should again, but modify Y
            item = this._pGetClosestItemToXy(this.pSelectedHandlerItem().x, this.pSelectedHandlerItem().y, allItems);
            if (item != null) {
              item.pActivateHandler();
            }
          } else {
            allItems[0].pActivateHandler();
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        return this._pOnHandled();
      }

      freeSelectLeftHandlerItem() {
        var allItems, e, item;
        try {
          allItems = this._pGetAllHandlers();
          if (allItems.length === 0) {
            return;
          }
          if (this.pIsAnyHandlerSelected()) {
            item = this._pGetClosestItemToXy(-this.pSelectedHandlerItem().x, this.pSelectedHandlerItem().y, allItems);
            if (item != null) {
              item.pActivateHandler();
            }
          } else {
            allItems[0].pActivateHandler();
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        return this._pOnHandled();
      }

      _pGetClosestItemToXy(x, y, fromItems) {
        var distances, index, item, items, itemsInRow, j, len, rX;
        items = this._pGetItemsByX(x, fromItems);
        if (items.length === 0) {
          return null;
        }
        itemsInRow = items.filter(function(item) {
          return item.y === y;
        });
        if (itemsInRow.length > 0) {
          itemsInRow.sort(function(a, b) {
            return a.x - b.x;
          });
          return itemsInRow[0];
        } else {
          distances = [];
          rX = Math.abs(x);
          for (index = j = 0, len = items.length; j < len; index = ++j) {
            item = items[index];
            distances.push([index, Math.abs(item.x - rX) + Math.abs(item.y - y)]);
          }
          distances.sort(function(a, b) {
            return a[1] - b[1];
          });
          return items[distances[0][0]];
        }
      }

      _pGetItemsByX(x, fromItems) {
        if (x >= 0) {
          return fromItems.filter(function(item) {
            return item.x > x;
          });
        } else {
          return fromItems.filter(function(item) {
            return item.x < Math.abs(x);
          });
        }
      }

      _pGetClosestItemToYx(x, y, fromItems) {
        var distances, index, item, items, itemsInRow, j, len, rY;
        items = this._pGetItemsByY(y, fromItems);
        if (items.length === 0) {
          return null;
        }
        itemsInRow = items.filter(function(item) {
          return item.x === x;
        });
        if (itemsInRow.length > 0) {
          itemsInRow.sort(function(a, b) {
            return a.y - b.y;
          });
          return itemsInRow[0];
        } else {
          distances = [];
          rY = Math.abs(y);
          for (index = j = 0, len = items.length; j < len; index = ++j) {
            item = items[index];
            distances.push([index, Math.abs(item.x - x) + Math.abs(item.y - rY)]);
          }
          distances.sort(function(a, b) {
            return a[1] - b[1];
          });
          return items[distances[0][0]];
        }
      }

      _pGetItemsByY(y, fromItems) {
        if (y >= 0) {
          return fromItems.filter(function(item) {
            return item.y > y;
          });
        } else {
          return fromItems.filter(function(item) {
            return item.y < Math.abs(y);
          });
        }
      }

      _applyRequiredData() {
        var _n, e, func, j, len, ref;
        try {
          if (this._requiredFuncs == null) {
            return;
          }
          ref = this._requiredFuncs;
          for (j = 0, len = ref.length; j < len; j++) {
            func = ref[j];
            try {
              _n = func[0];
              if ((_n != null) && (this[_n] != null)) {
                this[_n](...func[1]);
              }
            } catch (error) {
              e = error;
              KDCore.warning(e);
            }
          }
          return this._requiredFuncs = null;
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _requireFunc(name, args) {
        var e;
        try {
          if (this._requiredFuncs == null) {
            this._requiredFuncs = [];
          }
          return this._requiredFuncs.push([name, args]);
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _addLoadListener(listener) {
        var e;
        try {
          if (this._loadListeners == null) {
            this._loadListeners = [];
          }
          return this._loadListeners.push(listener);
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _executeLoadListeners() {
        var e, j, l, len, ref;
        try {
          if (!this._loadListeners) {
            return;
          }
          ref = this._loadListeners;
          for (j = 0, len = ref.length; j < len; j++) {
            l = ref[j];
            try {
              l();
            } catch (error) {
              e = error;
              KDCore.warning(e);
            }
          }
          return this._loadListeners = null;
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      // * DEVELOPER TOOL ====================================
      _pUpdateDevDrag() {
        if (TouchInput.isLongPressed()) {
          if (this.__ddIn === true) {
            return this._pDD_moving();
          } else {
            if (this.isUnderMouse()) {
              return this._pDD_startMove();
            }
          }
        } else {
          if (this.__ddIn === true) {
            return this._pDD_stopMove();
          }
        }
      }

      _pDD_moving() {
        this.x = TouchInput.x - this._pDDTDelta.x;
        return this.y = TouchInput.y - this._pDDTDelta.y;
      }

      _pDD_startMove() {
        var x, y;
        ({x, y} = TouchInput);
        this._pDDTDelta = {x, y};
        this.__ddIn = true;
      }

      _pDD_stopMove() {
        this.__ddIn = false;
        console.log("DD DRAG POS: ");
        return console.log(this.x, this.y);
      }

      // * STATIC ==================================================
      static WhiteRect(w, h) {
        return KDCore.Sprite.ColorRect(w, h, '#FFF');
      }

      static BlackRect(w, h) {
        return KDCore.Sprite.ColorRect(w, h, '#000');
      }

      static ColorRect(w, h, color) {
        var s;
        s = KDCore.Sprite.FromBitmap(w, h);
        s.b().fillAll(color);
        return s;
      }

      static FromImg(filename, sourceFolder) {
        var s;
        s = new KDCore.Sprite();
        s.bImg(filename, sourceFolder);
        return s;
      }

      static FromBitmap(w, h) {
        var s;
        s = new KDCore.Sprite();
        s.bNew(w, h);
        return s;
      }

      static FromTextSettings(settings) {
        var s;
        s = KDCore.Sprite.FromBitmap(settings.textBoxWidth, settings.textBoxHeight);
        s.applyTextSettingsByExtraSettings(s, settings);
        s.textSettingsPosition = settings.position;
        return s;
      }

      // * Загрузчик из параметров плагина (безопасный)
      static FromParams(pluginParams) {
        var e, h, height, margins, s, size, w, width;
        try {
          size = pluginParams.size;
          ({w, h} = size);
          try {
            if (String.any(w)) {
              if (isFinite(w)) {
                w = Number(w);
              } else {
                w = eval(w);
              }
            }
          } catch (error) {
            e = error;
            KDCore.warning(e);
            w = 100;
          }
          try {
            if (String.any(h)) {
              if (isFinite(h)) {
                h = Number(h);
              } else {
                h = eval(h);
              }
            }
          } catch (error) {
            e = error;
            KDCore.warning(e);
            h = 100;
          }
          ({width, height} = size);
          try {
            if (String.any(width)) {
              if (isFinite(width)) {
                w = Number(width);
              } else {
                w = eval(width);
              }
            }
          } catch (error) {
            e = error;
            KDCore.warning(e);
            w = 100;
          }
          try {
            if (String.any(height)) {
              if (isFinite(height)) {
                h = Number(height);
              } else {
                h = eval(height);
              }
            }
          } catch (error) {
            e = error;
            KDCore.warning(e);
            h = 100;
          }
          s = KDCore.Sprite.FromBitmap(w, h);
          s.textSettingsPosition = pluginParams.alignment;
          margins = pluginParams.margins;
          if (margins != null) {
            s.move(margins.x, margins.y);
          }
          s.applyFontParam(pluginParams.font);
          s.applyOutlineParam(pluginParams.outline);
          if (!String.isNullOrEmpty(pluginParams.textColor)) {
            s.b().textColor = pluginParams.textColor;
          }
          if (pluginParams.visible != null) {
            s.visible = pluginParams.visible;
          }
          return s;
        } catch (error) {
          e = error;
          console.warn('Something wrong with Text Settings!', e);
          return KDCore.Sprite.FromBitmap(60, 30);
        }
      }

    };

    return Sprite;

  }).call(this, Sprite);
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  //@[AUTO EXTEND]
  return KDCore.TimedUpdate = class TimedUpdate {
    constructor(interval, method) {
      this.interval = interval;
      this.method = method;
      this._timer = 0;
      this._once = false;
    }

    setAfter(_repeatsLeft, afterCallback) {
      this._repeatsLeft = _repeatsLeft;
      this.afterCallback = afterCallback;
    }

    update() {
      if (this.interval == null) {
        return;
      }
      if (this._timer++ >= this.interval) {
        this.call();
        this._timer = 0;
        if (this._repeatsLeft != null) {
          this._repeatsLeft -= 1;
          if (this._repeatsLeft <= 0) {
            if (this.afterCallback != null) {
              this.afterCallback();
            }
          }
        }
        if (this._once === true) {
          return this.stop();
        }
      }
    }

    once() {
      return this._once = true;
    }

    onUpdate(method) {
      this.method = method;
    }

    stop() {
      return this.interval = null;
    }

    isAlive() {
      return this.interval != null;
    }

    // * Рандомизировать интервал @interval (-min, +max)
    applyTimeRange(min, max) {
      var value;
      if (!this.isAlive()) {
        return;
      }
      value = KDCore.SDK.rand(min, max);
      return this.interval += value;
    }

    call() {
      var e;
      try {
        if (this.method != null) {
          return this.method();
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  //@[AUTO EXTEND]
  return KDCore.AnimationKeyFrame = class AnimationKeyFrame {
    constructor(startValue, endValue, duration = 1, func = 'linear') {
      this.startValue = startValue;
      this.endValue = endValue;
      this.func = func;
      this._t = 0; // * Timer
      this._d = duration * 60; // * Convert to Frames
      this._c = this.endValue - this.startValue; // * Change
      if (this.func == null) {
        this.func = 'linear';
      }
      return;
    }

    reset() {
      return this._t = 0;
    }

    update() {
      if (this._t < this._d) {
        return this._t += 1;
      }
    }

    isEnd() {
      return this._t >= this._d || this._d <= 0;
    }

    getValue() {
      if (this._d <= 0) {
        return this.endValue;
      } else {
        return this.easingFunc()(this._t, this.startValue, this._c, this._d);
      }
    }

    easingFunc() {
      if ((this.func != null) && (KDCore.EasingFuncs[this.func] != null)) {
        return KDCore.EasingFuncs[this.func];
      } else {
        console.warn("Easing func " + this.func + " not found!");
        return this.linear;
      }
    }

    // * Default one
    linear(t, b, c, d) {
      return c * t / d + b;
    }

  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  //@[AUTO EXTEND]
  return KDCore.AnimationKeyLine = class AnimationKeyLine {
    constructor(keyFramesList, totalDuration = 1, func = 'linear') {
      this.totalDuration = totalDuration;
      this.keyFrames = this._parseKeyFrames(keyFramesList, func);
      this.repeatsLeftBase = 0;
      this.repeatsLeft = 0;
      this.keyIndex = 0;
      this._relativeValue = 0;
      this._isStarted = false;
      return;
    }

    setRelativeValue(_relativeValue) {
      this._relativeValue = _relativeValue;
    }

    setRepeatsCount(repeatsLeftBase) {
      this.repeatsLeftBase = repeatsLeftBase;
      return this.repeatsLeft = this.repeatsLeftBase;
    }

    setLoop() {
      return this.setRepeatsCount(-1);
    }

    start(startDelay = 0) {
      this.startDelay = startDelay;
      if (this.startDelay === 0) {
        return this._isStarted = true;
      } else {
        return this._startTimer = this.startDelay * 60;
      }
    }

    pause() {
      this._isStarted = false;
      this._startTimer = null;
    }

    isStarted() {
      return this._isStarted === true;
    }

    complete() {
      this.keyIndex = this.keyFrames.length;
      this.repeatsLeft = 0;
    }

    reset() {
      this.repeatsLeft = this.repeatsLeftBase;
      this._resetKeyframes();
    }

    update() {
      if (this._startTimer != null) {
        this._updateStartTimer();
      }
      if (!this.isStarted()) {
        return;
      }
      if (this.isEnd()) {
        if (this.repeatsLeft === 0) { // * No repeats at all
          return;
        } else if (this.repeatsLeft < 0) { // * Infinite Loop
          this._resetKeyframes();
        } else {
          this.repeatsLeft -= 1;
          this._resetKeyframes();
        }
      }
      this.keyFrames[this.keyIndex].update();
      if (this.keyFrames[this.keyIndex].isEnd()) {
        //console.log("NEXT")
        this.keyIndex++;
      }
    }

    isEnd() {
      return this.keyIndex > this.keyFrames.length - 1;
    }

    getValue() {
      var value;
      if (this.isEnd()) {
        value = this.keyFrames.last().getValue();
      } else {
        value = this.keyFrames[this.keyIndex].getValue();
      }
      return value + this._relativeValue;
    }

    _parseKeyFrames(keyframes, func) {
      var duration, e, endValue, endValues, index, key, keyframesOutput, keys, kf, prevKey, startValue, value;
      try {
        keyframesOutput = [];
        endValues = [];
        keys = [];
        index = 0;
        for (key in keyframes) {
          value = keyframes[key];
          if (endValues.length > 0) {
            startValue = endValues[index - 1];
          } else {
            startValue = 0;
          }
          value = KDCore.Utils.getValueWithDP(value);
          endValue = value;
          if (key === "0") {
            duration = 0;
          } else {
            prevKey = keys[index - 1];
            duration = this._calculateDuration(prevKey, key);
          }
          kf = new KDCore.AnimationKeyFrame(startValue, endValue, duration, func);
          keys[index] = key;
          endValues[index] = value;
          keyframesOutput.push(kf);
          index++;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return keyframesOutput;
    }

    _calculateDuration(rateA, rateB) {
      var d, e, timeA, timeB;
      try {
        rateA = Number(rateA) / 100.0;
        rateB = Number(rateB) / 100.0;
        timeA = this.totalDuration * rateA;
        timeB = this.totalDuration * rateB;
        d = timeB - timeA;
        return d;
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return 0;
    }

    _resetKeyframes() {
      var e, f, i, len, ref, results;
      try {
        this.keyIndex = 0;
        ref = this.keyFrames;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          f = ref[i];
          results.push(f.reset());
        }
        return results;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _updateStartTimer() {
      var e;
      try {
        if (this._startTimer == null) {
          return;
        }
        this._startTimer -= 1;
        if (this._startTimer <= 0) {
          this._isStarted = true;
          return this._startTimer = null;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  //@[AUTO EXTEND]
  return KDCore.AnimationRule = class AnimationRule {
    constructor(animationConfig, obj) {
      var condition, delay, duration, func, keyframes, repeats;
      if (typeof animationConfig === "string") {
        animationConfig = KDCore.UI.Builder.ConvertShortcut(animationConfig);
      }
      this.animationConfig = Object.assign(this.defaultConfig(), animationConfig);
      ({condition} = this.animationConfig);
      if (String.any(condition)) {
        if (eval(condition) === false) {
          return;
        }
      }
      ({keyframes, duration, func, repeats, delay} = this.animationConfig);
      this.prepareKeyFrames(keyframes, obj);
      this.keyLine = new KDCore.AnimationKeyLine(keyframes, duration, func);
      if (repeats == null) {
        repeats = 0;
      }
      this.keyLine.setRepeatsCount(repeats);
      if ((obj != null) && this.animationConfig.field === "_scaleFactor") {
        this.prepareObject(obj);
      }
      if (this.animationConfig.relative === true && (obj != null)) {
        this.keyLine.setRelativeValue(obj[this.animationConfig.field]);
      }
      this.keyLine.start(delay);
      if ((obj != null) && delay <= 0) {
        this.applyAnimation(obj);
      }
      return;
    }

    prepareKeyFrames(keyframes, obj) {
      var key, value;
      for (key in keyframes) {
        value = keyframes[key];
        if (value === "@") {
          if ((obj != null) && (obj[this.animationConfig.field] != null)) {
            keyframes[key] = obj[this.animationConfig.field];
          } else {
            keyframes[key] = 0;
          }
        }
      }
    }

    setEndCallback(onEndCallback) {
      this.onEndCallback = onEndCallback;
    }

    isHaveEndCallback() {
      var e;
      try {
        if (this.animationConfig.repeats !== 0) {
          // * Callback works only for single-shot animations
          return false;
        }
        return this.onEndCallback != null;
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return false;
    }

    defaultConfig() {
      return {
        field: "opacity",
        duration: 1,
        func: "linear",
        delay: 0,
        repeats: 0,
        relative: false,
        keyframes: {
          "0": 0,
          "100": 255
        },
        condition: null
      };
    }

    update() {
      var e;
      if (this.keyLine == null) {
        return;
      }
      this.keyLine.update();
      if (this.isHaveEndCallback()) {
        if (this.keyLine.isEnd()) {
          try {
            this.onEndCallback();
          } catch (error) {
            e = error;
            KDCore.warning(e);
          }
          this.onEndCallback = null;
        }
      }
    }

    applyAnimation(obj) {
      var e;
      try {
        if (obj == null) {
          return;
        }
        if (this.keyLine == null) {
          return;
        }
        return obj[this.animationConfig.field] = this.keyLine.getValue();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    prepareObject(obj) {
      var e;
      try {
        if ((obj != null) && (obj.onBeforeChangeScaleFactor != null)) {
          return obj.onBeforeChangeScaleFactor();
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  
    // * Button (Sprite_XButton)

    //@[AUTO EXTEND]
  //?DEPRECATED
  return KDCore.Button = class Button extends Sprite {
    constructor() {
      super();
      this._mouseIn = false;
      this._touching = false;
      this._slowUpdateActive = false;
      this._localMode = false;
      this._images = [];
      this._checkAlpha = false;
      this._textSprite = null;
      this._textPosition = 0;
      this._override = false; // * TouchClick in game messages not work anymore if TRUE
      this._clickHandlers = [];
      this._manualHided = false;
      this._manualDisabled = false;
      this._condition = null; // * Условие для Visible
      this._condition2 = null; // * Условие для Enable \ Disable
      this._disabled = false;
      this._infoData = null;
      this._isNeedShowText = false;
      return;
    }

    isMouseInButton() {
      return this._mouseIn === true;
    }

    isActive() {
      return this.visible === true;
    }

    activateSlowUpdate() {
      return this._slowUpdateActive = true;
    }

    setLocalMode() {
      this._realX = this.x;
      this._realY = this.y;
      return this._localMode = true;
    }

    setAlphaMode() {
      return this._checkAlpha = true;
    }

    // * above, below
    setTextPosition(position) {
      return this._textPosition = position;
    }

    setHelpText(text, size) {
      return this._createText(text, size);
    }

    setInfoData(data) {
      return this._infoData = data;
    }

    setOverrideMode() {
      return this._override = true;
    }

    isOverride() {
      return this._override === true && this.isActive() && this.touchInButton();
    }

    isDisabled() {
      return this._disabled === true;
    }

    isEnabled() {
      return !this.isDisabled();
    }

    isNeedShowText() {
      return this._isNeedShowText === true;
    }

    addClickHandler(method) {
      return this._clickHandlers.push(method);
    }

    clearClickHandlers() {
      return this._clickHandlers = [];
    }

    isLocalMode() {
      return this._localMode === true;
    }

    setCondition(method) {
      return this._condition = method;
    }

    setConditionForDisable(method) {
      return this._condition2 = method;
    }

    getInfoData() {
      return this._infoData;
    }

    simulateClick() { //?NEW
      return this.applyClickedState();
    }

    simulateClickManual() { //?NEW
      this.simulateClick();
      return setTimeout((() => {
        try {
          return this.applyNormalState();
        } catch (error) {

        }
      }), 50);
    }

    prepare() { //?NEW
      return this.slowUpdate();
    }

    realX() {
      if (this.isLocalMode()) {
        return this._realX;
      } else {
        return this.x;
      }
    }

    realY() {
      if (this.isLocalMode()) {
        return this._realY;
      } else {
        return this.y;
      }
    }

    show() {
      this.visible = true;
      return this._manualHided = false;
    }

    hide() {
      this.visible = false;
      return this._manualHided = true;
    }

    disable() {
      this._disabled = true;
      this._manualDisabled = true;
      this.refreshEnDisState();
      return this._mouseIn = false;
    }

    enable() {
      this._disabled = false;
      this._manualDisabled = false;
      return this.refreshEnDisState();
    }

    update() {
      super.update();
      if (this._destroyed === true) {
        return;
      }
      this.updateMouseClick();
      this.updatePosition();
      if (!this._slowUpdateActive) {
        this.slowUpdate();
      }
      return this.updateComplexTextVisible();
    }

    slowUpdate() {
      if (this._destroyed === true) {
        return;
      }
      this.updateMouseTracking();
      this.updateConditionForVisible();
      return this.updateConditionForEnabling();
    }

    updateMouseTracking() {
      if (!this.isActive()) {
        return;
      }
      if (this.isDisabled()) {
        return;
      }
      if (this.cursorInButton()) {
        this._onMouseEnter();
        return this._mouseIn = true;
      } else {
        this._onMouseLeave();
        return this._mouseIn = false;
      }
    }

    // * In MZ TouchInput always have X,Y
    cursorInButton() {
      return this.touchInButton();
    }

    xyInButton(x, y) {
      var inRect, rect, rx, ry;
      rx = KDCore.SDK.toGlobalCoord(this, 'x');
      ry = KDCore.SDK.toGlobalCoord(this, 'y');
      rect = new PIXI.Rectangle(rx, ry, this._realWidth(), this._realHeight());
      inRect = rect.contains(x, y);
      if (inRect === true && this._checkAlpha === true) {
        return this._checkAlphaPixel(x - rx, y - ry);
      } else {
        return inRect;
      }
    }

    _realWidth() {
      if (this._hasImage()) {
        return this._mainImage().width;
      } else {
        return this.width;
      }
    }

    _hasImage() {
      return this._mainImage() != null;
    }

    _mainImage() {
      return this._images[0];
    }

    _realHeight() {
      if (this._hasImage()) {
        return this._mainImage().height;
      } else {
        return this.height;
      }
    }

    _checkAlphaPixel(x, y) {
      var pixel;
      pixel = this._hasImage() ? this._mainImage().bitmap.getAlphaPixel(x, y) : this.bitmap.getAlphaPixel(x, y);
      return pixel >= 200;
    }

    _onMouseEnter() {
      if (this._mouseIn === true) {
        return;
      }
      if (!this.isDisabled()) {
        this.applyCoverState();
      }
      this._showText();
      if (this.getInfoData() != null) {
        return this._startComplexTimer();
      }
    }

    _onMouseLeave() {
      if (this._mouseIn === false) {
        return;
      }
      if (!this.isDisabled()) {
        this.applyNormalState();
      }
      this._hideText();
      return this._stopComplexTimer();
    }

    _showText() {
      if (this._textSprite == null) {
        return;
      }
      this._updateTextPosition();
      return this._textSprite.visible = true;
    }

    _hideText() {
      if (this._textSprite == null) {
        return;
      }
      return this._textSprite.visible = false;
    }

    _startComplexTimer() {
      this._stopComplexTimer();
      return this._cTimer = setTimeout((() => {
        if (this._mouseIn === true) {
          return this._isNeedShowText = true;
        }
      }), 1000);
    }

    _stopComplexTimer() {
      if (this._cTimer != null) {
        clearTimeout(this._cTimer);
      }
      return this._isNeedShowText = false;
    }

    updateMouseClick() {
      if (!this.isActive()) {
        this._unTouch();
        return;
      }
      if (this.isDisabled()) {
        return;
      }
      if (TouchInput.isTriggered() && this.touchInButton()) {
        this._touching = true;
        this.applyClickedState();
      }
      if (this._touching === true) {
        if (TouchInput.isReleased() || !this.touchInButton()) {
          this._unTouch();
          if (TouchInput.isReleased()) {
            return this.callClickHandler();
          }
        }
      }
    }

    _unTouch() {
      this._touching = false;
      if (this.touchInButton()) {
        return this.applyCoverState();
      } else {
        return this.applyNormalState();
      }
    }

    touchInButton() {
      return this.xyInButton(TouchInput.x, TouchInput.y);
    }

    callClickHandler() {
      if (this._clickHandlers.length > 0) {
        return this._clickHandlers.forEach(function(method) {
          return method();
        });
      }
    }

    updatePosition() {
      var p;
      if (!this._localMode) {
        return;
      }
      p = new KDCore.Point(this._realX, this._realY);
      return this.move(p.screenX(), p.screenY());
    }

    updateConditionForVisible() {
      var result;
      if (this._condition == null) {
        return;
      }
      if (this._manualHided === true) {
        return;
      }
      try {
        result = this._condition();
        return this.visible = !result;
      } catch (error) {
        console.warn('wrong condition in button');
        return this.visible = true;
      }
    }

    updateConditionForEnabling() {
      if (!this._condition2) {
        return;
      }
      if (this._manualDisabled === true) {
        return;
      }
      try {
        this._disabled = this._condition2();
        return this.refreshEnDisState();
      } catch (error) {
        console.warn('wrong condition in button for enable state');
        return this.disable();
      }
    }

    setButtonImages(img1, img2, img3, img4) {
      if (this._images != null) {
        this._images.forEach(function(img) {
          if (img != null) {
            return img.parent.removeChild(img);
          }
        });
      }
      this._images = [new Sprite(img1), img2 != null ? new Sprite(img2) : void 0, img3 != null ? new Sprite(img3) : void 0, img4 != null ? new Sprite(img4) : void 0];
      this._images.forEach((img) => {
        if (img != null) {
          return this.addChild(img);
        }
      });
      return this.applyNormalState();
    }

    applyNormalState() {
      var ref;
      this.refreshImages();
      return (ref = this._images[0]) != null ? ref.visible = true : void 0;
    }

    refreshImages() {
      return this._images.forEach(function(img) {
        return img != null ? img.visible = false : void 0;
      });
    }

    applyCoverState() {
      this.refreshImages();
      if (this._images[1] != null) {
        return this._images[1].visible = true;
      } else {
        return this.applyNormalState();
      }
    }

    applyClickedState() {
      this.refreshImages();
      if (this._images[2] != null) {
        return this._images[2].visible = true;
      } else {
        return this.applyNormalState();
      }
    }

    _createText(text, size) {
      var h, w;
      if (this._textSprite) {
        this.removeChild(this._textSprite);
      }
      w = Math.round(((size / 10) + 1) * 5 * text.length);
      h = size + 4;
      this._textSprite = new Sprite(new Bitmap(w, h));
      this._textSprite.bitmap.fontSize = size;
      this._textSprite.bitmap.drawText(text, 0, h / 2, w, 1, 'center');
      this._textSprite.visible = false;
      return this.addChild(this._textSprite);
    }

    _updateTextPosition() {
      var nx, ny;
      if (!this._textSprite) {
        return;
      }
      nx = this._realWidth() / 2 - this._textSprite.width / 2;
      if (this._textPosition === 0) {
        ny = -this._textSprite.height;
      } else {
        ny = this._realHeight() + this._textSprite.height / 2;
      }
      return this._textSprite.move(nx, ny);
    }

    applyDisableState() {
      var ref;
      this.refreshImages();
      return (ref = this._images[3]) != null ? ref.visible = true : void 0;
    }

    refreshEnDisState() {
      if (this.isDisabled()) {
        this.applyDisableState();
        return this._hideText();
      } else {
        if (this._mouseIn === false) {
          return this.applyNormalState();
        }
      }
    }

    //else
    //    do @applyCoverState
    updateComplexTextVisible() {}

    applyScale(mod) {
      var i, img, len, ref;
      ref = this._images;
      for (i = 0, len = ref.length; i < len; i++) {
        img = ref[i];
        if (img != null) {
          img.scale.x = mod;
          img.scale.y = mod;
        }
      }
    }

    static FromSet(imgName, sourceFolder = null) {
      var button, getterFunc, img0, img1;
      getterFunc = function(filename) {
        return ImageManager.loadPicture(filename);
      };
      if (sourceFolder != null) {
        getterFunc = function(filename) {
          return ImageManager.loadBitmap("img/" + sourceFolder + "/", filename);
        };
      }
      img0 = getterFunc(imgName + "_00");
      img1 = getterFunc(imgName + "_01");
      button = new KDCore.Button();
      button.setButtonImages(img0, img1, img0, img0);
      return button;
    }

    static FromSetFull(imgName, sourceFolder = null) {
      var button, getterFunc, img0, img1, img2, img3;
      getterFunc = function(filename) {
        return ImageManager.loadPicture(filename);
      };
      if (sourceFolder != null) {
        getterFunc = function(filename) {
          return ImageManager.loadBitmap("img/" + sourceFolder + "/", filename);
        };
      }
      img0 = getterFunc(imgName + "_00");
      img1 = getterFunc(imgName + "_01");
      img2 = getterFunc(imgName + "_02");
      img3 = getterFunc(imgName + "_03");
      button = new KDCore.Button();
      button.setButtonImages(img0, img1, img2, img3);
      return button;
    }

  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_ActorFace;
  //NUI 1.2
  //rev 18.08.24

    //"type": "face"
  Sprite_ActorFace = class Sprite_ActorFace extends KDCore.Sprite {
    constructor(settings) {
      super();
      this.settings = Object.assign({}, this.defaultSettings(), settings);
      this._create();
      this.draw(this.settings.faceName, this.settings.faceIndex);
      this.flipX(this.settings.mirror);
      return;
    }

    isLoaded() {
      return true;
    }

    defaultSettings() {
      return {
        faceName: "",
        faceIndex: 0,
        size: 144,
        mirror: false
      };
    }

    realWidth() {
      if (this.isNotHaveBounds()) {
        return 0;
      }
      return this.settings.size;
    }

    realHeight() {
      if (this.isNotHaveBounds()) {
        return 0;
      }
      return this.settings.size;
    }

    dataBindings() {
      return Object.assign(super.dataBindings(), {
        size: function(v) {
          return this.setSize(v);
        },
        faceName: function(v) {
          return this.draw(v, this.settings.faceIndex);
        },
        faceIndex: function(v) {
          return this.draw(this.settings.faceName, v);
        },
        mirror: function(v) {
          return this.flipX(v);
        }
      });
    }

    setSize(size = 144) {
      var e;
      try {
        size = this._getValueByStr(size, 'width', this);
        if (size != null) {
          this.settings.size = size;
        }
        return this._onResize();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    draw(faceName = "", faceIndex = 0) {
      var e;
      try {
        this.settings.faceName = faceName;
        this.settings.faceIndex = faceIndex;
        if (faceName === "") {
          this.image.bitmap.clear();
          return;
        }
        return this._drawFaceImage(faceName);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    flipX(isMirror) {
      var e;
      try {
        if (isMirror) {
          this.image.scale.x = -1;
          return this.image.x = this.settings.size;
        } else {
          this.image.scale.x = 1;
          return this.image.x = 0;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _create() {
      var e;
      try {
        this.image = new KDCore.Sprite(new Bitmap(1, 1));
        return this.addChild(this.image);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawFaceImage(faceName) {
      var e;
      try {
        this._srcBitmap = ImageManager.loadFace(faceName);
        return this._srcBitmap.addLoadListener(this._onBitmapLoaded.bind(this));
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onBitmapLoaded() {
      var e;
      try {
        this._onResize();
        this._applyRequiredData();
        return this._executeLoadListeners();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onResize() {
      var b, e, fh, fw, size, sx, sy;
      try {
        this.image.bitmap = new Bitmap(this.realWidth(), this.realHeight());
        if (this._srcBitmap == null) {
          return;
        }
        b = this._srcBitmap;
        if (KDCore.isMZ()) {
          fw = ImageManager.faceWidth;
          fh = ImageManager.faceHeight;
        } else {
          fw = Window_Base._faceWidth;
          fh = Window_Base._faceHeight;
        }
        size = this.settings.size;
        sx = (this.settings.faceIndex % 4) * fw;
        sy = Math.floor(this.settings.faceIndex / 4) * fh;
        this.image.bitmap.blt(b, sx, sy, fw, fh, 0, 0, size, size);
        this.setFrame(0, 0, size, size);
        return this.flipX(this.settings.mirror);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
  return KDCore.Sprite_ActorFace = Sprite_ActorFace;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_BaseCircle;
  //NUI 1.0
  //rev 28.04.24

    //"type": "circle"
  Sprite_BaseCircle = class Sprite_BaseCircle extends KDCore.Sprite {
    constructor(settings) {
      super();
      this.settings = Object.assign({}, this.defaultSettings(), settings);
      this._create();
      this._applySettings();
      this._onResize();
      return;
    }

    defaultSettings() {
      return {
        width: 100,
        height: 100,
        fillGradient: null, // { gradient stops }
        gradientStart: {
          x: 0,
          y: 100,
          r: 30
        },
        gradientEnd: {
          x: 100,
          y: 100,
          r: 70
        },
        fillColor: 0xffffff,
        fillAlpha: 1,
        strokeWidth: 4,
        strokeColor: 0x000000,
        strokeAlpha: 1
      };
    }

    defaultGradientSettings() {
      return {
        "0": "#9ff",
        "1": "#033"
      };
    }

    isHaveGradient() {
      return false; //@settings.fillGradient?
    }

    dataBindings() {
      return Object.assign(super.dataBindings(), {
        width: function(v) {
          if (v != null) {
            return this.setSize(v, this.settings.height);
          }
        },
        height: function(v) {
          if (v != null) {
            return this.setSize(this.settings.width, v);
          }
        },
        size: function(v) {
          if (v != null) {
            return this.setSize(v.width, v.height);
          }
        },
        stroke: function(v) {
          if (v != null) {
            return this.setStroke(v.width, v.color, v.alpha);
          }
        },
        fill: function(v) {
          if (v != null) {
            return this.setFill(v.color, v.alpha);
          }
        }
      });
    }

    setFill(color = "#FFF", alpha = 1) {
      var e;
      try {
        this.settings.fillColor = color;
        this.settings.fillAlpha = alpha;
        this.settings.fillGradient = null;
        return this._applySettings();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setStroke(color = "#FFF", width = 0, alpha = 1) {
      var e;
      try {
        this.settings.strokeColor = color;
        this.settings.strokeAlpha = alpha;
        this.settings.strokeWidth = width;
        return this._applySettings();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setSize(width = 100, height = 100) {
      var e, h, w;
      try {
        w = this._getValueByStr(width, 'width', this);
        h = this._getValueByStr(height, 'height', this);
        if (w != null) {
          this.settings.width = w;
        }
        if (h != null) {
          this.settings.height = h;
        }
        this._applySettings();
        return this._onResize();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _create() {
      var e;
      try {
        this.graphics = new PIXI.Graphics();
        return this.addChild(this.graphics);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _applySettings() {
      var e, gradientSettings;
      try {
        if (this.graphics == null) {
          return;
        }
        this.graphics.clear();
        if (this.settings.fillGradient != null) {
          gradientSettings = Object.assign(this.defaultGradientSettings(), this.settings.fillGradient);
        }
        this._applyGradientTexture(gradientSettings);
        return this._drawBaseCircle();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _applyGradientTexture(fillGradient) {
      var e;
      try {

      } catch (error) {
        /*{ width, height } = @settings
        c = document.createElement("canvas")
        ctx = c.getContext("2d")*/
        /*grd = ctx.createRadialGradient(
            @settings.gradientStart.x,
            @settings.gradientStart.y,
            @settings.gradientStart.r,
            @settings.gradientEnd.x,
            @settings.gradientEnd.y,
            @settings.gradientEnd.r
        )*/
        //grd = ctx.createRadialGradient(110, 90, 30, 100, 100, 70)
        /*for key, value of fillGradient
        try
            grd.addColorStop(Number(key), value)
        catch e
            KDCore.warning e*/
        /*grd.addColorStop(0, "pink")
        grd.addColorStop(0.9, "white")
        grd.addColorStop(1, "green")

        ctx.fillStyle = grd
        ctx.fillRect(0, 0, 400, 400)
        texture = new PIXI.Texture.from(c)
        @graphics.beginTextureFill(texture)*/
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawBaseCircle() {
      var colorData, d, e, fillAlpha, fillColor, height, strokeAlpha, strokeColor, strokeColorData, width;
      try {
        ({width, height} = this.settings);
        ({fillColor, fillAlpha} = this.settings);
        colorData = this._buildColorData(fillColor, fillAlpha);
        if (this.settings.strokeWidth > 0) {
          ({strokeColor, strokeAlpha} = this.settings);
          strokeColorData = this._buildColorData(strokeColor, strokeAlpha);
          d = this.settings.strokeWidth;
          // * Base Fill
          this._drawElipse(0, 0, width, height, colorData);
          // * Stroke
          return this._drawStroke(0, 0, width, height, d, strokeColorData);
        } else {
          // * Base Fill only
          return this._drawElipse(0, 0, width, height, colorData);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _buildColorData(c = 0xfff, a = 1) {
      var e;
      try {
        if (typeof c === 'string') {
          c = KDCore.Utils.string2hex(c);
        }
        return [c, a];
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return [0xfff, 1];
      }
    }

    _drawElipse(x, y, w, h, colorData) {
      var e, g;
      try {
        if (this.graphics == null) {
          return;
        }
        g = this.graphics;
        if (!this.isHaveGradient()) {
          g.beginFill(...colorData);
        }
        g.drawEllipse(x, y, w / 2, h / 2);
        if (!this.isHaveGradient()) {
          return g.endFill();
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawStroke(x, y, w, h, d, colorData) {
      var e, g;
      try {
        if (this.graphics == null) {
          return;
        }
        g = this.graphics;
        g.lineStyle(d, ...colorData);
        return g.drawEllipse(x, y, w / 2, h / 2);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onResize() {
      var e;
      try {
        this.width = this.settings.width;
        this.height = this.settings.height;
        // * Круг (элипс) рисуется от центра, что не удобно
        // при расчёте координат, поэтому сдвигаем в левый вверхний угол
        this.graphics.x = this.settings.width * 0.5;
        return this.graphics.y = this.settings.height * 0.5;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
  return KDCore.Sprite_BaseCircle = Sprite_BaseCircle;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_BaseRect;
  //NUI 1.0
  //rev 28.04.24

    //"type": "rect"
  Sprite_BaseRect = class Sprite_BaseRect extends KDCore.Sprite {
    constructor(settings) {
      super();
      this.settings = Object.assign({}, this.defaultSettings(), settings);
      this._create();
      this._applySettings();
      this._onResize();
      return;
    }

    defaultSettings() {
      return {
        width: 100,
        height: 100,
        corners: 0, // {  topLeft, topRight, bottomRight, bottomLeft }
        fillGradient: null, // { gradient stops }
        gradientStart: {
          x: 0,
          y: 0
        },
        gradientEnd: {
          x: 0,
          y: 100
        },
        fillColor: 0xffffff,
        fillAlpha: 1,
        strokeWidth: 4,
        strokeColor: 0x000000,
        strokeAlpha: 1
      };
    }

    defaultGradientSettings() {
      return {
        "0": "#9ff",
        "1": "#033"
      };
    }

    defaultCornersSettings() {
      return {
        topLeft: 0,
        topRight: 0,
        bottomRight: 0,
        bottomLeft: 0
      };
    }

    isHaveGradient() {
      return this.settings.fillGradient != null;
    }

    dataBindings() {
      return Object.assign(super.dataBindings(), {
        width: function(v) {
          if (v != null) {
            return this.setSize(v, this.settings.height);
          }
        },
        height: function(v) {
          if (v != null) {
            return this.setSize(this.settings.width, v);
          }
        },
        size: function(v) {
          if (v != null) {
            return this.setSize(v.width, v.height);
          }
        },
        stroke: function(v) {
          if (v != null) {
            return this.setStroke(v.width, v.color, v.alpha);
          }
        },
        fill: function(v) {
          if (v != null) {
            return this.setFill(v.color, v.alpha);
          }
        },
        gradientStart: function(v) {
          if (v != null) {
            return this.setGradientStartEnd(v, this.settings.gradientEnd);
          }
        },
        gradientEnd: function(v) {
          if (v != null) {
            return this.setGradientStartEnd(this.settings.gradientStart, v);
          }
        }
      });
    }

    setGradientStartEnd(start, end) {
      var e;
      try {
        if (start != null) {
          start.x = this._getValueByStr(start.x, 'width', this);
          start.y = this._getValueByStr(start.y, 'height', this);
        }
        if (end != null) {
          end.x = this._getValueByStr(end.x, 'width', this);
          end.y = this._getValueByStr(end.y, 'height', this);
        }
        if (start != null) {
          this.settings.gradientStart = start;
        }
        if (end != null) {
          this.settings.gradientEnd = end;
        }
        return this._applySettings();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setFill(color = "#FFF", alpha = 1) {
      var e;
      try {
        this.settings.fillColor = color;
        this.settings.fillAlpha = alpha;
        this.settings.fillGradient = null;
        return this._applySettings();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setStroke(color = "#FFF", width = 0, alpha = 1) {
      var e;
      try {
        this.settings.strokeColor = color;
        this.settings.strokeAlpha = alpha;
        this.settings.strokeWidth = width;
        return this._applySettings();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setSize(width = 100, height = 100) {
      var e, h, w;
      try {
        w = this._getValueByStr(width, 'width', this);
        h = this._getValueByStr(height, 'height', this);
        if (w != null) {
          this.settings.width = w;
        }
        if (h != null) {
          this.settings.height = h;
        }
        this._applySettings();
        return this._onResize();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _create() {
      var e;
      try {
        this.graphics = new PIXI.Graphics();
        return this.addChild(this.graphics);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _applySettings() {
      var cornersSettings, e, gradientSettings;
      try {
        if (this.graphics == null) {
          return;
        }
        this.graphics.clear();
        if (this.settings.fillGradient != null) {
          gradientSettings = Object.assign(this.defaultGradientSettings(), this.settings.fillGradient);
        }
        this._applyGradientTexture(gradientSettings);
        if (typeof this.settings.corners === "number") {
          return this._drawBaseRoundedRect();
        } else if (this.settings.corners != null) {
          cornersSettings = Object.assign(this.defaultCornersSettings(), this.settings.corners);
          return this._drawComplexRoundedRect(cornersSettings);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _applyGradientTexture(fillGradient) {
      var c, convertedValue, ctx, e, grd, height, key, texture, value, width;
      try {
        if (KDCore.isMV()) {
          return;
        }
        ({width, height} = this.settings);
        c = document.createElement("canvas");
        ctx = c.getContext("2d");
        grd = ctx.createLinearGradient(this.settings.gradientStart.x, this.settings.gradientStart.y, this.settings.gradientEnd.x, this.settings.gradientEnd.y);
        for (key in fillGradient) {
          value = fillGradient[key];
          try {
            convertedValue = this._convertGradientStopColor(value);
            grd.addColorStop(Number(key), convertedValue);
          } catch (error) {
            e = error;
            KDCore.warning(e);
          }
        }
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, width, height);
        texture = new PIXI.Texture.from(c);
        return this.graphics.beginTextureFill(texture);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _convertGradientStopColor(color) {
      var alpha, c, e, parts;
      try {
        if (color == null) {
          return "#FFF";
        }
        if (!String.any(color)) {
          return "#FFF";
        }
        if (color.contains("%")) {
          parts = color.split("%");
          color = parts[0];
          alpha = Number(parts[1]);
          c = KDCore.Color.FromHex(color);
          c = c.reAlpha(alpha * 255);
          return c.CSS;
        } else {
          return color;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return "#FFF";
      }
    }

    _drawBaseRoundedRect() {
      var colorData, corners, d, e, fillAlpha, fillColor, height, strokeAlpha, strokeColor, strokeColorData, width;
      try {
        ({width, height, corners} = this.settings);
        ({fillColor, fillAlpha} = this.settings);
        colorData = this._buildColorData(fillColor, fillAlpha);
        if (this.settings.strokeWidth > 0) {
          ({strokeColor, strokeAlpha} = this.settings);
          strokeColorData = this._buildColorData(strokeColor, strokeAlpha);
          d = this.settings.strokeWidth;
          // * Base Fill
          this._drawRect(0, 0, width, height, corners, colorData);
          // * Stroke
          return this._drawStroke(-d / 2, -d / 2, width + d / 2, height + d / 2, corners, d, strokeColorData);
        } else {
          // * Base Fill only
          return this._drawRect(0, 0, width, height, corners, colorData);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _buildColorData(c = 0xfff, a = 1) {
      var e;
      try {
        if (typeof c === 'string') {
          c = KDCore.Utils.string2hex(c);
        }
        return [c, a];
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return [0xfff, 1];
      }
    }

    _drawRect(x, y, w, h, r, colorData) {
      var e, g;
      try {
        if (this.graphics == null) {
          return;
        }
        g = this.graphics;
        if (!this.isHaveGradient()) {
          g.beginFill(...colorData);
        }
        if (r > 0) {
          g.drawRoundedRect(x, y, w, h, r);
        } else {
          g.drawRect(x, y, w, h);
        }
        if (!this.isHaveGradient()) {
          return g.endFill();
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawStroke(x, y, w, h, r, d, colorData) {
      var e, g;
      try {
        if (this.graphics == null) {
          return;
        }
        g = this.graphics;
        g.lineStyle(d, ...colorData);
        if (r > 0) {
          return g.drawRoundedRect(x, y, w, h, r);
        } else {
          return g.drawRect(x, y, w, h);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawComplexRoundedRect(cornersSettings) {
      var bottomLeft, bottomRight, colorData, d, e, fillAlpha, fillColor, height, strokeAlpha, strokeColor, strokeColorData, topLeft, topRight, width;
      try {
        if (cornersSettings == null) {
          return;
        }
        ({width, height} = this.settings);
        ({fillColor, fillAlpha} = this.settings);
        colorData = this._buildColorData(fillColor, fillAlpha);
        ({topLeft, topRight, bottomRight, bottomLeft} = cornersSettings);
        if (this.settings.strokeWidth > 0) {
          ({strokeColor, strokeAlpha} = this.settings);
          strokeColorData = this._buildColorData(strokeColor, strokeAlpha);
          d = this.settings.strokeWidth;
          this._drawComplexRect(0, 0, width, height, colorData, topLeft, topRight, bottomRight, bottomLeft);
          return this._drawComplexStroke(-d / 2, -d / 2, width + (d / 2), height + (d / 2), strokeColorData, d, topLeft, topRight, bottomRight, bottomLeft);
        } else {
          return this._drawComplexRect(0, 0, width, height, colorData, topLeft, topRight, bottomRight, bottomLeft);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawComplexRect(x, y, width, height, colorData, topLeftRadius, topRightRadius, bottomRightRadius, bottomLeftRadius) {
      var e;
      try {
        if (!this.isHaveGradient()) {
          this.graphics.beginFill(...colorData);
        }
        // Starting from the top left corner.
        this.graphics.moveTo(x + topLeftRadius, y);
        // Drawing the top line with top right corner.
        this.graphics.lineTo(x + width - topRightRadius, y);
        if (topRightRadius > 0) {
          this.graphics.quadraticCurveTo(x + width, y, x + width, y + topRightRadius);
        }
        // Drawing the right line with bottom right corner.
        this.graphics.lineTo(x + width, y + height - bottomRightRadius);
        if (bottomRightRadius > 0) {
          this.graphics.quadraticCurveTo(x + width, y + height, x + width - bottomRightRadius, y + height);
        }
        // Drawing the bottom line with bottom left corner.
        this.graphics.lineTo(x + bottomLeftRadius, y + height);
        if (bottomLeftRadius > 0) {
          this.graphics.quadraticCurveTo(x, y + height, x, y + height - bottomLeftRadius);
        }
        // Drawing the left line with top left corner and closing the shape.
        this.graphics.lineTo(x, y + topLeftRadius);
        if (topLeftRadius > 0) {
          this.graphics.quadraticCurveTo(x, y, x + topLeftRadius, y);
        }
        if (!this.isHaveGradient()) {
          return this.graphics.endFill();
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawComplexStroke(x, y, width, height, colorData, d, topLeftRadius, topRightRadius, bottomRightRadius, bottomLeftRadius) {
      var e, graphics;
      try {
        graphics = this.graphics;
        graphics.lineStyle(d, ...colorData);
        // Starting from the top left corner.
        graphics.moveTo(x + topLeftRadius, y);
        // Drawing the top line with top right corner.
        graphics.lineTo(x + width - topRightRadius, y);
        if (topRightRadius > 0) {
          graphics.quadraticCurveTo(x + width, y, x + width, y + topRightRadius);
        }
        // Drawing the right line with bottom right corner.
        graphics.lineTo(x + width, y + height - bottomRightRadius);
        if (bottomRightRadius > 0) {
          graphics.quadraticCurveTo(x + width, y + height, x + width - bottomRightRadius, y + height);
        }
        // Drawing the bottom line with bottom left corner.
        graphics.lineTo(x + bottomLeftRadius, y + height);
        if (bottomLeftRadius > 0) {
          graphics.quadraticCurveTo(x, y + height, x, y + height - bottomLeftRadius);
        }
        // Drawing the left line with top left corner and closing the shape.
        graphics.lineTo(x, y + topLeftRadius);
        if (topLeftRadius > 0) {
          graphics.quadraticCurveTo(x, y, x + topLeftRadius, y);
        }
        return graphics.closePath();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onResize() {
      var e;
      try {
        this.width = this.settings.width;
        return this.height = this.settings.height;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
  return KDCore.Sprite_BaseRect = Sprite_BaseRect;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_ButtonsGroup;
  // * Класс для реализации набора кнопок переключателей (Tabs)
  // * Когда только одна кнопка может быть нажата (выбрана)

    //rev 07.10.21
  Sprite_ButtonsGroup = class Sprite_ButtonsGroup extends KDCore.Sprite {
    // buttonsArray = [
    //       {image: NAME, position: [X,Y]}, ...
    //    ]
    constructor(buttonsArray, activeIndex, clickCallback) {
      var button, i, len;
      super();
      this.clickCallback = clickCallback;
      this._buttons = [];
      for (i = 0, len = buttonsArray.length; i < len; i++) {
        button = buttonsArray[i];
        this._createButton(button);
      }
      this._onButtonClick(activeIndex);
      return;
    }

    getSelectedIndex() {
      return this._buttons.findIndex(function(btn) {
        return !btn.isEnabled();
      });
    }

  };
  (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = Sprite_ButtonsGroup.prototype;
    _._createButton = function({image, position}) {
      var btn, index, method;
      // * Так как кнопки работают как переключатели, то 03 должен быть всегда
      index = this._buttons.length;
      btn = new KDCore.ButtonM(image, true, "Alpha");
      btn.move(position);
      method = () => {
        return this._onButtonClick(index);
      };
      btn.addClickHandler(method);
      this._buttons.push(btn);
      this.add(btn);
    };
    _._onButtonClick = function(index = 0) {
      var ref;
      this._resetAllButtons();
      if ((ref = this._buttons[index]) != null) {
        ref.disable(); // * Нажата
      }
      if (this.clickCallback != null) {
        this.clickCallback(index);
      }
    };
    _._resetAllButtons = function() {
      var btn, i, len, ref;
      ref = this._buttons;
      for (i = 0, len = ref.length; i < len; i++) {
        btn = ref[i];
        if (btn != null) {
          btn.enable();
        }
      }
    };
  })();
  // ■ END PRIVATE
  //---------------------------------------------------------------------------
  return KDCore.Sprite_ButtonsGroup = Sprite_ButtonsGroup;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_ButtonsGroupHandler;
  // * Класс для реализации набора кнопок переключателей (Tabs)
  // * Когда только одна кнопка может быть нажата (выбрана)
  // * В отличии от Sprite_ButtonsGroup, принимает массив
  // * уже созданных кнопок

    //rev 10.07.22
  Sprite_ButtonsGroupHandler = class Sprite_ButtonsGroupHandler extends KDCore.Sprite {
    // _buttons = [Button object with enable, disable, isEnable, addClickHandler methods]
    constructor(_buttons, clickCallback, activeIndex = 0) {
      var button, i, index, len, ref;
      super();
      this._buttons = _buttons;
      this.clickCallback = clickCallback;
      ref = this._buttons;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        button = ref[index];
        this._processButton(button, index);
      }
      this._onButtonClick(activeIndex);
      return;
    }

    getSelectedIndex() {
      return this._buttons.findIndex(function(btn) {
        return !btn.isEnabled();
      });
    }

  };
  (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = Sprite_ButtonsGroupHandler.prototype;
    _._processButton = function(btn, index) {
      var method;
      // * Так как кнопки работают как переключатели, то 03 должен быть всегда
      method = () => {
        return this._onButtonClick(index);
      };
      btn.addClickHandler(method);
      this.add(btn);
    };
    _._onButtonClick = function(index = 0) {
      var ref;
      this._resetAllButtons();
      if ((ref = this._buttons[index]) != null) {
        ref.disable(); // * Нажата
      }
      if (this.clickCallback != null) {
        this.clickCallback(index);
      }
    };
    _._resetAllButtons = function() {
      var btn, i, len, ref;
      ref = this._buttons;
      for (i = 0, len = ref.length; i < len; i++) {
        btn = ref[i];
        if (btn != null) {
          btn.enable();
        }
      }
    };
  })();
  // ■ END PRIVATE
  //---------------------------------------------------------------------------
  return KDCore.Sprite_ButtonsGroupHandler = Sprite_ButtonsGroupHandler;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_Gauge;
  //NUI 1.1
  //rev 16.06.24

    //"type": "gauge"
  Sprite_Gauge = class Sprite_Gauge extends KDCore.Sprite {
    constructor(settings) {
      super();
      this.settings = Object.assign({}, this.defaultSettings(), settings);
      this._loaded = false;
      this._lastValue = 1;
      this._gaugeBaseLayer = new KDCore.Sprite();
      this.add(this._gaugeBaseLayer);
      this._applySettings();
      return;
    }

    defaultSettings() {
      return {
        fillMode: "color", //image, plane, color
        fillColor: "#ffffff",
        fillOpacity: 255,
        imageName: "", // * for fill, if fillMode is image, for plane if fillMode is plane
        folderName: "pictures",
        margins: 2, // * For plane image
        width: "auto",
        height: "auto",
        mask: "",
        backColor: "#000000",
        backImage: "",
        backOpacity: 255,
        vertical: false
      };
    }

    isLoaded() {
      var e;
      try {
        return this._loaded === true;
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return false;
    }

    realWidth() {
      var e;
      try {
        if (this.isNotHaveBounds()) {
          return 0;
        }
        if (this.settings.width !== "auto") {
          return this.settings.width;
        } else if (this._gaugeSpr != null) {
          return this._gaugeSpr.realWidth(); //TODO: Gauge Modes
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return this.width;
    }

    realHeight() {
      var e;
      try {
        if (this.isNotHaveBounds()) {
          return 0;
        }
        if (this.settings.height !== "auto") {
          return this.settings.height;
        } else if (this._gaugeSpr != null) {
          return this._gaugeSpr.realHeight(); //TODO: Gauge Modes
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return this.height;
    }

    dataBindings() {
      return Object.assign(super.dataBindings(), {
        width: function(v) {
          if (v != null) {
            return this.setSize(v, this.settings.height);
          }
        },
        height: function(v) {
          if (v != null) {
            return this.setSize(this.settings.width, v);
          }
        },
        size: function(v) {
          if (v != null) {
            return this.setSize(v.width, v.height);
          }
        },
        rate: function(v) {
          if (v != null) {
            return this.draw(v);
          }
        },
        fillImage: function(v) {
          if (v != null) {
            return this.setFillImage(v);
          }
        },
        fillColor: function(v) {
          if (v != null) {
            return this.setFillColor(v);
          }
        },
        fillOpacity: function(v) {
          if (v != null) {
            return this.setFillOpacity(v);
          }
        }
      });
    }

    //TODO:!
    //backImage: (v) ->
    //backColor: (v) ->
    //backOpacity: (v) ->
    draw(percent = 1) {
      var e;
      try {
        if (!this.isLoaded()) {
          this._requireFunc('draw', arguments);
          return;
        }
        this._lastValue = percent;
        return this._drawGauge(percent);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setFillOpacity(opacity) {
      var e, ref;
      try {
        this.settings.fillOpacity = opacity;
        return (ref = this.fillLayer) != null ? ref.opacity = opacity : void 0;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setFillColor(color) {
      var e;
      try {
        this.settings.fillColor = color;
        if (this.fillColorBitmap != null) {
          this._createColorGaugeFillColorBitmap();
          return this._drawGauge(this._lastValue);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setFillImage(imageName) {
      var e;
      try {

      } catch (error) {
        //TODO:
        e = error;
        return KDCore.warning(e);
      }
    }

    setSize(width = "auto", height = "auto") {
      var e;
      try {
        if (width !== "auto") {
          width = this._getValueByStr(width, 'width', this);
        }
        if (height !== "auto") {
          height = this._getValueByStr(height, 'height', this);
        }
        if (width != null) {
          this.settings.width = width;
        }
        if (height != null) {
          this.settings.height = height;
        }
        return this._applySettings();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _applySettings() {
      var e;
      try {
        this._loaded = false;
        this._destroyExistGauge();
        this._createGaugeFromSettings();
        return this.draw(this._lastValue);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _destroyExistGauge() {
      var e;
      try {
        if (this._gaugeSpr == null) {
          return;
        }
        this._gaugeSpr.removeFromParent();
        return this._gaugeSpr = null;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _createGaugeFromSettings() {
      var e;
      try {
        this._gaugeSpr = new KDCore.Sprite();
        this._gaugeBaseLayer.add(this._gaugeSpr);
        switch (this.settings.fillMode) {
          case "image":
            return this._createImageGauge();
          case "plane":
            return this._createPlaneGauge();
          case "color":
            return this._createColorGauge();
          default:
            return console.warn("Unknown Gauge fillMode: " + this.settings.fillMode);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _createImageGauge() {
      var e;
      try {
        this._gaugeSourceImage = new KDCore.Sprite_Image({
          imageName: this.settings.imageName,
          folderName: this.settings.folderName,
          width: this.settings.width,
          height: this.settings.height
        });
        return this._gaugeSourceImage.addLoadListener(this._onGaugeFillImageLoaded.bind(this));
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onGaugeFillImageLoaded() {
      var e;
      try {
        this._addBackground(this._gaugeSourceImage.realWidth(), this._gaugeSourceImage.realHeight());
        this.fillLayer = KDCore.Sprite.FromBitmap(this._gaugeSourceImage.realWidth(), this._gaugeSourceImage.realHeight());
        this.fillLayer.opacity = this.settings.fillOpacity;
        this._gaugeSpr.add(this.fillLayer);
        this._addMask();
        return this._onGaugeLoadedAndReady();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onGaugeLoadedAndReady() {
      var e;
      try {
        this._loaded = true;
        this.width = this.realWidth();
        this.height = this.realHeight();
        this._applyRequiredData();
        return this._executeLoadListeners();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _createPlaneGauge() {
      var e;
      try {
        if (this.settings.width === "auto") {
          // * Нельзя создать Plane Gauge с auto размером, поэтому задаём стандартные значения
          this.settings.width = 80;
        }
        if (this.settings.height === "auto") {
          this.settings.height = 20;
        }
        this._addBackground(this.settings.width, this.settings.height);
        this.fillLayer = new KDCore.Sprite_Plane({
          imageName: this.settings.imageName,
          folderName: this.settings.folderName,
          width: this.settings.width,
          height: this.settings.height,
          margins: this.settings.margins
        });
        this.fillLayer.opacity = this.settings.fillOpacity;
        this._gaugeSpr.add(this.fillLayer);
        this._addMask();
        return this._onGaugeLoadedAndReady();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _createColorGauge() {
      var e;
      try {
        if (this.settings.width === "auto") {
          // * Нельзя создать цветную Gauge с auto размером, поэтому задаём стандартные значения
          this.settings.width = 80;
        }
        if (this.settings.height === "auto") {
          this.settings.height = 20;
        }
        this._addBackground(this.settings.width, this.settings.height);
        this.fillLayer = KDCore.Sprite.FromBitmap(this.settings.width, this.settings.height);
        this.fillLayer.opacity = this.settings.fillOpacity;
        this._createColorGaugeFillColorBitmap();
        this._gaugeSpr.add(this.fillLayer);
        this._addMask();
        return this._onGaugeLoadedAndReady();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _createColorGaugeFillColorBitmap() {
      var e;
      try {
        this.fillColorBitmap = new Bitmap(this.settings.width, this.settings.height);
        return this.fillColorBitmap.fillAll(this.settings.fillColor);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _addBackground(width, height) {
      var background, e;
      try {
        if (this._gaugeSpr == null) {
          return;
        }
        background = null;
        if (String.any(this.settings.backImage)) {
          background = this._createGaugeBackgroundImage();
        } else if (String.any(this.settings.backColor)) {
          background = this._createGaugeBackgroundColor(width, height, this.settings.backColor);
        }
        if (background != null) {
          if (this.settings.backOpacity != null) {
            background.opacity = this.settings.backOpacity;
          }
          return this._gaugeSpr.add(background);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _addMask() {
      var e, gaugeMask;
      try {
        if (this._gaugeSpr == null) {
          return;
        }
        if (String.isNullOrEmpty(this.settings.mask)) {
          return;
        }
        gaugeMask = new KDCore.Sprite_Image({
          imageName: this.settings.mask,
          folderName: this.settings.folderName,
          width: this.settings.width,
          height: this.settings.height
        });
        this._gaugeSpr.mask = gaugeMask.image;
        this._gaugeSpr.add(gaugeMask);
      } catch (error) {
        e = error;
        KDCore.warning(e);
        this._gaugeSpr.mask = null;
      }
    }

    _createGaugeBackgroundColor(width, height, color) {
      var background, e;
      try {
        background = KDCore.Sprite.FromBitmap(width, height);
        background.b().fillAll(color);
        return background;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return new KDCore.Sprite();
      }
    }

    _createGaugeBackgroundImage() {
      var e;
      try {
        return new KDCore.Sprite_Image({
          imageName: this.settings.backImage,
          folderName: this.settings.folderName,
          width: this.settings.width,
          height: this.settings.height
        });
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return new KDCore.Sprite();
      }
    }

    _drawGauge(percent) {
      var e;
      try {
        if (this.fillLayer == null) {
          return;
        }
        // * See COE, Fill Indicator
        //if @settings.vertical is true
        //TODO: VERTICAL
        //else
        return this._drawHorizontal(percent);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawHorizontal(percent) {
      var e;
      try {
        switch (this.settings.fillMode) {
          case "image":
            return this._drawImageGauge(percent);
          case "plane":
            return this._drawPlaneGauge(percent);
          case "color":
            return this._drawColorGauge(percent);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawImageGauge(percent) {
      var e, fillBitmap;
      try {
        this.fillLayer.clear();
        fillBitmap = this._gaugeSourceImage.image.bitmap;
        return this._drawGaugeBitmapBased(percent, fillBitmap);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawGaugeBitmapBased(percent, fillBitmap) {
      var e, h, w;
      try {
        w = this.realWidth() * percent;
        h = this.realHeight();
        return this.fillLayer.b().blt(fillBitmap, 0, 0, w, h, 0, 0);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawColorGauge(percent) {
      var e, fillBitmap;
      try {
        this.fillLayer.clear();
        fillBitmap = this.fillColorBitmap;
        return this._drawGaugeBitmapBased(percent, fillBitmap);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawPlaneGauge(percent) {
      var e, h, w;
      try {
        w = this.realWidth() * percent;
        h = this.realHeight();
        return this.fillLayer.setSize(w, h);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
  return KDCore.Sprite_Gauge = Sprite_Gauge;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_Group;
  //NUI 1.0
  //rev 02.08.24
  Sprite_Group = class Sprite_Group extends KDCore.Sprite {
    constructor(settings) {
      super();
      this.settings = Object.assign({}, this.defaultSettings(), settings);
      if (this.settings.horizontalNavigation === true) {
        this.pIsVerticalKeyboardNavigation = function() {
          return false;
        };
      }
      if (this.settings.freeNagivation === true) {
        this.pIsFreeKeyboardNavigation = function() {
          return true;
        };
      }
      this._applySettings();
      this._onResize();
      return;
    }

    update() {
      var e;
      super.update();
      try {
        if (this._isNeedWaitLoadingChild === true) {
          //console.log("REFRESH BY LOAD")
          return this.refreshBindings(this._dataObjectRef, true);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    refreshBindings(dataObject, recursive) {
      var c, i, len, ref;
      super.refreshBindings(...arguments);
      ref = this.children;
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        if ((c.isLoaded != null) && !c.isLoaded()) {
          this._startWaitLoading(dataObject);
          return;
        }
      }
      this._isNeedWaitLoadingChild = false;
    }

    _startWaitLoading(_dataObjectRef) {
      var e;
      this._dataObjectRef = _dataObjectRef;
      try {
        return this._isNeedWaitLoadingChild = true;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    defaultSettings() {
      return {
        keyboardHandling: false,
        horizontalNavigation: false,
        freeNagivation: false,
        width: "auto",
        height: "auto"
      };
    }

    dataBindings() {
      return Object.assign(super.dataBindings(), {
        width: function(v) {
          if (v != null) {
            return this.setSize(v, this.settings.height);
          }
        },
        height: function(v) {
          if (v != null) {
            return this.setSize(this.settings.width, v);
          }
        },
        size: function(v) {
          if (v != null) {
            return this.setSize(v.width, v.height);
          }
        }
      });
    }

    setSize(width = "auto", height = "auto") {
      var e;
      try {
        if (width !== "auto") {
          width = this._getValueByStr(width, 'width', this);
        }
        if (height !== "auto") {
          height = this._getValueByStr(height, 'height', this);
        }
        if (width != null) {
          this.settings.width = width;
        }
        if (height != null) {
          this.settings.height = height;
        }
        return this._onResize();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    realWidth() {
      var e;
      try {
        if (this.isNotHaveBounds()) {
          return 0;
        }
        if (this.settings.width === "auto") {
          return this._calculateMax("x", "width");
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return this.settings.width;
    }

    realHeight() {
      var e;
      try {
        if (this.isNotHaveBounds()) {
          return 0;
        }
        if (this.settings.height === "auto") {
          return this._calculateMax("y", "height");
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return this.settings.height;
    }

    _calculateMax(a, b) {
      var child, e, i, len, ref, size, value;
      try {
        value = 0;
        ref = this.children;
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          size = child[a] + KDCore.Utils.getRealSpriteSize(b, child);
          if (size > value) {
            value = size;
          }
        }
        if (value < 0) {
          value = 0;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return 0;
      }
      return value;
    }

    _applySettings() {
      var e;
      try {
        if (this.settings.keyboardHandling === true) {
          return this.activateHandlerManagment();
        } else {
          return this.deactivateHandlerManagment();
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onResize() {
      var e;
      try {
        this.width = this.realWidth();
        return this.height = this.realHeight();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
  return KDCore.Sprite_Group = Sprite_Group;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_Image;
  //NUI 1.0
  //rev 09.08.24

    //"type": "image"
  Sprite_Image = class Sprite_Image extends KDCore.Sprite {
    constructor(settings) {
      super();
      this.settings = Object.assign({}, this.defaultSettings(), settings);
      this._loaded = false;
      this._create();
      this._onResize();
      this.draw(this.settings.imageName);
      return;
    }

    isLoaded() {
      var e;
      try {
        if (this.settings.width !== "auto" && this.settings.height !== "auto") {
          return true;
        } else {
          return this._loaded === true;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return false;
    }

    defaultSettings() {
      return {
        imageName: "",
        folderName: "pictures",
        width: "auto",
        height: "auto",
        keepAspect: false
      };
    }

    realWidth() {
      var e;
      try {
        if (this.isNotHaveBounds()) {
          return 0;
        }
        if (this.settings.width === "auto") {
          if (this._srcBitmap != null) {
            return this._srcBitmap.width;
          } else {
            if ((this.image.bitmap != null) && this.image.bitmap.isReady()) {
              return this.image.bitmap.width;
            }
          }
        } else {
          return this.settings.width;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return this.width;
    }

    realHeight() {
      var e;
      try {
        if (this.isNotHaveBounds()) {
          return 0;
        }
        if (this.settings.height === "auto") {
          if (this._srcBitmap != null) {
            return this._srcBitmap.height;
          } else {
            if ((this.image.bitmap != null) && this.image.bitmap.isReady()) {
              return this.image.bitmap.height;
            }
          }
        } else {
          return this.settings.height;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return this.height;
    }

    dataBindings() {
      return Object.assign(super.dataBindings(), {
        width: function(v) {
          if (v != null) {
            return this.setSize(v, this.settings.height);
          }
        },
        height: function(v) {
          if (v != null) {
            return this.setSize(this.settings.width, v);
          }
        },
        size: function(v) {
          if (v != null) {
            return this.setSize(v.width, v.height);
          }
        },
        image: function(v) {
          return this.draw(v);
        },
        icon: function(v) {
          return this.drawIcon(v);
        }
      });
    }

    setSize(width = "auto", height = "auto") {
      var e;
      try {
        if (width !== "auto") {
          width = this._getValueByStr(width, 'width', this);
        }
        if (height !== "auto") {
          height = this._getValueByStr(height, 'height', this);
        }
        if (width != null) {
          this.settings.width = width;
        }
        if (height != null) {
          this.settings.height = height;
        }
        return this._onResize();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setImage(imageName, folderName = null) {
      var e;
      try {
        if (String.any(folderName)) {
          this.settings.folderName = folderName;
        }
        return this.draw(imageName);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    // * Если не иконка (число), то ничего не рисует (защита)
    drawIcon(iconIndex) {
      var e;
      try {
        if (isFinite(iconIndex)) {
          return this.draw(iconIndex);
        } else {
          return this.draw("");
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    draw(imageName = "") {
      var e;
      try {
        if (String.any(imageName) && isFinite(imageName)) {
          return this._drawIcon(imageName);
        } else if (String.any(imageName)) {
          return this._drawImage(imageName);
        } else {
          this._srcBitmap = null;
          return this._onResize();
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _create() {
      var e;
      try {
        this.image = new KDCore.Sprite(new Bitmap(1, 1));
        return this.addChild(this.image);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawIcon(iconIndex) {
      var e, w;
      try {
        w = this.settings.width;
        if (w === "auto") {
          w = 32;
        }
        this.settings.height = w;
        this._srcBitmap = new Bitmap(w, w);
        this._srcBitmap.drawIcon(0, 0, iconIndex, w, true);
        this._loaded = true;
        return this._onResize();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _drawImage(imageName) {
      var e, folderName;
      try {
        ({folderName} = this.settings);
        this._loaded = false;
        this._srcBitmap = ImageManager.loadBitmap('img/' + folderName + "/", imageName);
        return this._srcBitmap.addLoadListener(this._onBitmapLoaded.bind(this));
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onBitmapLoaded() {
      var e;
      try {
        this._loaded = true;
        this._onResize();
        this._applyRequiredData();
        return this._executeLoadListeners();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onResize() {
      var b, e, fh, fw, height, width;
      try {
        this.image.bitmap = new Bitmap(this.realWidth(), this.realHeight());
        if (this._srcBitmap == null) {
          return;
        }
        b = this._srcBitmap;
        //TODO: Опция, чтобы размер был с учётом аспекта
        if (this.settings.keepAspect === true) {
          ({width, height} = this._calculateAspectRatio(this.image.bitmap.width, this.image.bitmap.height, this._srcBitmap.width, this._srcBitmap.height));
          fw = width;
          fh = height;
        } else {
          fw = this.realWidth();
          fh = this.realHeight();
        }
        return this.image.bitmap.blt(b, 0, 0, b.width, b.height, 0, 0, fw, fh);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _calculateAspectRatio(containerWidth, containerHeight, width, height) {
      var aspectRatio, containerAspectRatio, e;
      try {
        aspectRatio = width / height;
        containerAspectRatio = containerWidth / containerHeight;
        if (aspectRatio > containerAspectRatio) {
          width = containerWidth;
          height = width / aspectRatio;
        } else {
          height = containerHeight;
          width = height * aspectRatio;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return {width, height};
    }

  };
  return KDCore.Sprite_Image = Sprite_Image;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_ImgButton;
  //NUI 1.0
  //rev 24.07.24

    //"type": "legacyButton"
  Sprite_ImgButton = class Sprite_ImgButton extends KDCore.Sprite {
    constructor(settings) {
      super();
      this.settings = Object.assign({}, this.defaultSettings(), settings);
      this._create();
      return;
    }

    defaultSettings() {
      return {
        width: "auto",
        height: "auto",
        imageName: "",
        isFull: false,
        folderName: "pictures",
        isCheckAlpha: false,
        handler: null,
        forceSize: false // * Force change button bitmaps size
      };
    }

    isLoaded() {
      var e;
      try {
        if (this.settings.width !== "auto" && this.settings.height !== "auto") {
          return true;
        } else {
          return this._loaded === true;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    realWidth() {
      var e;
      try {
        if (this.isNotHaveBounds()) {
          return 0;
        }
        if (this.settings.width === "auto") {
          return this.button.realWidth();
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return this.settings.width;
    }

    realHeight() {
      var e;
      try {
        if (this.isNotHaveBounds()) {
          return 0;
        }
        if (this.settings.height === "auto") {
          return this.button.realHeight();
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return this.settings.height;
    }

    dataBindings() {
      return Object.assign(super.dataBindings(), {
        width: function(v) {
          if (v != null) {
            return this.setSize(v, this.settings.height);
          }
        },
        height: function(v) {
          if (v != null) {
            return this.setSize(this.settings.width, v);
          }
        },
        size: function(v) {
          if (v != null) {
            return this.setSize(v.width, v.height);
          }
        },
        image: function(v) {
          return this.setImage(v);
        },
        enable: function(v) {
          if (v != null) {
            return this.setEnabledState(v);
          }
        },
        handler: function(v) {
          return this.setClickHandler(v);
        }
      });
    }

    setSize(width = "auto", height = "auto") {
      var e;
      try {
        if (width !== "auto") {
          width = this._getValueByStr(width, 'width', this);
        }
        if (height !== "auto") {
          height = this._getValueByStr(height, 'height', this);
        }
        if (width != null) {
          this.settings.width = width;
        }
        if (height != null) {
          this.settings.height = height;
        }
        if (this.settings.forceSize === true) {
          this._create();
        }
        return this._onResize();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setImage(imageName = "") {
      var e;
      try {
        if (this.button != null) {
          this._lastButtonState = this.button.isEnabled();
          this._lastButtonHandler = this.button._handler;
        }
        this.settings.imageName = imageName;
        this._create();
        // * Может не быть кнопки, если imageName == ""
        if (this.button == null) {
          return;
        }
        if (this._lastButtonState != null) {
          this.setEnabledState(this._lastButtonState);
          this._lastButtonState = null;
        }
        if (this._lastButtonHandler != null) {
          this.setClickHandler(this._lastButtonHandler);
          return this._lastButtonHandler = null;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setEnabledState(state = true) {
      var e;
      try {
        if (this.button == null) {
          return;
        }
        if (state === true) {
          return this.button.enable();
        } else {
          return this.button.disable();
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    // * В отличии от AddClickHandler, удаляет все предидущие
    setClickHandler(handler) {
      var e;
      try {
        if (this.button == null) {
          return;
        }
        this.button.clearClickHandler();
        if ((handler != null) && typeof handler === "function") {
          this.settings.handler = handler;
          return this.button.addClickHandler(handler);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    // * EXPAND FIELDS
    click() {
      var ref;
      return (ref = this.button) != null ? ref.click() : void 0;
    }

    setManualHover() {
      var ref;
      return (ref = this.button) != null ? ref.setManualHover() : void 0;
    }

    disableManualHover() {
      var ref;
      return (ref = this.button) != null ? ref.disableManualHover() : void 0;
    }

    setManualSelected() {
      var ref;
      return (ref = this.button) != null ? ref.setManualSelected(...arguments) : void 0;
    }

    enableClick() {
      var ref;
      return (ref = this.button) != null ? ref.enableClick() : void 0;
    }

    disableClick() {
      var ref;
      return (ref = this.button) != null ? ref.disableClick() : void 0;
    }

    desaturate() {
      var ref;
      return (ref = this.button) != null ? ref.desaturate() : void 0;
    }

    isMouseIn() {
      return (this.button != null) && this.button.isMouseIn();
    }

    isActive() {
      return (this.button != null) && this.button.isActive();
    }

    isDisabled() {
      return this.isEnabled();
    }

    isEnabled() {
      return (this.button != null) && this.button.isEnabled();
    }

    addClickHandler() {
      return this.setClickHandler(...arguments);
    }

    clearClickHandler() {
      var ref;
      return (ref = this.button) != null ? ref.clearClickHandler() : void 0;
    }

    simulateClick() {
      var ref;
      return (ref = this.button) != null ? ref.simulateClick() : void 0;
    }

    refreshState() {
      var ref;
      return (ref = this.button) != null ? ref.refreshState(...arguments) : void 0;
    }

    disable() {
      var e, ref;
      try {
        this.settings.enabled = false;
        return (ref = this.button) != null ? ref.disable() : void 0;
      } catch (error) {
        e = error;
        return console.warn(e);
      }
    }

    enable() {
      var e, ref;
      try {
        this.settings.enabled = true;
        return (ref = this.button) != null ? ref.enable() : void 0;
      } catch (error) {
        e = error;
        return console.warn(e);
      }
    }

    // * ==============
    _create() {
      var e, size, sourceFolder;
      try {
        this._loaded = false;
        if (this.button != null) {
          this._destroyButton();
        }
        if (!String.any(this.settings.imageName)) {
          return;
        }
        this.button = new KDCore.ButtonM(this.settings.imageName, this.settings.isFull, this.settings.folderName);
        if (this.settings.forceSize === true && this.settings.width !== "auto" && this.settings.height !== "auto") {
          sourceFolder = this.settings.folderName;
          size = {
            width: this.settings.width,
            height: this.settings.height
          };
          this.button._getGetter = function() {
            var getterFunc;
            getterFunc = function(filename) {
              var bitmap, outputBitmap;
              outputBitmap = new Bitmap(size.width, size.height);
              bitmap = ImageManager.loadBitmap('img/' + sourceFolder + '/', filename);
              bitmap.addLoadListener(function() {
                return outputBitmap.blt(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, size.width, size.height);
              });
              return outputBitmap;
            };
            return getterFunc;
          };
          this.button._bitmaps = [];
          this.button._loadBitmaps(this.settings.imageName, this.settings.isFull, this.settings.folderName);
          this.button._setImageState(0);
        }
        if (this.settings.isCheckAlpha === true) {
          this.button.isCheckAlpha = function() {
            return true;
          };
        }
        if (this.settings.handler != null) {
          this.setClickHandler(this.settings.handler);
        }
        if (this.settings.enabled === false) {
          this.button.disable();
        }
        this.button.addLoadListener(this._onLoaded.bind(this));
        return this.addChild(this.button);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onLoaded() {
      var e;
      try {
        this._loaded = true;
        this._onResize();
        this._applyRequiredData();
        return this._executeLoadListeners();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _destroyButton() {
      var e;
      try {
        if (this.button == null) {
          return;
        }
        this.button.removeFromParent();
        this._loaded = false;
        if ($gameTemp.kdButtonUnderMouse === this.button) {
          return $gameTemp.kdButtonUnderMouse = null;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onResize() {
      var e;
      try {
        this.width = this.realWidth();
        return this.height = this.realHeight();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
  return KDCore.Sprite_ImgButton = Sprite_ImgButton;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_ItemsList;
  // * Класс который позволяет сделать список (на основе Window_Selectable), но из Sprite элементов, а не Draw на Bitmap

    //rev 02.05.24

    //TODO: Dynamic items height, controls handlers support
  Sprite_ItemsList = class Sprite_ItemsList extends Window_Selectable {
    constructor(r, settings = {}) {
      if (KDCore.isMV()) {
        super(r.x, r.y, r.width, r.height);
      } else {
        super(r);
      }
      this.settings = Object.assign(this.defaultSetting(), settings);
      this.padding = this.settings.itemsPadding;
      this._prevSelectedIndex = -1;
      this._createItemsContainer();
      this._createWindowContentMask();
      this._setupBackgroundType();
      return;
    }

    defaultSetting() {
      return {
        maxCols: 1,
        isHaveSelectionEffect: false,
        selectionEffects: ["glow;distance:12;outerStrength:3"],
        scaleItemsWidth: false,
        scaleItemsHeight: false,
        defautItemHeight: 36,
        isDrawDefaultItemBack: false,
        backgroundType: 2,
        itemsPadding: 12,
        isHaveInOutAnimation: false,
        inAnimation: "field:x;duration:0.15;keyframes:0=0,100=4",
        outAnimation: "field:x;duration:0.15;keyframes:0=4,100=0"
      };
    }

    activate(index) {
      var e;
      try {
        this.refresh();
        if (index != null) {
          this.safeSelect(index);
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return super.activate();
    }

    maxItems() {
      return this.getAllItems().length;
    }

    maxCols() {
      if (this.settings != null) {
        return this.settings.maxCols || 1;
      } else {
        return 1;
      }
    }

    getAllItems() {
      return this.itemsSet || [];
    }

    setItems(itemsSet, singleItemHeight = null) {
      this.itemsSet = itemsSet;
      this.singleItemHeight = singleItemHeight;
      this._prevSelectedIndex = -1;
      this.setTopRow(0);
      this._clearPreviousItems();
      if (this.singleItemHeight == null) {
        this._adjustAutoItemsHeight(this.itemsSet[0]);
      }
      this.refresh();
      this._drawNewItems();
    }

    selectedItem() {
      return this.itemAt(this.index());
    }

    setOkHandler(handler) {
      return this.setHandler('ok', handler);
    }

    setCancelHandler(handler) {
      return this.setHandler('cancel', handler);
    }

    setSelectionHandler(handler) {
      return this.pOnSelectionChanged = handler;
    }

    itemAt(index) {
      return this.getAllItems()[index];
    }

    isNeedScaleItemsW() {
      return this.settings.scaleItemsWidth === true;
    }

    isNeedScaleItemsH() {
      return this.settings.scaleItemsHeight === true;
    }

    // * NOT WORKS!!!
    isUseDynamicHeight() {
      return false;
    }

    lineHeight(index) {
      if (this.settings != null) {
        return this.singleItemHeight || this.settings.defautItemHeight;
      } else {
        return this.singleItemHeight || 36;
      }
    }

    isDrawWindowDefaultItemsBack() {
      return this.settings.isDrawDefaultItemBack === true;
    }

    //$[OVER]
    _updateCursor() {
      if (KDCore.isMV()) {
        return this.setCursorRect(0, 0, 0, 0);
      } else {
        return this._cursorSprite.visible = false;
      }
    }

    update() {
      super.update();
      this._itemsContainer.y = -this._scrollY;
      return this._updateItemsSelectionState();
    }

  };
  (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = Sprite_ItemsList.prototype;
    _._createItemsContainer = function() {
      var ref;
      if (!this.isDrawWindowDefaultItemsBack()) {
        if ((ref = this._contentsBackSprite) != null) {
          ref.visible = false;
        }
      }
      this._windowItemsContentLayer = new Sprite();
      this._windowItemsContentLayer.move(this._padding, this._padding);
      this.addChild(this._windowItemsContentLayer);
      this._itemsContainer = new KDCore.Sprite();
      this._windowItemsContentLayer.addChild(this._itemsContainer);
      this.addChild(this._downArrowSprite);
      return this.addChild(this._upArrowSprite);
    };
    _._setupBackgroundType = function() {
      return this.setBackgroundType(this.settings.backgroundType);
    };
    _._createWindowContentMask = function() {
      var e, m, maskBitmap;
      try {
        maskBitmap = new Bitmap(this.width - this._padding * 2, this.height - this._padding * 2);
        maskBitmap.fillAll("#FFF");
        m = new Sprite(maskBitmap);
        this._windowItemsContentLayer.mask = m;
        return this._windowItemsContentLayer.addChild(m);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._adjustAutoItemsHeight = function(item) {
      var e;
      try {
        if (item == null) {
          this.singleItemHeight = 36;
          return;
        }
        if (item.realHeight != null) {
          this.singleItemHeight = item.realHeight();
        } else {
          if (item.height > 0) {
            this.singleItemHeight = item.height;
          }
        }
        if (this.singleItemHeight === 0 || !this.singleItemHeight) {
          return this.singleItemHeight = 36;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._clearPreviousItems = function() {
      var c, e, i, j, len, len1, ref, results, toRemove;
      try {
        toRemove = [];
        ref = this._itemsContainer.children;
        for (i = 0, len = ref.length; i < len; i++) {
          c = ref[i];
          toRemove.push(c);
        }
        results = [];
        for (j = 0, len1 = toRemove.length; j < len1; j++) {
          c = toRemove[j];
          results.push(c.removeFromParent());
        }
        return results;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._drawNewItems = function() {
      var e, i, index, item, len, ref, results;
      try {
        ref = this.getAllItems();
        results = [];
        for (index = i = 0, len = ref.length; i < len; index = ++i) {
          item = ref[index];
          results.push(this._addNewItemToList(item, index));
        }
        return results;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._addNewItemToList = function(item, index) {
      var e, rect;
      try {
        if (item == null) {
          return;
        }
        rect = this.itemRect(index);
        item.x = rect.x;
        item.y = rect.y;
        this._adjustItemWidthAndHeight(item);
        return this._itemsContainer.addChild(item);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._adjustItemWidthAndHeight = function(item) {
      var e, scaleFactor;
      try {
        if (item == null) {
          return;
        }
        if (this.isNeedScaleItemsW()) {
          scaleFactor = this._defaultItemWidth() / this._getItemWidth(item);
          item.scale.x = scaleFactor;
        }
        if (this.isNeedScaleItemsH()) {
          scaleFactor = this.lineHeight() / this._getItemHeight(item);
          return item.scale.y = scaleFactor;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._getItemWidth = function(item) {
      var e, v;
      v = this._defaultItemWidth();
      try {
        if (item == null) {
          return v;
        }
        if (item.realWidth != null) {
          v = item.realWidth();
        } else {
          if (item.width > 0) {
            v = item.width;
          }
        }
        if (v === 0 || !v) {
          v = this._defaultItemWidth();
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return v;
    };
    _._defaultItemWidth = function() {
      return this.width - this._padding * 2;
    };
    _._getItemHeight = function(item) {
      var e, v;
      v = 36;
      try {
        if (item == null) {
          return v;
        }
        if (item.realHeight != null) {
          v = item.realHeight();
        } else {
          if (item.height > 0) {
            v = item.height;
          }
        }
        if (v === 0 || !v) {
          v = 36;
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return v;
    };
    _._updateItemsSelectionState = function() {
      var e;
      try {
        if (KDCore.isMZ()) {
          if (!this.active || this.index() < 0 || !this.cursorVisible) {
            this._disableSelectionForAll();
            return;
          }
        } else {
          if (!this.active || this.index() < 0 || !this.isCursorVisible()) {
            this._disableSelectionForAll();
            return;
          }
        }
        return this._selectItemAtIndex(this.index());
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._disableSelectionForAll = function() {
      var e, i, item, len, ref, results;
      try {
        if (this._prevSelectedIndex === -2) {
          return;
        }
        this._prevSelectedIndex = -2;
        ref = this.getAllItems();
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          results.push(this._deselectItem(item));
        }
        return results;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._selectItem = function(item) {
      var e;
      try {
        if (item == null) {
          return;
        }
        if ((this._prevSelectedIndex != null) && this._prevSelectedIndex >= 0) {
          this._deselectItem(this.itemAt(this._prevSelectedIndex));
        }
        this._playItemInAnimation(item);
        if (item.activateInList != null) {
          return item.activateInList();
        } else {
          return this._selectItemVisually(item);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._playItemInAnimation = function(item) {
      var e;
      try {
        if (!this.settings.isHaveInOutAnimation) {
          return;
        }
        if (this.settings.inAnimation == null) {
          return;
        }
        if (item == null) {
          return;
        }
        this._playItemAnimation(item, this.settings.inAnimation);
        return this._isHaveInAnimation = true;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._selectItemVisually = function(item) {
      var e;
      try {
        if (item == null) {
          return;
        }
        if (!this.settings.isHaveSelectionEffect) {
          return;
        }
        //item.filters = [new PIXI.filters.GlowFilter({ distance: 15, outerStrength: 4 })]
        if (this.settings.selectionEffects == null) {
          return;
        }
        if (this.settings.selectionEffects.length === 0) {
          return;
        }
        KDCore.UI.Builder.ApplyEffects(item, this.settings.selectionEffects);
        return this._isSelectionEffectBeenAdded = true;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._deselectItem = function(item) {
      var e;
      try {
        if (item == null) {
          return;
        }
        this._playItemOutAnimation(item);
        if (item.deactivateInList != null) {
          return item.deactivateInList();
        } else {
          return this._deselectItemVisually(item);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._playItemOutAnimation = function(item) {
      var e;
      try {
        if (!this.settings.isHaveInOutAnimation) {
          return;
        }
        if (!this._isHaveInAnimation) {
          return;
        }
        if (this.settings.outAnimation == null) {
          return;
        }
        if (item == null) {
          return;
        }
        this._playItemAnimation(item, this.settings.outAnimation);
        return this._isHaveInAnimation = false;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._playItemAnimation = function(item, animation) {
      var e, root;
      try {
        if (item == null) {
          return;
        }
        root = item.children[0];
        if (root == null) {
          return;
        }
        if (typeof animation === "string") {
          animation = KDCore.UI.Builder.ConvertShortcut(animation);
        }
        return root.setAnimationRule(animation);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._deselectItemVisually = function(item) {
      var e;
      try {
        if (item == null) {
          return;
        }
        if (this._isSelectionEffectBeenAdded === true) {
          item.filters = [];
          return this._isSelectionEffectBeenAdded = false;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._selectItemAtIndex = function(index) {
      var e, item;
      try {
        if (this._prevSelectedIndex !== index) {
          item = this.itemAt(index);
          if (item == null) {
            return;
          }
          this._selectItem(item);
          return this._prevSelectedIndex = index;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
  })();
  // ■ END PRIVATE
  //---------------------------------------------------------------------------
  return KDCore.Sprite_ItemsList = Sprite_ItemsList;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_ItemsListN;
  //NUI 1.0
  //rev 03.05.24

    //type: "list"
  // * Этот класс служит только как Wrapper, чтобы можно было задавать настроки List через NUI схему
  Sprite_ItemsListN = class Sprite_ItemsListN extends KDCore.Sprite {
    constructor(settings) {
      super();
      this.settings = Object.assign(this.defaultSettings(), settings);
      this._applySettings();
      return;
    }

    defaultSettings() {
      return Object.assign({
        width: 240,
        height: 420
      }, KDCore.Sprite_ItemsList.prototype.defaultSetting());
    }

    /* (See parent class, this is just for reference)
           defaultSetting: -> {
               maxCols: 1,
               isHaveSelectionEffect: false,
               selectionEffects: ["glow;distance:12;outerStrength:3"],
               scaleItemsWidth: false,
               scaleItemsHeight: false,
               defautItemHeight: 36,
               isDrawDefaultItemBack: false,
               backgroundType: 2,
               itemsPadding: 12,
               isHaveInOutAnimation: false,
               inAnimation: "field:x;duration:0.15;keyframes:0=0,100=4",
               outAnimation: "field:x;duration:0.15;keyframes:0=4,100=0"
           }*/
    dataBindings() {
      return Object.assign(super.dataBindings(), {
        width: function(v) {
          if (v != null) {
            return this.setSize(v, this.settings.height);
          }
        },
        height: function(v) {
          if (v != null) {
            return this.setSize(this.settings.width, v);
          }
        },
        size: function(v) {
          if (v != null) {
            return this.setSize(v.width, v.height);
          }
        },
        maxCols: function(v) {
          if (v != null) {
            return this.setMaxCols(v);
          }
        }
      });
    }

    realWidth() {
      if (this.isNotHaveBounds()) {
        return 0;
      }
      return this.settings.width;
    }

    realHeight() {
      if (this.isNotHaveBounds()) {
        return 0;
      }
      return this.settings.height;
    }

    setSize(width, height) {
      var e;
      try {
        width = this._getValueByStr(width, 'width', this);
        height = this._getValueByStr(height, 'height', this);
        if (width != null) {
          this.settings.width = width;
        }
        if (height != null) {
          this.settings.height = height;
        }
        return this._applySettings();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setMaxCols(maxCols) {
      var e;
      try {
        this.settings.maxCols = maxCols;
        return this._applySettings();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    clear() {
      var ref;
      return (ref = this.list) != null ? ref.setItems([]) : void 0;
    }

    // * WRAPPED
    setItems() {
      var ref;
      return (ref = this.list) != null ? ref.setItems(...arguments) : void 0;
    }

    activate() {
      var ref;
      return (ref = this.list) != null ? ref.activate(...arguments) : void 0;
    }

    deactivate() {
      var ref;
      return (ref = this.list) != null ? ref.deactivate(...arguments) : void 0;
    }

    setOkHandler() {
      var ref;
      return (ref = this.list) != null ? ref.setOkHandler(...arguments) : void 0;
    }

    setCancelHandler() {
      var ref;
      return (ref = this.list) != null ? ref.setCancelHandler(...arguments) : void 0;
    }

    setSelectionHandler() {
      var ref;
      return (ref = this.list) != null ? ref.setSelectionHandler(...arguments) : void 0;
    }

    refresh() {
      var ref;
      return (ref = this.list) != null ? ref.refresh(...arguments) : void 0;
    }

    selectedItem() {
      var ref;
      return (ref = this.list) != null ? ref.selectedItem() : void 0;
    }

    itemAt() {
      var ref;
      return (ref = this.list) != null ? ref.itemAt(...arguments) : void 0;
    }

    maxItems() {
      var ref;
      return (ref = this.list) != null ? ref.maxItems() : void 0;
    }

    getAllItems() {
      var ref;
      return (ref = this.list) != null ? ref.getAllItems() : void 0;
    }

    maxCols() {
      var ref;
      return (ref = this.list) != null ? ref.maxCols() : void 0;
    }

    // * END WRAPPED

      // * Dev, (not use settings) , чтобы визуально видеть размеры окна при подгонке
    setBackgroundType() {
      var ref;
      return (ref = this.list) != null ? ref.setBackgroundType(...arguments) : void 0;
    }

    // * Shortcut
    showBack() {
      return this.setBackgroundType(0);
    }

    _applySettings() {
      var e;
      try {
        this._destroyList();
        this._createListWithSettings(this.settings);
        if (this._isHaveStoredData === true) {
          return this._restoreData();
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _destroyList() {
      var e;
      try {
        if (this.list == null) {
          return;
        }
        this._isHaveStoredData = true;
        this._lastItems = this.list.getAllItems();
        this._isBeenActive = this.list.active === true;
        this._lastSelectedIndex = this.list.index();
        this._lastHandlers = this.list._handlers;
        this.removeChild(this.list);
        return this.list = null;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _createListWithSettings(settings) {
      var e;
      try {
        this.list = new KDCore.Sprite_ItemsList({
          x: 0,
          y: 0,
          width: settings.width,
          height: settings.height
        }, settings);
        return this.addChild(this.list);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _restoreData() {
      var e;
      try {
        if (this.list == null) {
          return;
        }
        if (this._lastHandlers != null) {
          this.list._handlers = this._lastHandlers;
        }
        if (this._lastItems == null) {
          return;
        }
        this.list.setItems(this._lastItems);
        if (this._lastSelectedIndex != null) {
          this.list.safeSelect(this._lastSelectedIndex);
        }
        if (this._isBeenActive === true) {
          this.list.activate();
        }
        return this._isHaveStoredData = false;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
  return KDCore.Sprite_ItemsListN = Sprite_ItemsListN;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_NUI;
  //NUI 1.0
  //rev 06.05.24
  Sprite_NUI = class Sprite_NUI extends KDCore.Sprite {
    constructor(nuiScheme, owner = null) {
      super();
      this.nuiScheme = nuiScheme;
      if (this.nuiScheme != null) {
        this.loadNuiScheme(this.nuiScheme, owner);
      }
      return;
    }

    // * DIRECT nuiElement,без Sprite_NUI (надо присоединять к OWNER)
    static FromScheme(scheme, owner) {
      var e, spr;
      try {
        spr = new Sprite_NUI(scheme, owner);
        if (owner != null) {
          owner.addChild(spr.nuiElement);
        }
        return spr.nuiElement;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return new KDCore.Sprite_NUI();
      }
    }

    _afterLoadNuiAutoRefreshTime() {
      return 100;
    }

    loadNuiScheme(scheme, owner = null) {
      var e;
      try {
        if (this.nuiElement != null) {
          this.destroyNuiElement();
        }
        if (scheme == null) {
          return;
        }
        if (owner == null) {
          owner = this;
        }
        if (scheme["type"] != null) {
          this.nuiElement = KDCore.UI.Builder.Make(scheme, owner, this);
        } else {
          this.nuiElement = KDCore.UI.Builder.Factory(scheme, owner, this._afterLoadNuiAutoRefreshTime())[0];
        }
        this.addChild(this.nuiElement);
        return this.refreshBindings(owner, true);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    destroyNuiElement() {
      var e;
      try {
        if (this.nuiElement == null) {
          return;
        }
        this.nuiElement.removeFromParent();
        return this.nuiElement = null;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
  return KDCore.Sprite_NUI = Sprite_NUI;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_Plane;
  //NUI 1.0
  //rev 25.04.24

    //type: "plane"
  Sprite_Plane = class Sprite_Plane extends KDCore.Sprite {
    constructor(settings) {
      var bottom, folderName, imageName, left, margins, right, textureSource, top;
      super();
      this.settings = Object.assign({}, this.defaultSettings(), settings);
      this.plane = null;
      this.planeContainer = new KDCore.Sprite();
      this.addChild(this.planeContainer);
      ({imageName, margins, folderName} = this.settings);
      if (isFinite(margins)) {
        left = top = right = bottom = margins;
      } else {
        ({left, top, right, bottom} = margins);
      }
      textureSource = ImageManager.loadBitmap('img/' + folderName + '/', imageName);
      textureSource.addLoadListener(() => {
        var texture;
        texture = new PIXI.Texture(textureSource._baseTexture);
        if (KDCore.isMV()) {
          this.plane = new PIXI.mesh.NineSlicePlane(texture, left, top, right, bottom);
        } else {
          this.plane = new PIXI.NineSlicePlane(texture, left, top, right, bottom);
        }
        this.planeContainer.addChild(this.plane);
        return this._onResize();
      });
      this._onResize();
      return;
    }

    realWidth() {
      if (this.isNotHaveBounds()) {
        return 0;
      }
      return this.settings.width;
    }

    realHeight() {
      if (this.isNotHaveBounds()) {
        return 0;
      }
      return this.settings.height;
    }

    defaultSettings() {
      return {
        imageName: "",
        width: 100,
        height: 100,
        margins: 20,
        folderName: "pictures"
      };
    }

    setSize(w = 100, h = 100) {
      var e;
      try {
        w = this._getValueByStr(w, 'width', this);
        h = this._getValueByStr(h, 'height', this);
        if (w != null) {
          this.settings.width = w;
        }
        if (h != null) {
          this.settings.height = h;
        }
        return this._onResize();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    //TODO: IMAGE
    dataBindings() {
      return Object.assign(super.dataBindings(), {
        width: function(v) {
          if (v != null) {
            return this.setSize(v, this.plane.height);
          }
        },
        height: function(v) {
          if (v != null) {
            return this.setSize(this.plane.width, v);
          }
        },
        size: function(v) {
          if (v != null) {
            return this.setSize(v.width, v.height);
          }
        }
      });
    }

    _onResize() {
      var e;
      try {
        this.width = this.settings.width;
        this.height = this.settings.height;
        if (this.plane == null) {
          return;
        }
        this.plane.width = this.settings.width;
        return this.plane.height = this.settings.height;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
  return KDCore.Sprite_Plane = Sprite_Plane;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_SButton;
  //NUI 1.0
  //rev 23.07.24
  //"type": "button"
  Sprite_SButton = class Sprite_SButton extends KDCore.Sprite {
    constructor(settings) {
      super();
      this.settings = Object.assign({}, this.defaultSettings(), settings);
      this._isEnabled = true;
      this._isUnderMouse = false;
      this._isPressActive = false;
      this._isMouseOver = false;
      this._create();
      this._refreshSettings();
      return;
    }

    realWidth() {
      if (this.isNotHaveBounds()) {
        return 0;
      }
      return this.settings.width;
    }

    realHeight() {
      if (this.isNotHaveBounds()) {
        return 0;
      }
      return this.settings.height;
    }

    isDisabled() {
      return !this.isEnabled();
    }

    isEnabled() {
      return this._isEnabled === true;
    }

    _enable() {
      var e;
      try {
        if (this._desaturated === true) {
          this.filters = [];
          this._desaturated = false;
        }
        if ((this.settings.disabledTint != null) && this._isEnabled === false) { // * Return to normal Tint
          this.applyTint(this.settings.activeTint, this.settings.tintAlpha);
        }
        this._isEnabled = true;
        return this._refreshTint();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _disable() {
      var e;
      try {
        this._applyDisabledEffect();
        return this._isEnabled = false;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _applyDisabledEffect() {
      var e;
      try {
        if (this.settings.desaturateWhenDisabled === true) {
          return this.desaturate();
        } else if (this.settings.disabledTint != null) {
          return this.applyTint(this.settings.disabledTint, this.settings.disabledTintAlpha);
        } else {
          return this.applyTint(this.settings.tint, this.settings.tintAlpha);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    isActive() {
      return this._isEnabled === true && this.visible === true && this.opacity !== 0;
    }

    pIsSupportKeyboardHandle() {
      return this.settings.keyboardHandled === true;
    }

    desaturate() {
      this.filters = [new PIXI.filters.ColorMatrixFilter()];
      this.filters[0].desaturate();
      this._desaturated = true;
    }

    defaultSettings() {
      return {
        imageName: '',
        folderName: 'pictures',
        imageMargins: 20,
        width: 160,
        height: 60,
        clickSe: "Cursor1",
        desaturateWhenDisabled: false,
        tint: "",
        overTint: 0xFFFFDD,
        activeTint: 0xAAAAAA,
        tintAlpha: 0.5,
        disabledTint: 0xAAAAAA,
        disabledTintAlpha: 0.5,
        keyboardKey: "",
        keyboardHandled: true,
        enabled: true
      };
    }

    //TODO: IMAGE!
    dataBindings() {
      return Object.assign(super.dataBindings(), {
        width: function(v) {
          if (v != null) {
            return this.setSize(v, this.settings.height);
          }
        },
        height: function(v) {
          if (v != null) {
            return this.setSize(this.settings.width, v);
          }
        },
        size: function(v) {
          if (v != null) {
            return this.setSize(v.width, v.height);
          }
        },
        style: function(v) {
          if (v != null) {
            return this.updateStyle(v);
          }
        },
        handler: function(v) {
          return this.setClickHandler(v);
        },
        enable: function(v) {
          if (v != null) {
            return this.setEnabledState(v);
          }
        }
      });
    }

    setEnabledState(state = true) {
      var e;
      try {
        this.settings.enabled = state;
        if (state === true) {
          return this._enable();
        } else {
          return this._disable();
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    enable() {
      return this.setEnabledState(true);
    }

    disable() {
      return this.setEnabledState(false);
    }

    updateStyle(style) {
      var e;
      try {
        this.settings = Object.assign(this.settings, style);
        return this._refreshSettings();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    addClickHandler() {
      return this.setClickHandler(...arguments);
    }

    setClickHandler(handler = null) {
      var e;
      try {
        this.settings.onClick = null;
        if ((handler != null) && typeof handler === 'function') {
          return this.settings.onClick = handler;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    setSize(width = 160, height = 60) {
      var e, h, w;
      try {
        w = this._getValueByStr(width, 'width', this);
        h = this._getValueByStr(height, 'height', this);
        if (w != null) {
          this.settings.width = w;
        }
        if (h != null) {
          this.settings.height = h;
        }
        return this._refreshSettings();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    executeAction() {
      var e;
      try {
        KDCore.Utils.playSE(this.settings.clickSe);
        if (this.settings.onClick != null) {
          return this.settings.onClick();
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onTap() {
      var e;
      try {
        return this.executeAction();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    //console.log("TAP")
    _onOver() {
      this._isMouseOver = true;
      return this._refreshSettings();
    }

    //console.log("OVER")
    _onOut() {
      this._isMouseOver = false;
      return this._refreshSettings();
    }

    //console.log("OUT")
    _onDown() {
      this._isPressActive = true;
      return this._refreshSettings();
    }

    //console.log("DOWN")
    _onUp() {
      this._isPressActive = false;
      return this._refreshSettings();
    }

    //console.log("UP")
    _create() {
      var e, height, width;
      try {
        this.buttonPlane = new KDCore.Sprite_Plane({
          imageName: this.settings.imageName,
          margins: this.settings.imageMargins,
          folderName: this.settings.folderName
        });
        ({width, height} = this.settings);
        this.buttonPlane.setSize(width, height);
        return this.addChild(this.buttonPlane);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _refreshSettings() {
      var e;
      try {
        this._refreshTint();
        if (this.settings.keyboardHandled === true) {
          this.handleOKAction = this._onTap;
        } else {
          this.handleOKAction = null;
        }
        this.setEnabledState(this.settings.enabled);
        return this._onResize();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _refreshTint() {
      var e;
      try {
        if (this._isPressActive === true) {
          return this.applyTint(this.settings.activeTint, this.settings.tintAlpha);
        } else if (this._isMouseOver === true) {
          return this.applyTint(this.settings.overTint, this.settings.tintAlpha);
        } else {
          return this.applyTint(this.settings.tint, this.settings.tintAlpha);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    applyTint(tintValue, tintAlpha = 0.5) {
      var e;
      try {
        if (tintValue == null) {
          this._resetTintFilter();
          return;
        }
        if (typeof tintValue === "string") {
          if (!String.any(tintValue)) {
            this._resetTintFilter();
            return;
          }
          tintValue = KDCore.Utils.string2hex(tintValue);
        }
        return this.buttonPlane.filters = [new PIXI.filters.ColorOverlayFilter(tintValue, tintAlpha)];
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _resetTintFilter() {
      var e;
      try {
        return this.buttonPlane.filters = [];
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _activateHandlerVisually() {
      var e;
      try {
        return this.applyTint(this.settings.overTint);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    pDeactivateHandler() {
      super.pDeactivateHandler();
      return this.applyTint(this.settings.tint);
    }

    update() {
      super.update();
      if (this.isActive()) {
        this._updateKeyboardHandling();
        this._updateMouseHandling();
      } else {
        if (this._isUnderMouse === true) {
          this._onOut();
        }
        if ($gameTemp.kdButtonUnderMouse === this) {
          $gameTemp.kdButtonUnderMouse = null;
        }
      }
    }

    _updateKeyboardHandling() {
      var e;
      try {
        if (String.any(this.settings.keyboardKey)) {
          if (Input.isTriggered(this.settings.keyboardKey)) {
            Input.clear();
            return this._onTap();
          }
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _updateMouseHandling() {
      var e;
      try {
        if (this.isUnderMouse()) {
          if (!this._isUnderMouse) {
            this._onOver();
            $gameTemp.kdButtonUnderMouse = this;
            try {
              if ($gameTemp.__pkdActiveKeyboardHandler != null) {
                $gameTemp.__pkdActiveKeyboardHandler.pDeactivateHandler();
              }
            } catch (error) {
              e = error;
              KDCore.warning(e);
            }
            this._isUnderMouse = true;
          }
        } else {
          if (this._isUnderMouse === true) {
            this._onOut();
            if ($gameTemp.kdButtonUnderMouse === this) {
              $gameTemp.kdButtonUnderMouse = null;
            }
            this._isUnderMouse = false;
          }
        }
        if (TouchInput.isPressed()) {
          if (this._isUnderMouse === true) {
            if (!this._isMousePressed) {
              this._onDown();
              this._isMousePressed = true;
            }
          }
        }
        if (TouchInput.isReleased()) {
          if (this._isMousePressed === true) {
            this._onUp();
            if (this._isUnderMouse === true) {
              this._onTap();
            }
            return this._isMousePressed = false;
          }
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    _onResize() {
      var e, ref;
      try {
        this.width = this.settings.width;
        this.height = this.settings.height;
        return (ref = this.buttonPlane) != null ? ref.setSize(this.width, this.height) : void 0;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
  return KDCore.Sprite_SButton = Sprite_SButton;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  return (function() {    //NUI 1.3
    //rev 18.11.24

    //"type": "textPro"
    var TextProElementsBuilder, TextProParser;
    TextProParser = class TextProParser {
      // * settings - it's a Sprite_TextPro settings
      constructor(settings1) {
        this.settings = settings1;
        this._textsConfigs = [];
        this._parseAllText();
        return;
      }

      static ParseText(settings) {
        var parser;
        parser = new TextProParser(settings);
        return parser.getConfigs();
      }

      isControlSeparator(char) {
        return '\x1b' === char;
      }

      getConfigs() {
        return this._textsConfigs;
      }

      _parseAllText() {
        var e, preparedText, textState;
        try {
          preparedText = this._convertControlCharacters(this.settings.text);
          //console.log "PREPARED TEXT: " + preparedText
          textState = this._makeInitialTextState(preparedText);
          return this._processAllText(textState);
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _convertControlCharacters(inputText) {
        var e;
        try {
          return TextProParser.ConvertControlCharacters(inputText);
        } catch (error) {
          e = error;
          KDCore.warning(e);
          return "";
        }
        return outputText;
      }

      static ConvertControlCharacters(inputText) {
        var e, outputText;
        try {
          if (String.any(inputText)) {
            if (window.__kdSharedTextProTextColorSourceWindow == null) {
              if (KDCore.isMV()) {
                window.__kdSharedTextProTextColorSourceWindow = new Window_Base(0, 0, 0, 0);
              } else {
                window.__kdSharedTextProTextColorSourceWindow = new Window_Base(new Rectangle(0, 0, 0, 0));
              }
            }
            outputText = window.__kdSharedTextProTextColorSourceWindow.convertEscapeCharacters(inputText);
          } else {
            outputText = "";
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
          return "";
        }
        return outputText;
      }

      _makeInitialTextState(text) {
        return {
          "text": text,
          "buffer": "",
          "index": 0,
          "color": "", // * "" default
          "fontSize": -1, // * -1 default
          "iconIndex": -1 // * -1 none
        };
      }

      _processAllText(textState) {
        var e;
        try {
          while (textState.index < textState.text.length) {
            this._processCharacter(textState);
          }
          return this._saveTextConfig(textState);
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _processCharacter(textState) {
        var c, e;
        try {
          c = textState.text[textState.index++];
          if (c.charCodeAt(0) < 0x20) {
            this._saveTextConfig(textState);
            return this._processControlCharacter(textState, c);
          } else {
            return textState.buffer += c;
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _saveTextConfig(textState) {
        var e;
        try {
          if (textState.buffer.length > 0 || textState.iconIndex > 0) {
            this._textsConfigs.push({
              "text": textState.buffer,
              "color": textState.color,
              "fontSize": textState.fontSize,
              "iconIndex": textState.iconIndex
            });
            textState.buffer = "";
            return textState.iconIndex = -1;
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _processControlCharacter(textState, c) {
        var code, e;
        try {
          if (this.isControlSeparator(c)) {
            code = this._obtainEscapeCode(textState);
            return this._processEscapeCharacter(code, textState);
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _obtainEscapeCode(textState) {
        var arr, e, regExp;
        try {
          regExp = /^[$.|^!><{}\\]|^[A-Z]+/i;
          arr = regExp.exec(textState.text.slice(textState.index));
          if (arr != null) {
            textState.index += arr[0].length;
            return arr[0].toUpperCase();
          } else {
            return "";
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
          return "";
        }
      }

      _processEscapeCharacter(code, textState) {
        var colorIndex, currentFontSize, e, fontSize, iconIndex;
        try {
          //TODO: chex param?
          switch (code) {
            case "C":
              colorIndex = this._obtainEscapeParam(textState);
              if (colorIndex > 0) {
                if (KDCore.isMV()) {
                  return textState.color = window.__kdSharedTextProTextColorSourceWindow.textColor(colorIndex);
                } else {
                  return textState.color = ColorManager.textColor(colorIndex);
                }
              } else {
                return textState.color = "";
              }
              break;
            case "I":
              iconIndex = this._obtainEscapeParam(textState);
              if (iconIndex > 0) {
                textState.iconIndex = iconIndex;
                // * Иконка - это отдельный спрайт, так что сохраняем текущий текст как отдельный
                return this._saveTextConfig(textState);
              } else {
                return textState.iconIndex = -1;
              }
              break;
            case "FS":
              fontSize = this._obtainEscapeParam(textState);
              return textState.fontSize = fontSize;
            case "{": // * Make font bigger by 1
              currentFontSize = textState.fontSize;
              if (currentFontSize === -1) {
                //TODO: ???
                currentFontSize = this.settings.font.size;
              }
              return textState.fontSize = currentFontSize + 1;
            case "}":
              currentFontSize = textState.fontSize;
              if (currentFontSize === -1) {
                //TODO: ???
                currentFontSize = this.settings.font.size;
              }
              return textState.fontSize = currentFontSize - 1;
            default:
              return KDCore.warning("Sprite_TextPro: Unknown escape code: " + code);
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _obtainEscapeParam(textState) {
        var arr, e, regExp;
        try {
          regExp = /^\[\d+\]/;
          arr = regExp.exec(textState.text.slice(textState.index));
          if (arr != null) {
            textState.index += arr[0].length;
            return parseInt(arr[0].slice(1));
          } else {
            return "";
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
          return "";
        }
      }

    };
    KDCore.TextProParser = TextProParser;
    TextProElementsBuilder = class TextProElementsBuilder {
      // * settings - it's a Sprite_TextPro settings
      constructor(configs1, settings1, userTextStyle1) {
        this.configs = configs1;
        this.settings = settings1;
        this.userTextStyle = userTextStyle1;
        this._elements = new KDCore.Sprite_Group({});
        this._buildElements();
        return;
      }

      getElements() {
        return this._elements;
      }

      static Build(configs, settings, userTextStyle) {
        var builder;
        builder = new TextProElementsBuilder(configs, settings, userTextStyle);
        return builder.getElements();
      }

      _buildElements() {
        var config, e, i, index, len, ref, results;
        try {
          ref = this.configs;
          results = [];
          for (index = i = 0, len = ref.length; i < len; index = ++i) {
            config = ref[index];
            //console.log(config)
            if (config.iconIndex >= 0) {
              results.push(this._createIconElement(config, this._elements));
            } else {
              results.push(this._createTextElement(config, this._elements));
            }
          }
          return results;
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _createIconElement(config, line) {
        var e, icon, iconSize, paddingGroup;
        try {
          if (this.settings.isStaticIconSize === true) {
            iconSize = this.settings.iconSize;
          } else {
            if (config.fontSize > 0) {
              iconSize = config.fontSize * this.settings.iconSize;
            } else {
              iconSize = this.settings.font.size * this.settings.iconSize;
            }
          }
          icon = new KDCore.Sprite_Image({
            imageName: config.iconIndex,
            width: iconSize,
            height: iconSize
          });
          paddingGroup = new KDCore.Sprite_Group({
            width: iconSize + this.settings.iconPadding.left + this.settings.iconPadding.right,
            height: iconSize + this.settings.iconPadding.top + this.settings.iconPadding.bottom
          });
          paddingGroup.addChild(icon);
          icon.setPosition("center", "center");
          line.addChild(paddingGroup);
          return paddingGroup.setPosition("prevEndX", this._textElementVerticalPosition());
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _createTextElement(config, line) {
        var e, metrics, text, textSettings;
        try {
          textSettings = Object.assign({}, this.settings);
          textSettings.text = config.text;
          if (config.fontSize > 0) {
            textSettings.font.size = config.fontSize;
          }
          if (String.any(config.color)) {
            textSettings.textColor = config.color;
          }
          textSettings.alignment = "left";
          textSettings.multiline = false;
          textSettings.verticalCentered = false;
          textSettings.actualSize = true;
          //TODO: margins control code \MX, \MY?
          textSettings.margins = {
            "x": 0,
            "y": 0
          };
          //console.log("Create text with settings " + JSON.stringify(textSettings))
          text = new KDCore.UI.Sprite_UIText2(textSettings, this.userTextStyle);
          // * Add to line
          line.addChild(text);
          //console.log(text.realWidth())
          metrics = text.getMetrics();
          //console.log(metrics)
          //f = -> @getMetrics().width
          //f2 = -> @getMetrics().height
          //text.realWidth = f.bind(text)
          //text.realHeight = f2.bind(text)
          //text.setSize(metrics.width, metrics.height)
          return text.setPosition("prevEndX", this._textElementVerticalPosition());
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _textElementVerticalPosition() {
        var e;
        try {
          if (this.settings.verticalCentered === true) {
            return "center";
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        return 0;
      }

    };
    return KDCore.Sprite_TextPro = class Sprite_TextPro extends KDCore.Sprite {
      constructor(settings = {}, userTextStyle1 = {}) {
        super();
        this.userTextStyle = userTextStyle1;
        this.settings = Object.assign({}, this.defaultSettings(), settings);
        this._textsContainer = new KDCore.Sprite_Group({});
        this._textLines = [];
        this.addChild(this._textsContainer);
        if (String.any(this.settings.text)) {
          this.drawText(this.settings.text);
        }
        return;
      }

      draw() {
        return this.drawText(...arguments);
      }

      drawText(text) {
        this.settings.text = text;
        this._createTextSprites();
        this._applyAlignment();
        this._applyMargins();
      }

      realWidth() {
        var e;
        try {
          if (this.isNotHaveBounds()) {
            return 0;
          }
          if (this.settings.actualSize === true) {
            return this._textsContainer.realWidth();
          }
          return this.settings.size.width;
        } catch (error) {
          e = error;
          KDCore.warning(e);
          return 0;
        }
      }

      realHeight() {
        var e;
        try {
          if (this.isNotHaveBounds()) {
            return 0;
          }
          if (this.settings.actualSize === true) {
            return this._textsContainer.realHeight();
          }
          return this.settings.size.height;
        } catch (error) {
          e = error;
          KDCore.warning(e);
          return 0;
        }
      }

      dataBindings() {
        return Object.assign(super.dataBindings(), {
          text: function(v) {
            return this.drawText(v);
          },
          style: function(v) {
            if (v != null) {
              return this.updateStyle(v);
            }
          },
          width: function(v) {
            if (v != null) {
              return this.setSize(v, this.realHeight());
            }
          },
          height: function(v) {
            if (v != null) {
              return this.setSize(this.realWidth(), v);
            }
          },
          size: function(v) {
            if (v != null) {
              return this.setSize(v.width, v.height);
            }
          },
          textColor: function(v) {
            if (v != null) {
              return this.updateStyle({
                textColor: v
              });
            }
          },
          fontSize: function(v) {
            if (v != null) {
              return this.updateFontSize(v);
            }
          },
          iconSize: function(v) {
            if (v != null) {
              return this.updateIconSize(v);
            }
          },
          verticalSpacing: function(v) {
            if (v != null) {
              return this.updateVerticalSpacing(v);
            }
          }
        });
      }

      setSize(w = 60, h = 20) {
        var e;
        try {
          w = this._getValueByStr(w, 'width', this);
          h = this._getValueByStr(h, 'height', this);
          return this.updateStyle({
            size: {
              width: w,
              height: h
            }
          });
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      updateFontSize(fontSize) {
        var e, font;
        try {
          font = Object.assign({}, this.settings.font);
          if (typeof fontSize === "string") {
            fontSize = this._getValueByStr(fontSize, 'height', this);
          }
          font.size = fontSize;
          return this.updateStyle({font});
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      updateIconSize(iconSize) {
        var e;
        try {
          if (typeof iconSize === "string") {
            iconSize = this._getValueByStr(iconSize, 'height', this);
          }
          return this.updateStyle({iconSize});
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      updateVerticalSpacing(spacing) {
        var e;
        try {
          if (typeof spacing === "string") {
            spacing = this._getValueByStr(spacing, 'height', this);
          }
          return this.updateStyle({
            verticalSpacing: spacing
          });
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      updateStyle(newStyleInOldFormat = {}, newStyleInNewFormat = {}) {
        var e;
        try {
          this.settings = Object.assign(this.settings, newStyleInOldFormat);
          this.userTextStyle = Object.assign(this.userTextStyle, newStyleInNewFormat);
          // * Redraw Text
          return this.drawText(this.settings.text);
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      defaultSettings() {
        var defaultTextSettings, e;
        try {
          defaultTextSettings = KDCore.UI.Sprite_UIText2.prototype.defaultParams.call();
          return Object.assign({}, defaultTextSettings, {
            trimWidth: false,
            trimHeight: false,
            alignment: 'center',
            verticalAlignment: 'top', //center, bottom,
            multiline: false,
            verticalCentered: true,
            isStaticIconSize: false, // * If true, icon size will be iconSize in PX
            iconSize: 1, //% of font size, 1 = 100%
            iconPadding: {
              left: 2,
              right: 2,
              top: 0,
              bottom: 0
            },
            actualSize: false,
            verticalSpacing: 4 // * only for multiline
          });
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        return {};
      }

      _applyMargins() {
        var e;
        try {
          this._textsContainer.x += this.settings.margins.x;
          return this._textsContainer.y += this.settings.margins.y;
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _applyAlignment() {
        var e;
        try {
          return this._textsContainer.setPosition(this.settings.alignment, this.settings.verticalAlignment);
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _createTextSprites() {
        var e, elements, i, len, line, lines, results, textsConfigs;
        try {
          this._clearTextSprites();
          textsConfigs = TextProParser.ParseText(this.settings);
          elements = TextProElementsBuilder.Build(textsConfigs, this.settings, this.userTextStyle);
          if (this.settings.multiline === true || this.settings.trimWidth === true) {
            lines = this._separateTextToLines(elements);
            results = [];
            for (i = 0, len = lines.length; i < len; i++) {
              line = lines[i];
              this._textLines.push(line);
              this._textsContainer.addChild(line);
              this._refreshTextElementsVerticalPosition(line);
              results.push(this._applyLineAligmnent(line));
            }
            return results;
          } else {
            this._textLines.push(elements);
            this._textsContainer.addChild(elements);
            return this._refreshTextElementsVerticalPosition(elements);
          }
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _applyLineAligmnent(line) {
        var e;
        try {
          return line.setPosition(this.settings.alignment, line.y);
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _textElementVerticalPosition() {
        var e;
        try {
          if (this.settings.verticalCentered === true) {
            return "center";
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        return 0;
      }

      _refreshTextElementsVerticalPosition(groupWithElements) {
        var child, e, i, len, ref, results;
        try {
          ref = groupWithElements.children;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];
            results.push(child.setPosition(child.x, this._textElementVerticalPosition()));
          }
          return results;
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      _separateTextToLines(allTextElements) {
        var child, currentHeight, currentWidth, e, el, elements, i, j, len, len1, line, lines, maxHeight, maxLineWidth, newHeight, ref;
        try {
          lines = [];
          maxLineWidth = this.settings.size.width;
          maxHeight = this.settings.size.height;
          currentWidth = 0;
          currentHeight = function() {
            return lines.reduce(function(sum, line) {
              return sum + line.realHeight();
            }, 0);
          };
          elements = [];
          ref = allTextElements.children;
          for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];
            elements.push(child);
          }
          line = new KDCore.Sprite_Group({});
          lines.push(line);
          for (j = 0, len1 = elements.length; j < len1; j++) {
            el = elements[j];
            currentWidth += el.realWidth();
            if (currentWidth > maxLineWidth) {
              currentWidth = 0;
              if (this.settings.multiline === false) {
                break;
              }
              newHeight = currentHeight() + el.realHeight();
              if (newHeight > maxHeight) {
                if (this.settings.trimHeight === true) {
                  break;
                }
              }
              line = new KDCore.Sprite_Group({});
              line.addChild(el);
              el.setPosition(0, this._textElementVerticalPosition());
              lines.push(line);
              line.y += line.realHeight() + this.settings.verticalSpacing;
            } else {
              line.addChild(el);
              el.setPosition("prevEndX", this._textElementVerticalPosition());
            }
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        return lines;
      }

      _clearTextSprites() {
        var e, i, len, ref, spr;
        try {
          this._textsContainer.move(0, 0);
          ref = this._textLines;
          for (i = 0, len = ref.length; i < len; i++) {
            spr = ref[i];
            spr.removeFromParent();
          }
          return this._textLines = [];
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

    };
  })();
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad((function() {
  var Sprite_TilingFrame;
  Sprite_TilingFrame = class Sprite_TilingFrame extends KDCore.Sprite {
    constructor(width, height, skinBitmap) {
      super();
      this.width = width;
      this.height = height;
      this.skinBitmap = skinBitmap;
      this._createParts();
      this._refreshAll();
    }

    _createParts() {
      var i, j;
      this.backSprite = new Sprite();
      this.addChild(this.backSprite);
      this.content = new Sprite();
      this.addChild(this.content);
      this._outFrame = new Sprite();
      for (i = j = 0; j < 8; i = ++j) {
        this._outFrame.addChild(new Sprite());
      }
      return this.addChild(this._outFrame);
    }

    // * Отступ, чтобы за рамку не выходить
    _fillPadding() {
      return 2;
    }

    // * Размер частей на картинке
    _fillImagePartWidth() {
      return 96;
    }

    _fillImagePartHeight() {
      return 96;
    }

    // * Толщина рамки
    _frameThickness() {
      return 12;
    }

    _refreshAll() {
      this._refreshBack();
      return this._refreshTFrame();
    }

    _refreshBack() {
      var fh, fw, h, m, sprite, w;
      m = this._fillPadding();
      w = Math.max(0, this.width - m * 2);
      h = Math.max(0, this.height - m * 2);
      sprite = this.backSprite;
      sprite.bitmap = this.skinBitmap;
      // * Координаты фона из картинки
      fw = this._fillImagePartWidth();
      fh = this._fillImagePartHeight();
      sprite.setFrame(0, 0, fw, fh);
      sprite.move(m, m);
      sprite.scale.x = w / fw;
      return sprite.scale.y = h / fh;
    }

    _refreshTFrame() {
      var drect, fh, fw, j, len, m, ref, spr, srect;
      fw = this._fillImagePartWidth();
      fh = this._fillImagePartHeight();
      // * Положение назначения
      drect = {
        x: 0,
        y: 0,
        width: this.width,
        height: this.height
      };
      // * Координаты рамки на картинке
      srect = {
        x: fw,
        y: 0,
        width: fw,
        height: fh
      };
      m = this._frameThickness(); // * Толщина
      ref = this._outFrame.children;
      for (j = 0, len = ref.length; j < len; j++) {
        spr = ref[j];
        spr.bitmap = this.skinBitmap;
      }
      if (KDCore.isMZ()) {
        Window.prototype._setRectPartsGeometry.call(this, this._outFrame, srect, drect, m);
      } else {
        this._setRectPartsGeometry(this._outFrame, srect, drect, m);
      }
    }

    // * Этот метод существует в MZ, но нет в MV
    //? From MZ
    _setRectPartsGeometry(sprite, srect, drect, m) {
      var child, children, dh, dmh, dmw, dw, dx, dy, j, len, sh, smh, smw, sw, sx, sy;
      sx = srect.x;
      sy = srect.y;
      sw = srect.width;
      sh = srect.height;
      dx = drect.x;
      dy = drect.y;
      dw = drect.width;
      dh = drect.height;
      smw = sw - m * 2;
      smh = sh - m * 2;
      dmw = dw - m * 2;
      dmh = dh - m * 2;
      children = sprite.children;
      sprite.setFrame(0, 0, dw, dh);
      sprite.move(dx, dy);
      // corner
      children[0].setFrame(sx, sy, m, m);
      children[1].setFrame(sx + sw - m, sy, m, m);
      children[2].setFrame(sx, sy + sw - m, m, m);
      children[3].setFrame(sx + sw - m, sy + sw - m, m, m);
      children[0].move(0, 0);
      children[1].move(dw - m, 0);
      children[2].move(0, dh - m);
      children[3].move(dw - m, dh - m);
      // edge
      children[4].move(m, 0);
      children[5].move(m, dh - m);
      children[6].move(0, m);
      children[7].move(dw - m, m);
      children[4].setFrame(sx + m, sy, smw, m);
      children[5].setFrame(sx + m, sy + sw - m, smw, m);
      children[6].setFrame(sx, sy + m, m, smh);
      children[7].setFrame(sx + sw - m, sy + m, m, smh);
      children[4].scale.x = dmw / smw;
      children[5].scale.x = dmw / smw;
      children[6].scale.y = dmh / smh;
      children[7].scale.y = dmh / smh;
      // center
      if (children[8] != null) {
        children[8].setFrame(sx + m, sy + m, smw, smh);
        children[8].move(m, m);
        children[8].scale.x = dmw / smw;
        children[8].scale.y = dmh / smh;
      }
      for (j = 0, len = children.length; j < len; j++) {
        child = children[j];
        child.visible = dw > 0 && dh > 0;
      }
    }

  };
  return KDCore.Sprite_TilingFrame = Sprite_TilingFrame;
}));


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Window_ExtTextLineBase;
  // * Данное окно используется как основа для Sprite_UITextExt
  //rev 07.10.21
  Window_ExtTextLineBase = class Window_ExtTextLineBase extends Window_Base {
    constructor(rect, fontSettings, styleSettings = {}) {
      super(rect);
      this.fontSettings = fontSettings;
      this.styleSettings = styleSettings;
      this.createContents();
      // * Всегда прозрачное окно
      this.setBackgroundType(2);
      this.resetFontSettings();
      return;
    }

    // * Нет отступов
    updatePadding() {
      return this.padding = 0;
    }

    // * Нет отступов
    itemPadding() {
      return 0;
    }

    textPadding() {
      return 0;
    }

    standardPadding() {
      return 0;
    }

    contentsWidth() {
      return this.width;
    }

    contentsHeight() {
      return this.height;
    }

    // * Более гибкая настройка размера текста при { }
    makeFontBigger() {
      return this.contents.fontSize += 1;
    }

    makeFontSmaller() {
      if (this.contents.fontSize > 1) {
        return this.contents.fontSize -= 1;
      }
    }

    resetTextColor() {
      super.resetTextColor();
      if (this.styleSettings == null) {
        return;
      }
      if (this.styleSettings.textColor != null) {
        return this.contents.textColor = this.styleSettings.textColor;
      }
    }

    // * Применение своих шрифта и размера текста
    resetFontSettings() {
      super.resetFontSettings();
      if (this.fontSettings == null) {
        return;
      }
      if (String.any(this.fontSettings.face)) {
        this.contents.fontFace = this.fontSettings.face;
      }
      if (this.fontSettings.size > 0) {
        this.contents.fontSize = this.fontSettings.size;
      }
      if (this.fontSettings.italic != null) {
        this.contents.fontItalic = this.fontSettings.italic;
      }
    }

  };
  return KDCore.Window_ExtTextLineBase = Window_ExtTextLineBase;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  // * Button M
  //------------------------------------------------------------------------------
  //@[AUTO EXTEND]
  // * Button Mini - упрощённый класс Sprite_XButton (KDCore.Button)

    // * Принимает название файла изображения кнопки без _00
  // * Названия изображения должны быть в стандартном формате _00, _01, [_03]
  // * _02 - не используются в этом классе

    // * Класс использует глобальную временную переменную для определения находится ли мышь в зоне кнопки

    //TODO: ADD ALPHA CHECK!

    // * Если isFull - true, значит нужен _03
  KDCore.ButtonM = class ButtonM extends KDCore.Sprite {
    constructor(filename, isFull = false, sourceFolder = null) {
      super();
      this._bitmaps = [];
      this._disabled = false;
      this._isTriggered = false;
      // * Когда произошло нажатие на кнопку
      this._handler = null;
      this._isCanBeClicked = true;
      this._isManualHoverMode = false;
      this._isManualSelected = false;
      this._loadBitmaps(filename, isFull, sourceFolder);
      this._setImageState(0);
      this._createThread();
    }

    realWidth() {
      return this._bitmaps[0].width;
    }

    realHeight() {
      return this._bitmaps[0].height;
    }

    setManualHover() {
      return this._isManualHoverMode = true;
    }

    disableManualHover() {
      return this._isManualHoverMode = false;
    }

    setManualSelected(_isManualSelected) {
      this._isManualSelected = _isManualSelected;
    }

    enableClick() {
      return this._isCanBeClicked = true;
    }

    disableClick() {
      return this._isCanBeClicked = false;
    }

    desaturate() {
      this.filters = [new PIXI.filters.ColorMatrixFilter()];
      this.filters[0].desaturate();
    }

    isLoaded() {
      var ref;
      return (ref = this._bitmaps[0]) != null ? ref.isReady() : void 0;
    }

    isMouseIn() {
      if (this._isManualHoverMode === true) {
        return this._isManualSelected;
      } else {
        return this.isUnderMouse() && this.visible === true;
      }
    }

    isAllParentsActive() {
      var e, parent;
      try {
        parent = this.parent;
        while (parent != null) {
          if (parent.visible === false) {
            return false;
          }
          if (parent.opacity === 0) {
            return false;
          }
          parent = parent.parent;
        }
        return true;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return false;
      }
    }

    isActive() {
      if (this._isCanBeClicked === false) {
        return false;
      }
      if (this.visible === false) {
        return false;
      }
      if (this.opacity === 0) {
        return false;
      }
      return this.isAllParentsActive();
    }

    isDisabled() {
      return this._disabled === true;
    }

    addClickHandler(_handler) {
      this._handler = _handler;
    }

    clearClickHandler() {
      return this._handler = null;
    }

    // * Воспроизводит визуальный эффект нажатия
    simulateClick() {
      if (!this.isActive()) {
        return;
      }
      if (this.isDisabled()) {
        return;
      }
      if (this.isMouseIn()) {
        return;
      }
      this._startSimulation();
    }

    isEnabled() {
      return !this.isDisabled();
    }

    refreshState(isEnable = true) {
      if (isEnable === true) {
        if (this.isDisabled()) {
          this.enable();
        }
      } else {
        if (this.isEnabled()) {
          this.disable();
        }
      }
    }

    disable() {
      this._disabled = true;
      return this._setImageState(2);
    }

    enable() {
      this._disabled = false;
      return this._setImageState(0);
    }

    click() {
      if (this._handler != null) {
        return this._handler();
      }
    }

    update() {
      super.update();
      return this._updateMain();
    }

  };
  return (function() {    
    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ ButtonM Implementation
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _, alias_SM_isAnyButtonPressed, alias_SM_onMapLoaded;
    //@[DEFINES]
    _ = KDCore.ButtonM.prototype;
    _._loadBitmaps = function(filename, isFull = false, sourceFolder = null) {
      var getterFunc;
      getterFunc = this._getGetter(sourceFolder);
      this._bitmaps.push(getterFunc(filename + '_00'));
      this._bitmaps[0].addLoadListener(this._onBitmapLoaded.bind(this));
      this._bitmaps.push(getterFunc(filename + '_01'));
      if (isFull) {
        this._bitmaps.push(getterFunc(filename + '_03'));
      }
    };
    _._onBitmapLoaded = function() {
      var e;
      try {
        return this._executeLoadListeners();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._getGetter = function(sourceFolder = null) {
      var getterFunc;
      getterFunc = function(filename) {
        return ImageManager.loadPicture(filename);
      };
      if (sourceFolder !== null) {
        getterFunc = function(filename) {
          return ImageManager.loadBitmap('img/' + sourceFolder + '/', filename);
        };
      }
      return getterFunc;
    };
    _._setImageState = function(index = 0) {
      if (this._bitmaps[index] == null) {
        index = 0;
      }
      this.bitmap = this._bitmaps[index];
      this._lastState = index;
    };
    _._createThread = function() {
      this.hoverThread = new KDCore.TimedUpdate(3, this._updateHover.bind(this));
      this.hoverThread.applyTimeRange(-1, 1);
      this.hoverThread.call();
    };
    //?[DYNAMIC]
    _._updateMain = function() {
      this._updateMouseLogic();
      if (!this.isActive()) {
        if (($gameTemp.kdButtonUnderMouse != null) && $gameTemp.kdButtonUnderMouse === this) {
          return $gameTemp.kdButtonUnderMouse = null;
        }
      }
    };
    _._updateMouseLogic = function() {
      this.hoverThread.update();
      return this._updateMouseClick();
    };
    _._updateHover = function() {
      var e;
      if (!this.isActive()) {
        return;
      }
      // * чтобы эффект нажатия не прекратить
      if (this._isTriggered === true) {
        return;
      }
      if (this.isMouseIn()) {
        if (this._lastState !== 1) {
          if (!this.isDisabled()) {
            this._setImageState(1);
          }
          $gameTemp.kdButtonUnderMouse = this;
          try {
            if ($gameTemp.__pkdActiveKeyboardHandler != null) {
              $gameTemp.__pkdActiveKeyboardHandler.pDeactivateHandler();
            }
          } catch (error) {
            e = error;
            KDCore.warning(e);
          }
        }
      } else {
        if (this._lastState !== 0) {
          if (!this.isDisabled()) {
            this._setImageState(0);
          }
          if ($gameTemp.kdButtonUnderMouse === this) {
            $gameTemp.kdButtonUnderMouse = null;
          }
        } else if ($gameTemp.kdButtonUnderMouse === this) {
          $gameTemp.kdButtonUnderMouse = null;
        }
      }
    };
    _._updateMouseClick = function() {
      if (!this.isActive()) {
        return;
      }
      if (this.isDisabled()) {
        return;
      }
      if (TouchInput.isTriggered() && this.isUnderMouse()) {
        this._isTriggered = true;
        this._setImageState(0);
      }
      if (this._isTriggered === true) {
        if (TouchInput.isReleased()) {
          this._isTriggered = false;
          if (this.isMouseIn()) {
            this.click();
          }
        }
      }
    };
    _._startSimulation = function() {
      this._setImageState(1);
      this._simulateThread = new KDCore.TimedUpdate(10, () => {
        return this._setImageState(0);
      });
      this._simulateThread.once();
      return this._updateMain = this._updateMouseClickSimulated;
    };
    _._updateMouseClickSimulated = function() {
      this._simulateThread.update();
      if (!this._simulateThread.isAlive()) {
        this._simulateThread = null;
        this._updateMain = this._updateMouseLogic;
      }
    };
    // * Теперь при нажатии на любую кнопку, игрок не будет ходить по карте

    //@[ALIAS]
    alias_SM_isAnyButtonPressed = Scene_Map.prototype.isAnyButtonPressed;
    Scene_Map.prototype.isAnyButtonPressed = function() {
      if ($gameTemp.kdButtonUnderMouse != null) {
        return true;
      } else {
        return alias_SM_isAnyButtonPressed.call(this);
      }
    };
    //TODO: Добавить доп. проверку?
    //@[ALIAS]
    alias_SM_onMapLoaded = Scene_Map.prototype.onMapLoaded;
    Scene_Map.prototype.onMapLoaded = function() {
      $gameTemp.kdButtonUnderMouse = null;
      setTimeout((function() {
        return $gameTemp.kdButtonUnderMouse = null;
      }), 50);
      return alias_SM_onMapLoaded.call(this);
    };
  })();
});

// ■ END ButtonM Implementation
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  // * Button Mini User - класс с определением файла каждого состояния отдельно
  // * Принимает теже аргументы, только заместо имени файла, три изображения (имени)
  // ? states = { main, hover, disabled }
  return KDCore.ButtonMU = class ButtonMU extends KDCore.ButtonM {
    constructor() {
      super(...arguments);
    }

    //$[OVER]
    _loadBitmaps(states, isFull = true, sourceFolder = null) {
      var getterFunc;
      getterFunc = this._getGetter(sourceFolder);
      this._bitmaps.push(getterFunc(states.main));
      this._bitmaps.push(getterFunc(states.hover));
      // * Optional 03
      if (String.any(states.disabled)) {
        this._bitmaps.push(getterFunc(states.disabled));
      }
    }

  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_TilingLine;
  Sprite_TilingLine = class Sprite_TilingLine extends KDCore.Sprite_TilingFrame {
    constructor() {
      super(...arguments);
    }

    //$[OVER BASE ALL BELOW]
    _fillPadding() {
      return 0;
    }

    _refreshTFrame() {} // * EMPTY

    _fillImagePartWidth() {
      return 4;
    }

    _fillImagePartHeight() {
      return 26;
    }

  };
  return KDCore.Sprite_TilingLine = Sprite_TilingLine;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  // * Пространство имён для всех UIElements
  KDCore.UI = KDCore.UI || {};
  (function() {    // * Общий класс для всех UI элементов
    //?rev 07.02.2024
    var Sprite_UIElement;
    Sprite_UIElement = (function() {
      // * ABSTRACT значит что класс сам по себе ничего не создаёт, не хранит данные
      //@[ABSTRACT]
      class Sprite_UIElement extends KDCore.Sprite {
        constructor(params) {
          super();
          this.params = params;
          this._init();
        }

        // * Стандартный набор настроек
        defaultParams() {
          return {
            visible: true
          };
        }

        // * Общий метод (есть у всех элементов)
        // * По умолчанию вызывает drawText, но потомки могут переопределить
        draw() {
          return this.drawText(...arguments);
        }

        // * Общий метод
        drawText() {} // * EMPTY

        
          // * Если изначально невидимый (из параметров), то не активный вообще
        isActive() {
          return this.params.visible === true;
        }

        rootImageFolder() {
          if (String.any(this.params.rootImageFolder)) {
            return this.params.rootImageFolder;
          } else {
            return Sprite_UIElement.RootImageFolder;
          }
        }

        // * Сделать чёрно белым
        desaturate() {
          this.filters = [new PIXI.filters.ColorMatrixFilter()];
          this.filters[0].desaturate();
        }

        clearFilters() {
          return this.filters = [];
        }

        // * Общий метод (можно ли редактировать визуально)
        isCanBeEdited() {
          return false;
        }

        // * Общий метод (надо ли скрывать при игровом сообщнии)
        isHaveHideWithMessageFlag() {
          return false;
        }

        // * Общий метод (находится ли объект под мышкой)
        isUnderMouse() {
          var ref;
          return ((ref = this.zeroChild()) != null ? ref.isUnderMouse() : void 0) && this.isFullVisible();
        }

        // * Полностью ли виден объект? (включае всех его родителей)
        isFullVisible() {
          return this.visible === true && this.allParentsIsVisible();
        }

        // * Все ли родители объекта видимы
        allParentsIsVisible() {
          var e, p;
          if (!this.visible) {
            return false;
          }
          try {
            if (this.parent != null) {
              p = this.parent;
              while (p != null) {
                if (p.visible === true) {
                  p = p.parent;
                } else {
                  return false;
                }
              }
              return true;
            } else {
              return this.visible === true;
            }
          } catch (error) {
            e = error;
            KDCore.warning(e);
            return true;
          }
        }

        // * Параметры первого элемента (если он есть)
        realWidth() {
          var child;
          child = this.zeroChild();
          if (child != null) {
            if (child instanceof KDCore.UI.Sprite_UIElement) {
              return child.realWidth();
            } else {
              return child.width;
            }
          }
          return 0;
        }

        realHeight() {
          var child;
          child = this.zeroChild();
          if (child != null) {
            if (child instanceof KDCore.UI.Sprite_UIElement) {
              return child.realHeight();
            } else {
              return child.height;
            }
          }
          return 0;
        }

        // * Метод восстановления значения на стандартные настройки
        reset(property) {
          var e;
          try {
            switch (property) {
              case "position":
                this._resetPosition();
                break;
              default:
                this[property] = this.params[property];
            }
          } catch (error) {
            e = error;
            KDCore.warning(e);
          }
        }

      };

      // * Корневая директория для изображений
      Sprite_UIElement.RootImageFolder = "Alpha";

      return Sprite_UIElement;

    }).call(this);
    KDCore.UI.Sprite_UIElement = Sprite_UIElement;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UIElement.prototype;
    _._init = function() {
      var e;
      this._prepare();
      try {
        return this._createContent();
      } catch (error) {
        e = error;
        KDCore.warning(e);
        // * Если при создании произошла ошибка, отключаем элемент
        return this.isActive = function() {
          return false;
        };
      }
    };
    
    // * Подготовка элемента (проверка параметров)
    _._prepare = function() {
      //@params = @defaultParams() unless @params?
      this.params = Object.assign({}, this.defaultParams(), this.params);
      if (this.params.visible != null) {
        this.visible = this.params.visible;
      }
    };
    // * Наследники создают свои элементы в этом методе
    _._createContent = function() {}; // * EMPTY
    
    // * Сброс позиции
    _._resetPosition = function() {
      var e, x, y;
      if (this.params.position == null) {
        return;
      }
      try {
        ({x, y} = this.params.position);
        if (isFinite(x) && isFinite(y)) {
          x = Number(x);
          y = Number(y);
        } else {
          x = Number(eval(x));
          y = Number(eval(y));
        }
        this.move(x, y);
      } catch (error) {
        e = error;
        KDCore.warning(e);
        this.move(0, 0);
      }
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_ItemsListNHor;
  //TODO: NOT USED IN NUI 1.0
  //NUI 1.X !#!
  //rev 03.05.24

    //"type": "horList"
  Sprite_ItemsListNHor = class Sprite_ItemsListNHor extends KDCore.Sprite_ItemsListN {
    constructor() {
      super(...arguments);
    }

    //$[OVER]
    defaultSettings() {
      var settings;
      settings = super.defaultSettings();
      settings.width = 420;
      settings.height = 120;
      settings.maxCols = 4;
      return settings;
    }

    //$[OVER]
    setMaxCols(maxCols) {} // * AUTO

    setItems(items) {
      var e, l;
      try {
        if (items != null) {
          l = this.maxItems();
          if (l !== items.length) {
            this.settings.maxCols = items.length;
            this.clear();
            this._applySettings();
          }
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return super.setItems(items);
    }

  };
  return KDCore.Sprite_ItemsListNHor = Sprite_ItemsListNHor;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Sprite_Screen;
  //NUI 1.0
  //rev 04.05.24

    //"type": "screen"
  Sprite_Screen = class Sprite_Screen extends KDCore.Sprite_Group {
    constructor(settings) {
      super(settings);
      this._applyExtraSettings();
    }

    //TODO: В режиме linkToMap, должен иметь width и height карты (size * tileSize)
    realWidth() {
      if (this.isNotHaveBounds()) {
        return 0;
      }
      return Graphics.width;
    }

    realHeight() {
      if (this.isNotHaveBounds()) {
        return 0;
      }
      return Graphics.height;
    }

    defaultSettings() {
      var defaultSettings;
      defaultSettings = super.defaultSettings();
      return Object.assign(defaultSettings, {
        width: Graphics.width,
        height: Graphics.height,
        linkToMap: false //TODO: NOT USED IN NUI 1.0
      });
    }

    _applyExtraSettings() {
      var e;
      try {
        if (this.settings.linkToMap === true) {
          return this.anchorPoint = new KDCore.MapAnchorPoint(0, 0);
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

    update() {
      super.update();
      return this._refreshScreenPosition();
    }

    _refreshScreenPosition() {
      var e;
      try {
        if (this.anchorPoint == null) {
          return;
        }
        this.x = this.anchorPoint.screenX();
        return this.y = this.anchorPoint.screenY();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    }

  };
  return KDCore.Sprite_Screen = Sprite_Screen;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {
    var Sprite_UIButton;
    // * Кнопка на экране, можно нажимать
    Sprite_UIButton = class Sprite_UIButton extends KDCore.UI.Sprite_UIElement {
      constructor() {
        super(...arguments);
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          image: "Button_Inventory",
          isHaveDisabled: true,
          rootImageFolder: null, //?optional
          click: "console.log('click')" // * число или код
        };
      }

      // * Кнопка не поддерживает перерисовку
      draw() {} // * EMPTY

      disable() {
        var ref;
        return (ref = this.button) != null ? ref.disable() : void 0;
      }

      enable() {
        var ref;
        return (ref = this.button) != null ? ref.enable() : void 0;
      }

      setState(isEnabled) {
        if (isEnabled) {
          return this.enable();
        } else {
          return this.disable();
        }
      }

      
        // * Просто вызов метода
      call() {
        var ref;
        return (ref = this.button) != null ? ref.click() : void 0;
      }

      // * Вызов метода с симуляцией нажатия
      click() {
        var ref, ref1;
        if ((ref = this.button) != null) {
          ref.click();
        }
        return (ref1 = this.button) != null ? ref1.simulateClick() : void 0;
      }

    };
    KDCore.UI.Sprite_UIButton = Sprite_UIButton;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UIButton.prototype;
    //$[OVER]
    _._createContent = function() {
      if (this.params.image.isEmpty()) {
        KDCore.warning('You try create Button without image');
        return;
      }
      this.button = new KDCore.ButtonM(this.params.image, this.params.isHaveDisabled, this.rootImageFolder());
      this.add(this.button);
      return this._registerClickMethod();
    };
    _._registerClickMethod = function() {
      var commonEventId, e, method, ref, script;
      if (!String.any(this.params.click)) {
        return;
      }
      method = null;
      try {
        // * Если число, то значит общее событие
        if (isFinite(this.params.click)) {
          commonEventId = parseInt(this.params.click);
          if (commonEventId > 0) {
            method = function() {
              return $gameTemp.reserveCommonEvent(commonEventId);
            };
          }
        } else {
          // * Иначе скрипт
          script = this.params.click;
          method = function() {
            return eval(script);
          };
        }
        return this.button.addClickHandler(method);
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return (ref = this.button) != null ? ref.clearClickHandler() : void 0;
      }
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {    // * Рисует лицо персонажа (из папки Faces)
    var Sprite_UIFace;
    Sprite_UIFace = class Sprite_UIFace extends KDCore.UI.Sprite_UIElement {
      constructor() {
        super(...arguments);
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          faceName: "Actor1",
          faceIndex: 0,
          mirror: false,
          size: 144
        };
      }

      draw() {
        return this.drawFace(...arguments);
      }

      drawFace(faceName, faceIndex) {
        return this._drawFaceWhenReady(faceName, faceIndex);
      }

    };
    KDCore.UI.Sprite_UIFace = Sprite_UIFace;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UIFace.prototype;
    //$[OVER]
    _._createContent = function() {
      return this._createFaceSprite();
    };
    _._createFaceSprite = function() {
      this._faceSpr = KDCore.Sprite.FromBitmap(this.params.size);
      if (this.params.mirror === true) {
        this._flipFaceSpr();
      }
      this.add(this._faceSpr);
      this._drawFaceWhenReady(this.params.faceName, this.params.faceIndex);
    };
    _._flipFaceSpr = function() {
      this._faceSpr.scale.x = -1;
      this._faceSpr.x = this.params.size;
    };
    _._drawFaceWhenReady = function(name, index = 0) {
      var ref;
      if ((ref = this._faceSpr) != null) {
        ref.clear();
      }
      if (!String.any(name)) {
        return;
      }
      if (index < 0) {
        return;
      }
      this._drawOnReady = {name, index};
      this._faceSourceBitmap = ImageManager.loadFace(name);
      this._faceSourceBitmap.addLoadListener(this._drawFace.bind(this));
      this._drawFace();
    };
    _._drawFace = function() {
      var fh, fw, size, sx, sy;
      if (this._faceSpr == null) {
        return;
      }
      this._faceSpr.clear();
      if (!String.any(this._drawOnReady.name)) {
        return;
      }
      if (KDCore.isMZ()) {
        fw = ImageManager.faceWidth;
        fh = ImageManager.faceHeight;
      } else {
        fw = Window_Base._faceWidth;
        fh = Window_Base._faceHeight;
      }
      size = this.params.size;
      sx = (this._drawOnReady.index % 4) * fw;
      sy = Math.floor(this._drawOnReady.index / 4) * fh;
      this._faceSpr.bitmap.blt(this._faceSourceBitmap, sx, sy, fw, fh, 0, 0, size, size);
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {
    var Sprite_UIGauge;
    Sprite_UIGauge = class Sprite_UIGauge extends KDCore.UI.Sprite_UIElement {
      constructor() {
        super(...arguments);
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          fill: "",
          foreground: "",
          mask: "",
          backColor: "#000000".toCss(),
          backOpacity: 255,
          vertical: false,
          rootImageFolder: null //?optional
        };
      }

      draw() {
        return this.drawGauge(...arguments);
      }

      drawGauge(percent = 1) {
        this._lastValue = percent;
        return this._drawGauge(percent);
      }

      isVertical() {
        return this.params.vertical === true;
      }

    };
    KDCore.UI.Sprite_UIGauge = Sprite_UIGauge;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UIGauge.prototype;
    //$[OVER]
    _._createContent = function() {
      // * Загружается главное изображение, затем уже все остальные, т.к. нужны размеры
      return this._loadFillImage();
    };
    _._loadFillImage = function() {
      // * Главное изображение, поэтому если не указано, то ничего
      if (this.params.fill.isEmpty()) {
        KDCore.warning('You try create Gauge without fill image');
        return;
      }
      KDCore.Utils.loadImageAsync(this.rootImageFolder(), this.params.fill).then(this._createParts.bind(this));
    };
    // * Получаем изображение заполнения и создаём части (т.к. есть размеры)
    _._createParts = function(fillBitmap) {
      this.fillBitmap = fillBitmap;
      this._createBackground();
      this._createFillLayer();
      this._loadForeground();
      this._loadMask();
      return this._onReady();
    };
    _._createBackground = function() {
      this.background = KDCore.Sprite.FromBitmap(this.fillBitmap.width, this.fillBitmap.height);
      this.background.b().fillAll(this.params.backColor);
      this.background.opacity = this.params.backOpacity;
      return this.add(this.background);
    };
    _._createFillLayer = function() {
      this.fillLayer = KDCore.Sprite.FromBitmap(this.fillBitmap.width, this.fillBitmap.height);
      return this.add(this.fillLayer);
    };
    _._loadForeground = function() {
      var fore;
      if (String.isNullOrEmpty(this.params.foreground)) {
        return;
      }
      fore = KDCore.Sprite.FromImg(this.params.foreground, this.rootImageFolder());
      return this.add(fore);
    };
    _._loadMask = function() {
      var mask;
      if (String.isNullOrEmpty(this.params.mask)) {
        return;
      }
      mask = KDCore.Sprite.FromImg(this.params.mask, this.rootImageFolder());
      this.mask = mask;
      return this.add(mask);
    };
    // * Если что-то было до готовности, нарисовать
    _._onReady = function() {
      this.drawGauge(this._lastValue);
    };
    _._drawGauge = function(percent) {
      if (this.fillLayer == null) {
        return;
      }
      this.fillLayer.clear();
      if (this.isVertical()) {
        return this._drawVerGauge(percent);
      } else {
        return this._drawHorGauge(percent);
      }
    };
    _._drawHorGauge = function(percent) {
      var w;
      w = this.fillBitmap.width * percent;
      return this.fillLayer.b().blt(this.fillBitmap, 0, 0, w, this.fillLayer.height, 0, 0);
    };
    _._drawVerGauge = function(percent) {
      var h, hy;
      h = this.fillBitmap.height * percent;
      hy = this.fillBitmap.height - h;
      this.fillLayer.b().blt(this.fillBitmap, 0, 0, this.fillLayer.width, h, 0, hy);
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {
    var Sprite_UIIcon;
    Sprite_UIIcon = class Sprite_UIIcon extends KDCore.UI.Sprite_UIElement {
      constructor() {
        super(...arguments);
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          index: 0,
          size: 32,
          rootImageFolder: null //?optional
        };
      }

      draw() {
        return this.drawIcon(...arguments);
      }

      drawIcon(index = 0, noSmoth = false) {
        this._lastValue = index;
        return this._drawIcon(index, noSmoth);
      }

    };
    KDCore.UI.Sprite_UIIcon = Sprite_UIIcon;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UIIcon.prototype;
    //$[OVER]
    _._createContent = function() {
      this._createIcon();
      return this._drawIcon(this.params.index);
    };
    _._createIcon = function() {
      this._icon = KDCore.Sprite.FromBitmap(this.params.size, this.params.size);
      this.add(this._icon);
      return this._onReady();
    };
    _._onReady = function() {
      return this.drawIcon(this._lastValue);
    };
    _._drawIcon = function(index, noSmoth = false) {
      this._icon.clear();
      if (KDCore.SDK.isString(index)) {
        this._drawImageIcon(index, noSmoth);
      } else {
        if (index <= 0) {
          return;
        }
        this._icon.drawIcon(0, 0, index, this.params.size, noSmoth);
      }
    };
    _._drawImageIcon = function(imageName, noSmoth = false) {
      return KDCore.Utils.loadImageAsync(this.rootImageFolder(), imageName).then((bitmap) => {
        return this._icon.drawIcon(0, 0, bitmap, this.params.size, noSmoth);
      });
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {
    var Sprite_UIImage;
    Sprite_UIImage = class Sprite_UIImage extends KDCore.UI.Sprite_UIElement {
      constructor() {
        super(...arguments);
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          image: "",
          rootImageFolder: null //?optional
        };
      }

      draw() {
        return this.drawImage(...arguments);
      }

      drawImage(image) {
        return this._drawImage(image);
      }

    };
    KDCore.UI.Sprite_UIImage = Sprite_UIImage;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UIImage.prototype;
    //$[OVER]
    _._createContent = function() {
      return this._drawImage(this.params.image);
    };
    _._drawImage = function(image) {
      this._clearImage();
      if (!String.isNullOrEmpty(image)) {
        this._image = KDCore.Sprite.FromImg(image, this.rootImageFolder());
        this.add(this._image);
      }
    };
    _._clearImage = function() {
      if (this._image == null) {
        return;
      }
      this._image.visible = false;
      this.removeChild(this._image);
      return this._image = null;
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {
    var Sprite_UIRect;
    Sprite_UIRect = class Sprite_UIRect extends KDCore.UI.Sprite_UIElement {
      constructor() {
        super(...arguments);
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          size: {
            w: 60,
            h: 20
          },
          fillColor: "#FFFFFF".toCss(),
          fillOpacity: 255,
          borderColor: "#000000".toCss(),
          borderThickness: 1,
          borderOpacity: 255
        };
      }

      draw() {
        return this.fill(...arguments);
      }

      fill(color, opacity = 255) {
        return this._fill(color, opacity);
      }

      drawBorder(color, thickness = 1, opacity = 255) {
        return this._drawBorder(color, thickness, opacity);
      }

    };
    KDCore.UI.Sprite_UIRect = Sprite_UIRect;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UIRect.prototype;
    //$[OVER]
    _._createContent = function() {
      if (String.any(this.params.fillColor)) {
        this._createFill();
        this.fill(this.params.fillColor, this.params.fillOpacity);
      }
      if (String.any(this.params.borderColor) && this.params.borderThickness > 0) {
        this._createBorder();
        return this.drawBorder(this.params.borderColor, this.params.borderThickness, this.params.borderOpacity);
      }
    };
    _._createFill = function() {
      this._fillSpr = KDCore.Sprite.FromBitmap(this.params.size.w, this.params.size.h);
      return this.addChild(this._fillSpr);
    };
    _._createBorder = function() {
      this._borderSprite = KDCore.Sprite.FromBitmap(this.params.size.w, this.params.size.h);
      return this.addChild(this._borderSprite);
    };
    _._fill = function(color, opacity) {
      if (this._fillSpr == null) {
        return;
      }
      this._fillSpr.fillAll(color);
      this._fillSpr.opacity = opacity;
    };
    _._drawBorder = function(color, thickness, opacity) {
      var b;
      if (this._borderSprite == null) {
        return;
      }
      this._borderSprite.clear();
      b = this._borderSprite.b();
      // * Top line
      b.fillRect(0, 0, b.width, thickness, color);
      // * Bottom line
      b.fillRect(0, b.height - thickness, b.width, thickness, color);
      // * Left line
      b.fillRect(0, 0, thickness, b.height, color);
      // * Right line
      b.fillRect(b.width - thickness, 0, thickness, b.height, color);
      return this._borderSprite.opacity = opacity;
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {    //NUI 1.0
    //rev 11.05.22

    //"type": "legacyText"
    var Sprite_UIText;
    Sprite_UIText = class Sprite_UIText extends KDCore.UI.Sprite_UIElement {
      constructor() {
        super(...arguments);
        if (String.any(this.params.text)) {
          this.drawText(this.params.text);
        }
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          size: {
            width: 60,
            height: 20
          },
          alignment: "center",
          font: {
            face: null,
            size: 18,
            italic: false
          },
          margins: {
            x: 0,
            y: 0
          },
          outline: {
            color: null,
            width: 2
          },
          textColor: "#ffffff",
          shadow: {
            color: "#000",
            opacity: 0,
            margins: {
              x: 1,
              y: 1
            }
          },
          text: ""
        };
      }

      // * For compatibility with old style configurations
      sizeWidth() {
        if (this.params.size.w != null) {
          return this.params.size.w;
        } else {
          if (this.params.size.width != null) {
            this.params.size.w = this.params.size.width;
            return this.params.size.width;
          }
        }
        return 0;
      }

      // * For compatibility with old style configurations
      sizeHeight() {
        if (this.params.size.h != null) {
          return this.params.size.h;
        } else {
          if (this.params.size.height != null) {
            this.params.size.h = this.params.size.height;
            return this.params.size.height;
          }
        }
        return 0;
      }

      realWidth() {
        if (this.isNotHaveBounds()) {
          return 0;
        }
        return this.sizeWidth();
      }

      realHeight() {
        if (this.isNotHaveBounds()) {
          return 0;
        }
        return this.sizeHeight();
      }

      dataBindings() {
        return Object.assign(super.dataBindings(), {
          text: function(v) {
            return this.drawText(v);
          },
          style: function(v) {
            return this.updateStyle(v);
          },
          width: function(v) {
            if (v != null) {
              return this.setSize(v, this.sizeHeight());
            }
          },
          height: function(v) {
            if (v != null) {
              return this.setSize(this.sizeWidth(), v);
            }
          },
          size: function(v) {
            if (v != null) {
              return this.setSize(v.width, v.height);
            }
          },
          textColor: function(v) {
            if (v != null) {
              return this.updateStyle({
                textColor: v
              });
            }
          },
          fontSize: function(v) {
            if (v != null) {
              return this.updateFontSize(v);
            }
          }
        });
      }

      setSize(w = 60, h = 20) {
        var e;
        try {
          w = this._getValueByStr(w, 'width', this);
          h = this._getValueByStr(h, 'height', this);
          return this.updateStyle({
            size: {
              w: w,
              h: h,
              width: w,
              height: h
            }
          });
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      updateStyle(newStyle) {
        var e;
        try {
          this.params = Object.assign({}, this.params, newStyle);
          this._destroyOldContent();
          this._createContent();
          // * Redraw Text
          return this.drawText(this._lastText || "");
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      updateFontSize(fontSize) {
        var e, font;
        try {
          font = Object.assign({}, this.params.font);
          if (typeof fontSize === "string") {
            fontSize = this._getValueByStr(fontSize, 'height', this);
          }
          font.size = fontSize;
          return this.updateStyle({font});
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      //?DYNAMIC
      // * Сперва рисуем по готовности, а как загрузился спрайт, меняем
      drawText(text) {
        var e;
        try {
          this.params.text = text;
          return this._drawTextWhenReady(text);
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      // * Сборка текста с учётом формата
      // * Заменить вхождения %1, %2 на значения параметров
      drawTextWithFormat(/*format string, arguments parameters... */) {
        var text;
        text = this._convertFormatedString(...arguments);
        this.drawText(text);
      }

      // * Пишет текст с определённым цветом (один раз)
      drawTextColor(text, colorCss) {
        if (this._textSpr == null) {
          return;
        }
        this._textSpr.b().textColor = colorCss;
        this.drawText(text);
        this._textSpr.b().textColor = this.params.textColor;
      }

    };
    KDCore.UI.Sprite_UIText = Sprite_UIText;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UIText.prototype;
    _._destroyOldContent = function() {
      var e, ref, ref1;
      try {
        if ((ref = this._shadowSpr) != null) {
          ref.removeFromParent();
        }
        return (ref1 = this._textSpr) != null ? ref1.removeFromParent() : void 0;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    //$[OVER]
    _._createContent = function() {
      if (this.params.shadow != null) {
        this._createShadow();
      }
      return this._createTextSprite();
    };
    _._createTextSprite = function() {
      this._textSpr = KDCore.Sprite.FromParams(this.params);
      this._textSpr.onReady(this._onReady.bind(this));
      return this.add(this._textSpr);
    };
    // * Выполнить по готовности
    _._onReady = function() {
      // * Переключить метод, так как уже готов
      this.drawText = this._drawText;
      // * Написать то что нужно было до готовности (если есть)
      if (this._drawOnReady == null) {
        return;
      }
      this.drawText(this._drawOnReady);
      this._drawOnReady = null;
    };
    _._drawText = function(text) {
      this._lastText = text;
      if (this._textSpr == null) {
        return;
      }
      this._textSpr.clear();
      if (text != null) {
        this._textSpr.drawTextFull(text);
      }
      if (this._shadowSpr != null) {
        this._shadowSpr.clear();
        if (text != null) {
          this._shadowSpr.drawTextFull(text);
        }
      }
    };
    // * Написать текст когда будет готов
    _._drawTextWhenReady = function(text) {
      this._drawOnReady = text;
      return this._drawText(text);
    };
    
    // * Заменить вхождения %1, %2 на значения параметров
    _._convertFormatedString = function(/*text, args...*/) {
      var e, i, j, ref, text;
      try {
        text = arguments[0];
        for (i = j = 1, ref = arguments.length; (1 <= ref ? j < ref : j > ref); i = 1 <= ref ? ++j : --j) {
          try {
            if (arguments[i] == null) {
              continue;
            }
            text = text.replace("%" + i, arguments[i]);
          } catch (error) {
            e = error;
            KDCore.warning(e);
            text = "[wrong format text input]";
          }
        }
        return text;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return "[wrong format text input]";
      }
    };
    _._createShadow = function() {
      this._shadowSpr = KDCore.Sprite.FromParams(this.params);
      this._shadowSpr.bitmap.textColor = this.params.shadow.color;
      this._shadowSpr.opacity = this.params.shadow.opacity;
      this._shadowSpr.x += this.params.shadow.margins.x;
      this._shadowSpr.y += this.params.shadow.margins.y;
      return this.add(this._shadowSpr);
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {    //NUI 1.0
    //rev 11.05.22
    var Sprite_UIText2;
    
      //"type": "text"
    Sprite_UIText2 = class Sprite_UIText2 extends KDCore.UI.Sprite_UIElement {
      constructor(params, userTextStyle) {
        super(params);
        this.userTextStyle = userTextStyle;
        this._applyParameters(params);
        this._createTextSprite();
        if (String.any(this.params.text)) {
          this.drawText(this.params.text);
        }
        return;
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          size: {
            width: 60,
            height: 20
          },
          alignment: "center",
          font: {
            face: null,
            size: 18,
            italic: false,
            bold: false,
            weight: 0 // * 0 - not used
          },
          margins: {
            x: 0,
            y: 0
          },
          outline: {
            color: null,
            width: 2
          },
          textColor: "#FFFFFF",
          shadow: {
            color: "#000",
            opacity: 0,
            margins: {
              x: 1,
              y: 1
            }
          },
          text: "",
          multiline: false,
          verticalCentered: true,
          actualSize: false
        };
      }

      // * For compatibility with old style configurations
      sizeWidth() {
        if (this.isNotHaveBounds()) {
          return 0;
        }
        if ((this._textSpr != null) && this.params.actualSize === true) {
          return this.getMetrics().width;
        }
        if (this.params.size.w != null) {
          return this.params.size.w;
        } else {
          if (this.params.size.width != null) {
            this.params.size.w = this.params.size.width;
            return this.params.size.width;
          }
        }
        return 0;
      }

      // * For compatibility with old style configurations
      sizeHeight() {
        if (this.isNotHaveBounds()) {
          return 0;
        }
        if ((this._textSpr != null) && this.params.actualSize === true) {
          return this.getMetrics().height;
        }
        if (this.params.size.h != null) {
          return this.params.size.h;
        } else {
          if (this.params.size.height != null) {
            this.params.size.h = this.params.size.height;
            return this.params.size.height;
          }
        }
        return 0;
      }

      dataBindings() {
        return Object.assign(super.dataBindings(), {
          text: function(v) {
            return this.drawText(v);
          },
          style: function(v) {
            if (v != null) {
              return this.updateStyle(v);
            }
          },
          width: function(v) {
            if (v != null) {
              return this.setSize(v, this.sizeHeight());
            }
          },
          height: function(v) {
            if (v != null) {
              return this.setSize(this.sizeWidth(), v);
            }
          },
          size: function(v) {
            if (v != null) {
              return this.setSize(v.width, v.height);
            }
          },
          textColor: function(v) {
            if (v != null) {
              return this.updateStyle({
                textColor: v
              });
            }
          },
          fontSize: function(v) {
            if (v != null) {
              return this.updateFontSize(v);
            }
          }
        });
      }

      realWidth() {
        return this.sizeWidth();
      }

      realHeight() {
        return this.sizeHeight();
      }

      setSize(w = 60, h = 20) {
        var e;
        try {
          w = this._getValueByStr(w, 'width', this);
          h = this._getValueByStr(h, 'height', this);
          return this.updateStyle({
            size: {
              w: w,
              h: h
            }
          });
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      defaultStyle() {
        return {};
      }

      drawText(text) {
        if (text == null) {
          text = "";
        }
        this.params.text = text;
        this._drawText(text);
      }

      // * Сборка текста с учётом формата
      // * Заменить вхождения %1, %2 на значения параметров
      drawTextWithFormat(/*format string, arguments parameters... */) {
        var text;
        text = this._convertFormatedString(...arguments);
        this.drawText(text);
      }

      // * Пишет текст с определённым цветом (один раз)
      drawTextColor(text, colorCss = "#FFF") {
        if (this._textSpr == null) {
          return;
        }
        this.updateStyle({
          textColor: colorCss
        });
        this.drawText(text);
      }

      updateFontSize(fontSize) {
        var e, font;
        try {
          font = Object.assign({}, this.params.font);
          if (typeof fontSize === "string") {
            fontSize = this._getValueByStr(fontSize, 'height', this);
          }
          font.size = fontSize;
          return this.updateStyle({font});
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      updateStyle(newStyleInOldFormat = {}, newStyleInNewFormat = {}) {
        var e;
        try {
          this.textStyle = this._convertOldStyle(newStyleInOldFormat, newStyleInNewFormat);
          this._textSpr.style = this.textStyle;
          // * Redraw Text
          return this.drawText(this._textSpr.text);
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }

      getMetrics() {
        return PIXI.TextMetrics.measureText(this._textSpr.text, this._textSpr.style);
      }

    };
    KDCore.UI.Sprite_UIText2 = Sprite_UIText2;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UIText2.prototype;
    _._applyParameters = function(params) {
      var e;
      try {
        return this.textStyle = this._convertOldStyle(params, {});
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._convertOldStyle = function(params = {}, style = {}) {
      var _textStyle, color, e, margins, opacity;
      try {
        this.params = Object.assign({}, this.params, params);
        _textStyle = Object.assign({}, this.defaultStyle(), this.userTextStyle, style);
        if (String.any(this.params.font.face)) {
          _textStyle.fontFamily = this.params.font.face;
        }
        _textStyle.fontSize = this.params.font.size;
        if (this.params.font.italic === true) {
          _textStyle.fontStyle = 'italic';
        }
        if (this.params.font.bold === true) {
          _textStyle.fontWeight = 'bold';
        }
        if ((this.params.font.weight != null) && this.params.font.weight > 0) {
          _textStyle.fontWeight = this.params.font.weight;
        }
        if (String.any(this.params.outline.color) && this.params.outline.width > 0) {
          _textStyle.stroke = this.params.outline.color;
          _textStyle.strokeThickness = this.params.outline.width;
        }
        _textStyle.fill = this.params.textColor;
        if ((this.params.shadow != null) && this.params.shadow.opacity > 0) {
          ({color, opacity, margins} = this.params.shadow);
          _textStyle.dropShadow = true;
          _textStyle.dropShadowAngle = margins.y;
          _textStyle.dropShadowColor = color;
          _textStyle.dropShadowDistance = margins.x;
          _textStyle.dropShadowAlpha = opacity / 255.0;
        }
        if (this.params.multiline === true) {
          _textStyle.align = this.params.alignment || 'left';
          _textStyle.wordWrap = true;
          if (this.params.font.size != null) {
            _textStyle.lineHeight = this.params.font.size + 2;
          }
          if (this.sizeWidth() > 0) {
            _textStyle.wordWrapWidth = this.sizeWidth();
          }
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return _textStyle;
    };
    _._createTextSprite = function() {
      var style;
      style = new PIXI.TextStyle(this.textStyle);
      this._textSpr = new PIXI.Text('', style);
      this.add(this._textSpr);
      if (this._needToDrawText != null) {
        this.draw(this._needToDrawText);
        this._needToDrawText = null;
      }
    };
    _._drawText = function(text) {
      var e, h, height, maxLineWidth, textMetrics, w;
      if (this._textSpr == null) {
        this._needToDrawText = text;
        return;
      }
      this._textSpr.text = text;
      if (this.params.size.height != null) {
        this.params.size.h = this.params.size.height;
      }
      if (this.params.size.width != null) {
        this.params.size.w = this.params.size.width;
      }
      ({w, h} = this.params.size);
      try {
        if (typeof text !== "string") {
          text = String(text);
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
        text = "[wrong text input]";
      }
      textMetrics = PIXI.TextMetrics.measureText(text, this._textSpr.style);
      ({height, maxLineWidth} = textMetrics);
      if (this.params.verticalCentered === true) {
        this._textSpr.y = (h - height) / 2;
      } else {
        this._textSpr.y = 0;
      }
      if (this.params.alignment === 'center') {
        this._textSpr.x = (w - maxLineWidth) / 2;
      } else if (this.params.alignment === 'right') {
        this._textSpr.x = w - maxLineWidth;
      } else {
        this._textSpr.x = 0;
      }
      this._textSpr.x += this.params.margins.x;
      this._textSpr.y += this.params.margins.y;
    };
    // * Заменить вхождения %1, %2 на значения параметров
    _._convertFormatedString = function(/*text, args...*/) {
      var e, i, j, ref, text;
      try {
        text = arguments[0];
        for (i = j = 1, ref = arguments.length; (1 <= ref ? j < ref : j > ref); i = 1 <= ref ? ++j : --j) {
          try {
            if (arguments[i] == null) {
              continue;
            }
            text = text.replace("%" + i, arguments[i]);
          } catch (error) {
            e = error;
            KDCore.warning(e);
            text = "[wrong format text input]";
          }
        }
        return text;
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return "[wrong format text input]";
      }
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {    //TODO: NOT USED IN NUI 1.0
    //NUI 1.X !#!
    //rev 03.05.22

    //"type": "textExt"
    var Sprite_UITextExt;
    Sprite_UITextExt = class Sprite_UITextExt extends KDCore.UI.Sprite_UIText {
      constructor() {
        super(...arguments);
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          size: {
            width: 200,
            height: 60
          },
          font: {
            face: null,
            size: 14,
            italic: false
          },
          margins: {
            x: 0,
            y: 0
          },
          // * новые параметры (KDCore 2.7)
          //?null могут быть
          singleLine: false,
          forceCentered: false
        };
      }

      //$[OVER]
      // * Данный метод не поддерживается, так как тут основа не Sprite, а Window
      drawTextColor() {
        return this.drawText(...arguments);
      }

    };
    KDCore.UI.Sprite_UITextExt = Sprite_UITextExt;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UITextExt.prototype;
    //$[OVER]
    _._destroyOldContent = function() {
      var e;
      try {
        if (this._textSpr == null) {
          return;
        }
        return this.removeChild(this._textSpr);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    //$[OVER]
    _._createTextSprite = function() {
      var rect;
      rect = new Rectangle(0, 0, this.sizeWidth(), this.sizeHeight());
      this._textSpr = new KDCore.Window_ExtTextLineBase(rect, this.params.font, this.params);
      this._textSpr.x = this.params.margins.x || 0;
      this._textSpr.y = this.params.margins.y || 0;
      this.add(this._textSpr);
      // * На следующий кадр, чтобы не было потери текста (опасно)
      setTimeout((() => {
        var e;
        try {
          return this._onReady();
        } catch (error) {
          e = error;
          return KDCore.warning(e);
        }
      }), 10);
      this._onReady(); // * Сразу
    };
    
    //$[OVER]
    _._drawText = function(text) {
      this._lastText = text;
      if (this._textSpr == null) {
        return;
      }
      this._textSpr.contents.clear();
      if (this.params.forceCentered === true) {
        this._textSpr.drawTextExInCenter(text, 0, 0, this._textSpr.width, this._textSpr.height);
      } else {
        if (this.params.singleLine === true) {
          this._textSpr.drawTextEx(text, 0, 0, this._textSpr.width);
        } else {
          // * По умолчанию
          this._textSpr.drawTextExWithWordWrap(text, 0, 0, this._textSpr.width);
        }
      }
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {
    var Sprite_UITextWithBack;
    Sprite_UITextWithBack = class Sprite_UITextWithBack extends KDCore.UI.Sprite_UIElement {
      constructor() {
        super(...arguments);
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          text: {
            visible: true,
            size: {
              w: 60,
              h: 20
            },
            alignment: "center",
            font: {
              face: null,
              size: 18,
              italic: false
            },
            margins: {
              x: 0,
              y: 0
            },
            outline: {
              color: null,
              width: 2
            },
            textColor: "#000000".toCss()
          },
          rect: {
            visible: true,
            size: {
              w: 60,
              h: 20
            },
            fillColor: "#FFFFFF".toCss(),
            fillOpacity: 255,
            borderColor: "#000000".toCss(),
            borderThickness: 1,
            borderOpacity: 255
          },
          textMargins: {
            x: 0,
            y: 0
          }
        };
      }

      draw() {
        return this.drawText(...arguments);
      }

      // * Aргументы смотри в Sprite_UIText
      drawText() {
        return this.text.draw(...arguments);
      }

      drawTextColor() {
        return this.text.drawTextColor(...arguments);
      }

      // * Аргументы смотри в Sprite_UIRect
      fill() {
        return this.rect.fill(...arguments);
      }

      drawBorder() {
        return this.rect.drawBorder(...arguments);
      }

      //$[OVER]
      isUnderMouse() {
        return this.rect.isUnderMouse();
      }

    };
    KDCore.UI.Sprite_UITextWithBack = Sprite_UITextWithBack;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UITextWithBack.prototype;
    //$[OVER]
    _._createContent = function() {
      this._createRect();
      return this._createText();
    };
    _._createRect = function() {
      this.rect = new KDCore.UI.Sprite_UIRect(this.params.rect);
      return this.addChild(this.rect);
    };
    _._createText = function() {
      var x, y;
      this.text = new KDCore.UI.Sprite_UIText(this.params.text);
      ({x, y} = this.params.textMargins);
      this.text.move(x, y);
      return this.addChild(this.text);
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {
    var Sprite_UIColorGauge;
    Sprite_UIColorGauge = class Sprite_UIColorGauge extends KDCore.UI.Sprite_UIGauge {
      constructor() {
        super(...arguments);
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          size: {
            w: 100,
            h: 40
          },
          fill: "#FFFFFF", // * В отличии от Gauge, тут цвет, а не картинка
          foreground: "", // картинка
          mask: "", // картинка
          backColor: "#000000".toCss(),
          backOpacity: 255,
          vertical: false,
          rootImageFolder: null //?optional
        };
      }

    };
    KDCore.UI.Sprite_UIColorGauge = Sprite_UIColorGauge;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UIColorGauge.prototype;
    //$[OVER]
    // * Заместо изображения используем простой Bitmap с заливкой цвета
    _._loadFillImage = function() {
      var fillBitmap;
      fillBitmap = new Bitmap(this.params.size.w, this.params.size.h);
      fillBitmap.fillAll(this.params.fill);
      this._createParts(fillBitmap);
    };
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  (function() {    // * Данный UI Элемент является только контейнером
    // * Он ничего не рисует, нужно добавлять в него
    // * контент методом addContent

    //rev 17.11.22
    var Sprite_UITooltip;
    Sprite_UITooltip = class Sprite_UITooltip extends KDCore.UI.Sprite_UIElement {
      constructor() {
        super(...arguments);
        this.opacity = 0;
      }

      isTooltipActive() {
        return (this._opThread != null) || (this._opChanger != null) || this.opacity > 0;
      }

      activateTooltip(x, y, parent) {
        if (this.isTooltipActive()) {
          return;
        }
        this.deactivateTooltip();
        this.move(x, y);
        this._opThread = new KDCore.TimedUpdate(this.params.delay, this.showTooltip.bind(this));
        if (!this.params.isGlobal && (parent != null)) {
          parent.addChild(this);
        } else {
          // * Always on Top on Scene  (if Global)
          SceneManager._scene.addChild(this);
        }
      }

      deactivateTooltip() {
        this._opThread = null;
        this._opChanger = null;
        return this.opacity = 0;
      }

      showTooltip() {
        this._opThread = null;
        this.appear(this.params.opacityChangeStep);
        if (this.params.cursorRelative === true) {
          return this.toCursor();
        }
      }

      update() {
        var ref;
        super.update();
        if ((ref = this._opThread) != null) {
          ref.update();
        }
        if (this.isTooltipActive() && this.params.cursorRelative === true) {
          return this.toCursor();
        }
      }

      // * Стандартный набор настроек
      defaultParams() {
        return {
          visible: true,
          delay: 30,
          opacityChangeStep: 35,
          margins: {
            x: 8,
            y: 8
          },
          isGlobal: true,
          cursorRelative: true
        };
      }

      toCursor() {
        var x, y;
        ({x, y} = this.params.margins);
        return this.move(TouchInput.x + x, TouchInput.y + y);
      }

      // * Основной метод, нужно добавить контент
      addContent(content) {
        return this.add(content);
      }

    };
    KDCore.UI.Sprite_UITooltip = Sprite_UITooltip;
  })();
  return (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = KDCore.UI.Sprite_UITooltip.prototype;
  })();
});

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var ALIAS__processEscapeCharacter, _;
  //@[DEFINES]
  _ = Window_Base.prototype;
  //@[ALIAS]
  ALIAS__processEscapeCharacter = _.processEscapeCharacter;
  _.processEscapeCharacter = function(code, textState) {
    switch (code) {
      case 'CHEX':
        this.pProcessColorChangeHex(this.pObtainEscapeParamHexColor(textState));
        break;
      case 'ISZ':
        this.pProcessDrawIconSized(this.pObtainEscapeParamIconArr(textState), textState);
        break;
      case 'PSZ':
        this.pProcessDrawPictureSized(this.pObtainEscapeParamImgArr(textState), textState, false);
        break;
      case 'PSB':
        this.pProcessDrawPictureSized(this.pObtainEscapeParamImgArr(textState), textState, true);
        break;
      default:
        ALIAS__processEscapeCharacter.call(this, code, textState);
    }
  };
  //?NEW
  _.pObtainEscapeParamHexColor = function(textState) {
    var arr, regExp, textPart;
    regExp = /^\[(#?([0-9a-fA-F]{2}){3}|([0-9a-fA-F]){3})\]/;
    textPart = textState.text.slice(textState.index);
    arr = regExp.exec(textPart);
    if (arr != null) {
      textState.index += arr[0].length;
      return arr[1];
    } else {
      return "";
    }
  };
  //?NEW
  _.pObtainEscapeParamIconArr = function(textState) {
    var arr, params, regExp, textPart;
    regExp = /^\[(\d+,\s*\d+,\s*-?\d+,\s*-?\d+)\]/;
    textPart = textState.text.slice(textState.index);
    arr = regExp.exec(textPart);
    if (arr != null) {
      textState.index += arr[0].length;
      if (arr[1] != null) {
        params = arr[1].split(",").map(function(i) {
          return parseInt(i.trim());
        });
        return params;
      }
    }
    return [];
  };
  //?NEW
  _.pObtainEscapeParamImgArr = function(textState) {
    var arr, params, regExp, textPart;
    regExp = /^\[(\w+,\s*\d+,\s*\d+,\s*-?\d+,\s*-?\d+)\]/;
    textPart = textState.text.slice(textState.index);
    arr = regExp.exec(textPart);
    if (arr != null) {
      textState.index += arr[0].length;
      if (arr[1] != null) {
        params = arr[1].split(",").map(function(i) {
          if (isFinite(i)) {
            return parseInt(i.trim());
          } else {
            return i;
          }
        });
        return params;
      }
    }
    return [];
  };
  //?NEW
  _.pProcessColorChangeHex = function(colorHex) {
    var e;
    try {
      this.changeTextColor(colorHex);
    } catch (error) {
      e = error;
      KDCore.warning(e);
      this.resetTextColor();
    }
  };
  //?NEW
  //?params: [INDEX, SIZE, DX, DY]
  _.pProcessDrawIconSized = function(params, textState) {
    var dx, dy, e, iconIndex, size, staticMargin, x, y;
    try {
      if (params == null) {
        return;
      }
      if (params.isEmpty()) {
        return;
      }
      size = params[1];
      if (params[1] == null) {
        if (KDCore.isMZ()) {
          size = ImageManager.iconWidth;
        } else {
          size = Window_Base._iconWidth;
        }
      }
      if (params[2] == null) {
        params[2] = 0;
      }
      if (params[3] == null) {
        params[3] = 0;
      }
      iconIndex = params[0];
      dx = params[2];
      dy = params[3];
      staticMargin = 2;
      x = textState.x + staticMargin + dx;
      y = textState.y + staticMargin + dy;
      if (KDCore.isMZ()) {
        if (textState.drawing === true) {
          // * Только в режиме рисования
          this.contents.drawIcon(x, y, iconIndex, size);
        }
      } else {
        this.contents.drawIcon(x, y, iconIndex, size);
      }
      textState.x += size + (staticMargin * 2) + dx;
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
  };
  //?NEW
  //?params: [NAME, W, H, DX, DY]
  _.pProcessDrawPictureSized = function(params, textState, isUnderText = false) {
    var drawBitmap, drawProcess, e, height, name, source, width, x, y;
    try {
      if (params == null) {
        return;
      }
      if (params.isEmpty()) {
        return;
      }
      name = params[0];
      if (!String.any(name)) {
        return;
      }
      width = params[1];
      height = params[2];
      if (params[3] == null) {
        params[3] = 0;
      }
      if (params[4] == null) {
        params[4] = 0;
      }
      x = textState.x + 2 + params[3];
      y = textState.y + 2 + params[4];
      drawBitmap = this.contents;
      source = this.pGetSourceImageForDrawPictureSized(name);
      if ((KDCore.isMZ() && textState.drawing === true) || KDCore.isMV()) {
        drawProcess = function() {
          var e;
          try {
            if (drawBitmap == null) {
              return;
            }
            return drawBitmap.drawOnMe(source, x, y, width, height);
          } catch (error) {
            e = error;
            return KDCore.warning(e);
          }
        };
        source.addLoadListener(drawProcess);
      }
      if (isUnderText !== true) {
        // * Вариант, что текст не будет "перескакивать" за ширину картинки а пойдёт поверх (т.е. фоновая картинка)
        // * Если картине не preload, то может "вылезти" на текст потом, так как рисоваться будет позже
        textState.x += width + 4 + params[3];
      }
    } catch (error) {
      e = error;
      KDCore.warning(e);
    }
  };
  // * Данный метод вынесен отдельно, чтобы можно было переопределять папки
  return _.pGetSourceImageForDrawPictureSized = function(name) {
    return ImageManager.loadPicture(name);
  };
});


// Generated by CoffeeScript 2.6.1



// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var FloatingWindow;
  
    // * Общий класс для всех окон на карте
  /*parameters
      {
          draggable: true,
          closeButton: true,
          moveToCenter: true,
          alwaysOnTop: true,
          header: true
      }
  */
  FloatingWindow = class FloatingWindow extends KDCore.Sprite {
    constructor(mainParent, windowW, windowH, parameters) {
      super();
      this.mainParent = mainParent;
      this.windowW = windowW;
      this.windowH = windowH;
      this.parameters = parameters;
      this._init();
      return;
    }

    static StaticSettings() {
      return {
        draggable: false,
        closeButton: false,
        moveToCenter: false,
        alwaysOnTop: false,
        header: false
      };
    }

    // * Статическое окно с дочерним
    static StaticWindow(parent, sub) {
      var p, w;
      p = KDCore.FloatingWindow.StaticSettings();
      w = new KDCore.FloatingWindow(parent, sub.width, sub.height, p);
      w.setSubWindow(sub);
      w.open();
      return w;
    }

    isActive() {
      return this.visible === true;
    }

    isReady() {
      return this._isReady === true;
    }

    isMouseIn() {
      return this.inPosition(TouchInput);
    }

    isOpen() {
      return this.isActive();
    }

    // * Дочернее окно (если есть)
    sub() {
      return this._subw;
    }

    setOnReadyHandler(_readyHandler) {
      this._readyHandler = _readyHandler;
      if ((this._readyHandler != null) && this._isReady === true) {
        return this._readyHandler();
      }
    }

    isDraggable() {
      return this._isDraggable === true && (this._headerSpr != null) && this._headerSpr.visible === true && this.isOpen();
    }

    setCloseHandler(_closeHandler) {
      this._closeHandler = _closeHandler;
    }

    callCloseHandler() {
      if (this._closeHandler != null) {
        return this._closeHandler();
      }
    }

    setDraggingHandler(_dragHandler) {
      this._dragHandler = _dragHandler;
    }

    setDragEndHandler(_dragEndHandler) {
      this._dragEndHandler = _dragEndHandler;
    }

    hideHeader() {} //TODO:

    hideCloseButton() {} //TODO:

    
      // * Сдвиг заголовка по X, чтобы рамку не задевал
    headerMarginX() {
      return 2;
    }

    // * Сдвиг заголовка по Y, чтобы рамку не задевал
    headerMarginY() {
      return 0;
    }

    // * Стандартная позиция кнопки "закрыть"
    closeButtonPosition() {
      return {
        x: this.width - 24,
        y: 4
      };
    }

    open() {
      if (this.isOpen()) {
        return;
      }
      this._open();
      this._afterOpen();
    }

    close() {
      if (!this.isOpen()) {
        return;
      }
      this._close();
      this._afterClose();
    }

    rootImageFolder() {
      return "Alpha/Windows";
    }

    update() {
      super.update();
      this._updateMouseCheckThread();
      this._updateDragging();
    }

    // * Добавить спрайт на специальный слой контента
    addContent(sprite) {
      return this._contentLayer.addChild(sprite);
    }

    // * Добавить дочернее окно
    setSubWindow(w) {
      this._subw = w;
      this.addContent(w);
    }

    destroy() {
      this._close();
      return Sprite.prototype.destroy.call(this);
    }

  };
  (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ PRIVATE.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    //@[DEFINES]
    _ = FloatingWindow.prototype;
    _._init = function() {
      var ref;
      // * Окно всегда закрыто
      this.visible = false;
      // * Контент прогрузился?
      this._isReady = false;
      this._applyParameters();
      if (this._isAlwaysOnTop === false) {
        // * Если не всегда поверх окон, то добавляем сразу к родителю (один раз)
        if ((ref = this.mainParent) != null) {
          ref.addChild(this);
        }
      }
      this._initFloatingSystem();
      this._createLayers();
      this._loadWindowFrame();
    };
    // * Тут ничего не создавать, не двигать, так как
    // * конент создаётся Async, см. метод _createCustomElements
    _._applyParameters = function() {
      var p;
      this._applyDefaults();
      if (this.parameters == null) {
        return;
      }
      p = this.parameters;
      if (p.draggable != null) {
        this._isDraggable = p.draggable;
      }
      if (p.moveToCenter != null) {
        this._isMoveToCenter = p.moveToCenter;
      }
      if (p.header != null) {
        this._isHeaderVisible = p.header;
      }
      if (p.closeButton != null) {
        this._isHaveCloseButton = p.closeButton;
      }
      if (p.alwaysOnTop != null) {
        this._isAlwaysOnTop = p.alwaysOnTop;
      }
    };
    _._applyDefaults = function() {
      // * Окно можно перетаскивать мышкой (по умолчанию - да)
      this._isDraggable = true;
      this._isMoveToCenter = true;
      this._isHeaderVisible = true;
      this._isHaveCloseButton = true;
      this._isAlwaysOnTop = true;
    };
    _._initFloatingSystem = function() {
      if ($gameTemp._floatingWindows == null) {
        // * Создаём массив окон, он нужен для правильного
        // закрытия окон (по очереди) и перемещения drag and drop
        // с учётом верхнего окна
        $gameTemp._floatingWindows = [];
      }
      // * Вспомогательная переменная, чтобы не вызывать методы каждый кадр
      this._mouseIn = false;
      // * Тоже вспомогательная переменная
      this._dragging = false;
    };
    _._moveToStartPosition = function() {
      if (this._isMoveToCenter === true) {
        return this.moveToCenter(Graphics.width / 2, Graphics.height / 2);
      }
    };
    _._closeButtonClick = function() {
      // * При исчезании, кнопка не успевает себя "удалить"
      $gameTemp.kdButtonUnderMouse = null;
      this.callCloseHandler();
      return this.close();
    };
    (function() {      // * DRAGGING
      // -----------------------------------------------------------------------
      _._updateDragging = function() {
        if (!this.isDraggable()) {
          return;
        }
        // * Если мы уже двигаем окно, но мышка вышла за границы, то можно дальше двигать
        // * Только если мышка не в окне и не двигали ранее, то не проверяем
        if (this._mouseIn === false && this._dragging === false) {
          return;
        }
        // * Если существует объект который сейчас dragging
        if ($gameTemp.pkdDraggableInstance != null) {
          // * Если этот объект не этот объект, то выходим из метода
          if ($gameTemp.pkdDraggableInstance !== this) {
            return;
          }
        }
        if (TouchInput.isLongPressed()) {
          if (this._dragging === false) {
            this._onDragStart();
          } else {
            this._onDragging();
          }
        } else {
          this._stopDragging();
        }
      };
      _._onDragStart = function() {
        // * Проверка, в области Header или нет
        if (!this._isMouseInHeader()) {
          return;
        }
        // * Разница в координатах курсора и объекта, чтобы убрать эффект "прыжка"
        this.opacity = 200;
        this._deltaXY = this.getDeltaXY();
        this._dragging = true;
        // * Устанавливаем глобальную ссылку на объект перемещения
        $gameTemp.pkdDraggableInstance = this;
      };
      _.getDeltaXY = function() {
        var p;
        p = new KDCore.Point(this.x, this.y);
        return p.delta(TouchInput);
      };
      _._onDragging = function() {
        // * Защита от перетаскивания за края экрана
        if (!this._isNewMousePositionOnScreen()) {
          return;
        }
        this.move(TouchInput.x - this._deltaXY.x, TouchInput.y - this._deltaXY.y);
        if (this._dragHandler != null) {
          return this._dragHandler();
        }
      };
      _._stopDragging = function() {
        if (this._dragging === true) {
          this._dragging = false;
          this.opacity = 255;
          this._clearDraggableGlocalInstance();
          if (this._dragEndHandler != null) {
            this._dragEndHandler();
          }
        }
      };
      // * Освобождаем глобальную ссылку
      _._clearDraggableGlocalInstance = function() {
        if ($gameTemp.pkdDraggableInstance === this) {
          return $gameTemp.pkdDraggableInstance = null;
        }
      };
      _._isMouseInHeader = function() {
        if (this._headerSpr == null) {
          return false;
        }
        return this._headerSpr.isContainsPoint(TouchInput);
      };
      _._isNewMousePositionOnScreen = function() {
        return KDCore.Utils.isPointInScreen(TouchInput, 10);
      };
    })();
    (function() {      // -----------------------------------------------------------------------

      // * CREATE ELEMENTS
      // -----------------------------------------------------------------------
      
      // * Слои нужны, так как изображения загружаються асинхронно
      _._createLayers = function() {
        this._mainLayer = new Sprite();
        this._contentLayer = new Sprite();
        this._headerLayer = new Sprite();
        this._closeButtonLayer = new Sprite();
        this.addChild(this._mainLayer);
        this.addChild(this._contentLayer);
        this.addChild(this._headerLayer);
        this.addChild(this._closeButtonLayer);
      };
      _._loadWindowFrame = function() {
        return KDCore.Utils.loadImageAsync(this.rootImageFolder(), "windowFrame").then(this._createWindow.bind(this));
      };
      _._createWindow = function(frameImage) {
        this.bitmap = new Bitmap(this.windowW, this.windowH);
        this.wFrame = new KDCore.Sprite_TilingFrame(this.windowW, this.windowH, frameImage);
        this._mainLayer.addChild(this.wFrame);
        this._createParts();
      };
      _._createParts = function() {
        this._loadHeader();
        if (this._isHaveCloseButton === true) {
          this._createCloseButton();
        }
        this._moveToStartPosition();
        this._createCustomElements();
        // * Окно готово
        this._isReady = true;
        if (this._readyHandler != null) {
          this._readyHandler();
        }
      };
      _._loadHeader = function() {
        return KDCore.Utils.loadImageAsync(this.rootImageFolder(), "headerLine").then(this._createHeader.bind(this));
      };
      _._createHeader = function(headerLineImage) {
        var w;
        w = this.windowW - (this.headerMarginX() * 2);
        this._headerSpr = new KDCore.Sprite_TilingLine(w, headerLineImage.height, headerLineImage);
        this._headerSpr.x = this.headerMarginX();
        this._headerSpr.y = this.headerMarginY();
        this._headerLayer.addChild(this._headerSpr);
        if (this._isHeaderVisible === true) {
          // * Сдвигаем контент, чтобы было начало под заголовком
          this._contentLayer.y += headerLineImage.height + this.headerMarginY();
        } else {
          this._headerSpr.visible = false;
        }
      };
      _._createCloseButton = function() {
        this._closeButton = new KDCore.ButtonM("windowCloseButton", false, this.rootImageFolder());
        this._closeButtonLayer.addChild(this._closeButton);
        this._closeButton.move(this.closeButtonPosition());
        this._closeButton.addClickHandler(this._closeButtonClick.bind(this));
      };
      //%[FOR CHILDRENS]
      // * Наследники создают свои элементы в этом методе
      // * Есть специальный метод addContent()
      _._createCustomElements = function() {}; // * EMPTY
    })();
    (function() {      // -----------------------------------------------------------------------

      // * MOUSE
      // -----------------------------------------------------------------------
      
      // * Определение если мышка в области окна
      //TODO: Есть проблема при открытии окна сразу под курсором
      _._registerMouseInOut = function() {
        if (!this.isOpen()) {
          return;
        }
        if (this.isMouseIn()) {
          if (this._mouseIn === false) {
            this._mouseIn = true;
            this._onMouseIn();
          }
        } else {
          if (this._mouseIn === true) {
            this._mouseIn = false;
            this._onMouseOut();
          }
        }
      };
      // * Используется похожая система что и в KDCore.ButtonM
      _._onMouseIn = function() {
        return $gameTemp.floatingWindowUnderMouse = this;
      };
      _._onMouseOut = function() {
        if ($gameTemp.floatingWindowUnderMouse === this) {
          return $gameTemp.floatingWindowUnderMouse = null;
        }
      };
      // * Будем проверять мышка ли в окне только при открытом окне
      _._createMouseCheckThread = function() {
        this._mouseCheckThread = new KDCore.TimedUpdate(1, this._registerMouseInOut.bind(this));
        this._updateMouseCheckThread = () => {
          return this._mouseCheckThread.update();
        };
        return this._mouseCheckThread.call();
      };
      // * Когда окно закрывается, никаких проверок, обнуляем метод
      _._destroyMouseCheckThread = function() {
        this._mouseCheckThread = null;
        return this._updateMouseCheckThread = function() {};
      };
      //?DYNAMIC
      _._updateMouseCheckThread = function() {}; // * EMPTY
    })();
    (function() {      // -----------------------------------------------------------------------

      // * OPEN OR CLOSE
      // -----------------------------------------------------------------------
      _._open = function() {
        var ref, ref1;
        this.visible = true;
        if ((ref = $gameTemp._floatingWindows) != null) {
          ref.push(this);
        }
        if (this._isAlwaysOnTop === true) {
          // * Окно, которое открывается, всегда снова выше остальных (опция)
          if ((ref1 = this.mainParent) != null) {
            ref1.addChild(this);
          }
        }
        return this._createMouseCheckThread();
      };
      _._afterOpen = function() {}; // * EMPTY
      _._close = function() {
        this.visible = false;
        if (this._isAlwaysOnTop === true) {
          this.removeFromParent();
        }
        this._clearDraggableGlocalInstance();
        $gameTemp._floatingWindows.delete(this);
        this._onMouseOut();
        return this._destroyMouseCheckThread();
      };
      _._afterClose = function() {}; // * EMPTY
    })();
  })();
  (function() {    // ■ END PRIVATE.coffee
    //---------------------------------------------------------------------------

    // * Если окно под курсором, нельзя нажимать на карте для движения игрока
    // -----------------------------------------------------------------------
    (function() {      //╒═════════════════════════════════════════════════════════════════════════╛
      // ■ Scene_Map.coffee
      //╒═════════════════════════════════════════════════════════════════════════╛
      //---------------------------------------------------------------------------
      var ALIAS__isAnyButtonPressed, ALIAS__processMapTouch, _;
      
      //@[DEFINES]
      _ = Scene_Map.prototype;
      if (KDCore.isMZ()) {
        //@[ALIAS]
        ALIAS__isAnyButtonPressed = _.isAnyButtonPressed;
        _.isAnyButtonPressed = function() {
          if ($gameTemp.floatingWindowUnderMouse != null) {
            return true;
          } else {
            return ALIAS__isAnyButtonPressed.call(this);
          }
        };
      } else {
        //@[ALIAS]
        ALIAS__processMapTouch = _.processMapTouch;
        _.processMapTouch = function() {
          if ($gameTemp.floatingWindowUnderMouse != null) {
            return;
          }
          return ALIAS__processMapTouch.call(this);
        };
      }
    })();
  })();
  //@[EXTEND]
  // ■ END Scene_Map.coffee
  //---------------------------------------------------------------------------
  return KDCore.FloatingWindow = FloatingWindow;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var HUI;
  // * Html UI Manager
  // * Набор инструментов для работы с HTML элементами интерфейса
  HUI = function() {};
  (function() {
    var _;
    //@[DEFINES]
    _ = HUI;
    _.init = function() {
      // * Данный набор инструментов могут использовать многие плагины, поэтому проверка
      if (this.isInited()) {
        return;
      }
      this._createMainParentInHtml();
      this._extendGraphicsClass();
      this.refresh();
    };
    // * Был ли создан (инициализирован) основной элемент
    _.isInited = function() {
      return this.parent() != null;
    };
    // * Основной элемент родитель для всех элементов UI
    _.parent = function() {
      return this._parent;
    };
    _.refresh = function() {
      if (!this.isInited()) {
        return;
      }
      Graphics._centerElement(this._parent);
      this._parent.style.zIndex = 2;
      this._parent.style.width = Graphics._canvas.style.width;
      this._parent.style.height = Graphics._canvas.style.height;
    };
    _.initReactComponents = function(withBabel = true) {
      var e;
      try {
        if (withBabel) {
          this._loadBabel();
        }
        return this._loadReact();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._loadBabel = function() {
      var e;
      try {
        return this._loadScript('https://unpkg.com/babel-standalone@6/babel.min.js');
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._loadReact = function() {
      var e;
      try {
        this._loadScript('https://unpkg.com/react@18/umd/react.production.min.js');
        return this._loadScript('https://unpkg.com/react-dom@18/umd/react-dom.production.min.js');
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._loadScript = function(src, isReact = false) {
      var e, script;
      try {
        script = document.createElement("script");
        if (isReact === true) {
          script.type = "text/babel";
        } else {
          script.type = "text/javascript";
          script.crossorigin = true;
        }
        script.src = src;
        script.async = false;
        script.defer = true;
        script.onerror = function(e) {
          KDCore.warning('HUI: Failed to load script');
          return KDCore.warning(e);
        };
        document.body.appendChild(script);
        if (isReact === true) {
          return window.dispatchEvent(new Event('DOMContentLoaded'));
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.loadReactComponent = function(componentName, folder = 'data/uiComponents') {
      var e, src;
      try {
        src = folder + "/" + componentName + ".js";
        return this._loadScript(src, true);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.addReactComponent = function(componentName, props, uniqueId = null) {
      var e, element, reactElement, root;
      try {
        if (window[componentName] == null) {
          KDCore.warning("Cant find " + componentName + ", make sure to load it first");
          return null;
        }
        if (uniqueId == null) {
          uniqueId = componentName;
        }
        // * Создаём отдельный DIV для каждого элемента (чтобы можно было удалять)
        element = this._getElementForReactComponent(uniqueId);
        root = ReactDOM.createRoot(element);
        reactElement = React.createElement(window[componentName], props);
        root.render(reactElement);
        return KDCore.HUI.getElement(uniqueId);
      } catch (error) {
        e = error;
        KDCore.warning(e);
        return null;
      }
    };
    // * Simple React Component (without JSX!)
    _.loadReactComponentFromFile = function(filename, props, uniqueId, handler, folder = "data/uiComponents") {
      var e, url, xhr;
      try {
        xhr = new XMLHttpRequest();
        url = folder + "/" + filename + ".js";
        xhr.open("GET", url);
        xhr.overrideMimeType("plain/text");
        xhr.onload = function() {
          var e, element;
          eval(xhr.responseText);
          element = KDCore.HUI.addReactComponent(filename, props, uniqueId);
          try {
            if (handler != null) {
              return handler(element, filename);
            }
          } catch (error) {
            e = error;
            return KDCore.warning(e);
          }
        };
        return xhr.send();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._getElementForReactComponent = function(componentId) {
      var e, element;
      try {
        this.removeElementById(componentId);
        element = this.addElement(componentId, '', null);
        return element;
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return null;
    };
    _.loadElementFromFile = function(filename, handler, folder = "data/uiComponents") {
      var e, url, xhr;
      try {
        xhr = new XMLHttpRequest();
        url = folder + "/" + filename + ".html";
        xhr.open("GET", url);
        xhr.overrideMimeType("plain/text");
        xhr.onload = function() {
          var e, element, htmlElementText;
          // * Хотел отдельные данные передавать и заменять в HTML текст
          // * Но если у нас есть React компоненты, то это не надо
          //htmlElementText = @convertDataKeys(xhr.responseText, dataKeys)
          htmlElementText = xhr.responseText;
          element = KDCore.HUI.addElement(filename, htmlElementText, null);
          try {
            if (handler != null) {
              return handler(element, filename);
            }
          } catch (error) {
            e = error;
            return KDCore.warning(e);
          }
        };
        return xhr.send();
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.addCSS = function(name, folder = "css") {
      var head;
      if (!this.isInited()) {
        this.init();
      }
      head = document.getElementsByTagName("head")[0];
      if (head != null) {
        head.insertAdjacentHTML("beforeend", "<link rel=\"stylesheet\" href=\"$0/$1.css\" />".replace("$0", folder).replace("$1", name));
      }
    };
    _.addElement = function(id, html, classes = null) {
      var cls, element, i, len;
      if (!this.isInited()) {
        this.init();
      }
      element = document.createElement("div");
      element.id = id;
      element.innerHTML = html;
      if (classes != null) {
        for (i = 0, len = classes.length; i < len; i++) {
          cls = classes[i];
          element.classList.add(cls);
        }
      }
      this._parent.appendChild(element);
      return element;
    };
    _.appendElement = function(element) {
      var e;
      try {
        return this._parent.appendChild(element);
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    // * Может быть NULL
    _.getElement = function(id) {
      return document.getElementById(id);
    };
    _.removeElement = function(element) {
      if (element == null) {
        return;
      }
      if (KDCore.SDK.isString(element)) {
        this.removeElementById(element);
      } else {
        this.removeElementById(element.id);
      }
    };
    _.removeElementById = function(elementId) {
      var element;
      if (!this.isInited()) {
        return;
      }
      element = this.getElement(elementId);
      if (element != null) {
        this._parent.removeChild(element);
      }
    };
    // * PRIVATE ------------------------------------------------------------------
    _._createMainParentInHtml = function() {
      this._parent = document.createElement("div");
      this._parent.id = "KDCoreMain";
      document.body.appendChild(this._parent);
    };
    _._extendGraphicsClass = function() {
      var ALIAS___updateCanvas;
      //@[ALIAS]
      ALIAS___updateCanvas = Graphics._updateCanvas;
      Graphics._updateCanvas = function() {
        ALIAS___updateCanvas.call(this);
        return KDCore.HUI.refresh();
      };
    };
  })();
  //@[EXTEND]
  return KDCore.HUI = HUI;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var ALIAS___onMouseUp, ALIAS___onRightButtonDown, ALIAS__clear, ALIAS__update, _;
  // * Right mouse pressed
  // * Определение когда правая (вторая) кнопка мыши зажата и удерживается

  //@[DEFINES]
  _ = TouchInput;
  //@[ALIAS]
  ALIAS__clear = _.clear;
  _.clear = function() {
    ALIAS__clear.call(this);
    this._kdMousePressed2 = false;
    this._kdPressedTime2 = 0;
  };
  //@[ALIAS]
  ALIAS___onRightButtonDown = _._onRightButtonDown;
  _._onRightButtonDown = function(event) {
    var check;
    ALIAS___onRightButtonDown.call(this, event);
    // * Это значит что ALIAS метод прошёл (верные X и Y в Canvas)
    if (KDCore.isMZ()) {
      check = this._newState.cancelled === true;
    } else {
      check = this._events.cancelled === true;
    }
    if (check === true) {
      this._kdMousePressed2 = true;
      this._kdPressedTime2 = 0;
    }
  };
  //@[ALIAS]
  ALIAS___onMouseUp = _._onMouseUp;
  _._onMouseUp = function(event) {
    ALIAS___onMouseUp.call(this, event);
    if (event.button === 2) {
      this._kdMousePressed2 = false;
    }
  };
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    ALIAS__update.call(this);
    if (this.kdIsPressed2()) {
      return this._kdPressedTime2++;
    }
  };
  //?[NEW]
  return _.kdIsPressed2 = function() {
    return this._kdMousePressed2 === true;
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  // * Методы из RPG Maker MZ которых нет в RPG Maker MV
  if (KDCore.isMZ()) {
    return;
  }
  (function() {    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Scene_Base.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    
    //@[DEFINES]
    _ = Scene_Base.prototype;
    _.calcWindowHeight = function(numLines, selectable) {
      if (selectable === true) {
        return Window_Selectable.prototype.fittingHeight(numLines);
      } else {
        return Window_Base.prototype.fittingHeight(numLines);
      }
    };
  })();
  (function() {    // ■ END Scene_Base.coffee
    //---------------------------------------------------------------------------

    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Window_Selectable.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    
    //@[DEFINES]
    _ = Window_Selectable.prototype;
    _.itemLineRect = function(index) {
      return this.itemRect(index);
    };
  })();
  (function() {    // ■ END Window_Selectable.coffee
    //---------------------------------------------------------------------------

    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Window_Base.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var ALIAS__initialize, ALIAS__processEscapeCharacter, _;
    //@[DEFINES]
    _ = Window_Base.prototype;
    // * Чтоб можно было Rectangle принимать в конструктор
    //@[ALIAS]
    ALIAS__initialize = _.initialize;
    _.initialize = function(x, y, w, h) {
      if (x instanceof PIXI.Rectangle || x instanceof Rectangle) {
        return ALIAS__initialize.call(this, x.x, x.y, x.width, x.height);
      } else {
        return ALIAS__initialize.call(this, ...arguments);
      }
    };
    
    // * В MZ используется FS для изменения размера шрифта в тексте
    //@[ALIAS]
    ALIAS__processEscapeCharacter = _.processEscapeCharacter;
    _.processEscapeCharacter = function(code, textState) {
      if (code === "FS") {
        this.contents.fontSize = this.obtainEscapeParam(textState);
      } else {
        ALIAS__processEscapeCharacter.call(this, code, textState);
      }
    };
  })();
  (function() {    // ■ END Window_Base.coffee
    //---------------------------------------------------------------------------

    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Spriteset_Map.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    
    //@[DEFINES]
    _ = Spriteset_Map.prototype;
    _.findTargetSprite = function(target) {
      return this._characterSprites.find(function(sprite) {
        return sprite.checkCharacter(target);
      });
    };
  })();
  return (function() {    // ■ END Spriteset_Map.coffee
    //---------------------------------------------------------------------------

    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Sprite_Character.coffee
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    var _;
    
    //@[DEFINES]
    _ = Sprite_Character.prototype;
    _.checkCharacter = function(character) {
      return this._character === character;
    };
  })();
});

// ■ END Sprite_Character.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var alias_SM_processMapTouch, alias_TIOMM;
  //?SMouse better alternative
  if (KDCore.isMZ()) {
    return;
  }
  // * Для ButtonM
  //@[ALIAS]
  alias_SM_processMapTouch = Scene_Map.prototype.processMapTouch;
  Scene_Map.prototype.processMapTouch = function() {
    if ($gameTemp.kdButtonUnderMouse != null) {
      if ($gameTemp.kdButtonUnderMouse.parent == null) {
        return $gameTemp.kdButtonUnderMouse = null;
      } else {

      }
    } else {
      return alias_SM_processMapTouch.call(this);
    }
  };
  //@[ALIAS]
  alias_TIOMM = TouchInput._onMouseMove;
  TouchInput._onMouseMove = function(event) {
    var x, y;
    alias_TIOMM.call(this, event);
    x = Graphics.pageToCanvasX(event.pageX);
    y = Graphics.pageToCanvasY(event.pageY);
    if (Graphics.isInsideCanvas(x, y)) {
      return this._onHover(x, y);
    }
  };
  
  //?NEW, from MZ
  return TouchInput._onHover = function(_x, _y) {
    this._x = _x;
    this._y = _y;
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var ALIAS__clear, ALIAS__update, _;
  if (KDCore.isMZ()) {
    return;
  }
  //@[DEFINES]
  _ = Input;
  //@[ALIAS]
  ALIAS__clear = _.clear;
  _.clear = function() {
    ALIAS__clear.call(this);
    return this._virtualButton = null;
  };
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    ALIAS__update.call(this);
    if (this._virtualButton == null) {
      return;
    }
    this._latestButton = this._virtualButton;
    this._pressedTime = 0;
    return this._virtualButton = null;
  };
  return _.virtualClick = function(buttonName) {
    return this._virtualButton = buttonName;
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var ALIAS___startLoading, _;
  // * В версии RPG Maker MZ 1.5.0 появился баг что картинки не успевают прогрузится
  // * Данный фикс, возвращает старое поведение
  if (!KDCore.isMZ()) {
    return;
  }
  //@[DEFINES]
  _ = Bitmap.prototype;
  //@[ALIAS]
  ALIAS___startLoading = _._startLoading;
  return _._startLoading = function() {
    if (Utils.hasEncryptedImages()) {
      ALIAS___startLoading.call(this, ...arguments);
    } else {
      // * Это из RPG Maker MZ до версии 1.5
      this._image = new Image();
      this._image.onload = this._onLoad.bind(this);
      this._image.onerror = this._onError.bind(this);
      this._destroyCanvas();
      this._loadingState = "loading";
      this._image.src = this._url;
    }
  };
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var Builder;
  Builder = {};
  (function() {    //NUI 1.0
    //rev 18.08.24
    var _;
    //@[DEFINES]
    _ = Builder;
    _.Factory = function(jsonCollection, owner, exRefresh = 0) {
      var e, item, items, j, key, len, value;
      try {
        if (jsonCollection == null) {
          return;
        }
        items = [];
        for (key in jsonCollection) {
          value = jsonCollection[key];
          item = KDCore.UI.Builder.Make(value, owner);
          if (item != null) {
            items.push(item); // * Skip not UI elements definitions
          }
        }
//owner[key] = item if owner?
        for (j = 0, len = items.length; j < len; j++) {
          item = items[j];
          item.refreshBindings(owner, true);
        }
        // * Обновить привязки через MS ещё раз
        if (exRefresh > 0) {
          setTimeout((function() {
            var e, k, len1, results;
            try {
              results = [];
              for (k = 0, len1 = items.length; k < len1; k++) {
                item = items[k];
                results.push(item.refreshBindings(owner, true));
              }
              return results;
            } catch (error) {
              e = error;
              return KDCore.warning(e);
            }
          }), exRefresh);
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return items;
    };
    _.Make = function(jsonStructure, owner = null, parent = null) {
      var bindings, child, childrens, dataObject, e, item, j, len, parameters, shortcutData, subItem, type, value;
      try {
        if (jsonStructure == null) {
          return null;
        }
        if (jsonStructure.type == null) {
          return null;
        }
        if (jsonStructure.shortcut != null) {
          shortcutData = KDCore.UI.Builder.ConvertShortcut(jsonStructure.shortcut);
          ({type, parameters} = shortcutData);
        } else {
          ({type, parameters} = jsonStructure);
        }
        if (typeof parameters === "string") {
          parameters = KDCore.UI.Builder.ConvertShortcut(parameters);
        }
        if (jsonStructure.createIf != null) {
          value = this._convertBindingValue(owner, jsonStructure.createIf);
          if (value !== true) {
            return null;
          }
        }
        item = KDCore.UI.Builder.CreateItemByType(type, parameters);
        if (item == null) {
          return null;
        }
        ({dataObject, bindings, childrens} = jsonStructure);
        // * Parent нужен чтобы работали настройки положения (center, %) и т.д.
        if (parent != null) {
          parent.addChild(item);
        } else {
          // * Owner - это не только главный родитель, но и к кому мы
          // * прописываем все поля по ID
          if (owner != null) {
            owner.addChild(item);
          }
        }
        // * Сохраняем схему (но только этого элемента, без "детей")
        item.uiJsonScheme = Object.assign({}, jsonStructure, {
          childrens: []
        });
        // * Константы доступны не только у каждого элемента в схеме, но и у общего родителя
        if (jsonStructure.constants != null) {
          if (item.uiConstants == null) {
            item.uiConstants = {};
          }
          item.uiConstants = Object.assign(item.uiConstants, jsonStructure.constants);
          if (owner != null) {
            if (owner.uiConstants == null) {
              owner.uiConstants = {};
            }
            owner.uiConstants = Object.assign(owner.uiConstants, jsonStructure.constants);
          }
        }
        if (bindings != null) {
          if (dataObject == null) {
            dataObject = owner;
          }
          KDCore.UI.Builder.ApplyBindings(item, bindings, dataObject);
        }
        try {
          if (jsonStructure.effects != null) {
            KDCore.UI.Builder.ApplyEffects(item, jsonStructure.effects);
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        if ((childrens != null) && childrens.length > 0) {
          for (j = 0, len = childrens.length; j < len; j++) {
            child = childrens[j];
            // * Дети всегда имеют родителя - этот элемент (а не owner)
            subItem = KDCore.UI.Builder.Make(child, owner, item);
          }
        }
        if (jsonStructure.id != null) {
          item.id = jsonStructure.id;
          if (owner != null) {
            owner[jsonStructure.id] = item;
          }
        }
        if (jsonStructure.parent != null) {
          parent = jsonStructure.parent;
          if ((owner != null) && (owner[parent] != null)) {
            owner[parent].addChild(item);
          }
        }
        // * Update bindings for recalculate Positions and Sizes
        if (bindings != null) {
          KDCore.UI.Builder.RefreshBindings(item, dataObject);
        }
        if (jsonStructure.position != null) {
          item.setPosition(jsonStructure.position);
        }
        try {
          if (jsonStructure.animations != null) {
            KDCore.UI.Builder.ApplyAnimations(item, jsonStructure.animations);
          }
        } catch (error) {
          e = error;
          KDCore.warning(e);
        }
        return item;
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return null;
    };
    // * dataObject может быть Null, если нет binding c $
    _.ApplyBindings = function(uiElement, bindings, dataObject) {
      var dataBindings, e, field, value;
      try {
        if (uiElement == null) {
          return;
        }
        if (bindings == null) {
          return;
        }
        if (uiElement.dataBindings == null) {
          return;
        }
        dataBindings = uiElement.dataBindings();
        if (dataBindings == null) {
          return;
        }
        for (field in dataBindings) {
          if (bindings[field] != null) {
            value = this.ConvertBindingValue(dataObject, bindings[field], uiElement);
            dataBindings[field].call(uiElement, value);
          }
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    };
    _.RefreshBindings = function(uiElement, dataObject) {
      var bindings, e;
      try {
        if (uiElement == null) {
          return;
        }
        if (uiElement.uiJsonScheme == null) {
          return;
        }
        ({bindings} = uiElement.uiJsonScheme);
        if (bindings == null) {
          return;
        }
        KDCore.UI.Builder.ApplyBindings(uiElement, bindings, dataObject);
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    };
    _.ApplyEffects = function(uiElement, effects) {
      var alpha, color, e, ef, efData, effectsArray, j, len, quality, thickness;
      try {
        if (uiElement == null) {
          return;
        }
        if (effects == null) {
          return;
        }
        //TODO: Преобразование цвета!
        effectsArray = [];
        for (j = 0, len = effects.length; j < len; j++) {
          ef = effects[j];
          if (ef == null) {
            continue;
          }
          efData = KDCore.UI.Builder.ConvertShortcut(ef);
          if ((efData.shadow != null) && KDCore.isMZ()) {
            effectsArray.push(new PIXI.filters.DropShadowFilter(efData));
          }
          if ((efData.outline != null) && KDCore.isMZ()) {
            ({thickness, color, quality} = efData);
            if (thickness == null) {
              thickness = 1;
            }
            if (color == null) {
              color = 0xffffff;
            }
            effectsArray.push(new PIXI.filters.OutlineFilter(thickness, color, quality));
          }
          if (efData.glow != null) {
            effectsArray.push(new PIXI.filters.GlowFilter(efData));
          }
          if (efData.tint != null) {
            ({color, alpha} = efData);
            if (alpha == null) {
              alpha = 0.5;
            }
            effectsArray.push(new PIXI.filters.ColorOverlayFilter(color, alpha));
          }
        }
        if (effectsArray.length > 0) {
          return uiElement.filters = effectsArray;
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.ApplyAnimations = function(uiElement, animations) {
      var a, e, j, len;
      try {
        if (uiElement == null) {
          return;
        }
        if (animations == null) {
          return;
        }
        if (uiElement.addAnimationRule == null) {
          return;
        }
        if (animations.length === 0) {
          return;
        }
        for (j = 0, len = animations.length; j < len; j++) {
          a = animations[j];
          if (typeof a === 'string') {
            a = KDCore.UI.Builder.ConvertShortcut(a);
          }
          if (a != null) {
            uiElement.addAnimationRule(a);
          }
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
    };
    _.ConvertBindingValue = function(sourceObj, bindingValue, element = null) {
      var e, i, j, ref, text, value;
      try {
        if (bindingValue instanceof Array) {
          text = bindingValue[0];
          for (i = j = 1, ref = bindingValue.length; (1 <= ref ? j < ref : j > ref); i = 1 <= ref ? ++j : --j) {
            if (bindingValue[i] == null) {
              continue;
            }
            value = this.ConvertBindingValue(sourceObj, bindingValue[i], element);
            if (value != null) {
              text = text.replace("%" + i, value);
            }
          }
          return text;
        } else {
          return this._convertBindingValue(sourceObj, bindingValue, element);
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return bindingValue;
    };
    _.CreateItemByType = function(type, initialParameters = {}) {
      var e;
      try {
        // * SHOULD HAVE: dataBingins(size), realWidth, realHeight
        switch (type) {
          case 'button':
            return new KDCore.Sprite_SButton(initialParameters);
          case 'text':
            return new KDCore.UI.Sprite_UIText2(initialParameters);
          case 'plane':
            return new KDCore.Sprite_Plane(initialParameters);
          case 'rect':
            return new KDCore.Sprite_BaseRect(initialParameters);
          case 'image':
            return new KDCore.Sprite_Image(initialParameters);
          case 'legacyText':
            return new KDCore.UI.Sprite_UIText(initialParameters);
          case 'textExt':
            return new KDCore.UI.Sprite_UITextExt(initialParameters);
          case 'group':
            return new KDCore.Sprite_Group(initialParameters);
          case 'legacyButton':
            return new KDCore.Sprite_ImgButton(initialParameters);
          case 'circle':
            return new KDCore.Sprite_BaseCircle(initialParameters);
          case 'gauge':
            return new KDCore.Sprite_Gauge(initialParameters);
          case 'list':
            return new KDCore.Sprite_ItemsListN(initialParameters);
          case 'horList':
            return new KDCore.Sprite_ItemsListNHor(initialParameters);
          case 'screen':
            return new KDCore.Sprite_Screen(initialParameters);
          case 'face':
            return new KDCore.Sprite_ActorFace(initialParameters);
          case 'textPro':
            return new KDCore.Sprite_TextPro(initialParameters);
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return null;
    };
    _._convertValueDataFromShortcut = function(valueData) {
      var data, e, item, j, len, n, outerItems, p, v;
      try {
        if (valueData.contains("|")) {
          data = {};
          outerItems = valueData.split("|");
          for (j = 0, len = outerItems.length; j < len; j++) {
            item = outerItems[j];
            p = item.split("=");
            n = p.shift();
            v = p;
            if (v.length === 0) {
              v = true;
            } else {
              if (v.length === 1) {
                v = v[0];
                if (isFinite(v)) {
                  v = Number(v);
                }
              } else {
                v = KDCore.UI.Builder._convertValueDataFromShortcut(v.join("="));
              }
            }
            data[n] = v;
          }
          return data;
        }
        data = KDCore.UI.Builder.ConvertShortcut(valueData, ",", "=");
        return data;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _.ConvertShortcut = function(shortcut, outerSep = ";", innerSep = ":") {
      var config, e, j, len, pair, value, valueData, valueName, values;
      try {
        config = {};
        values = shortcut.split(outerSep);
//console.log(values)
        for (j = 0, len = values.length; j < len; j++) {
          value = values[j];
          if (!String.any(value)) {
            continue;
          }
          pair = value.split(innerSep);
          valueName = pair[0];
          valueData = pair[1];
          if (String.any(valueData) && valueData.contains("=")) {
            valueData = KDCore.UI.Builder._convertValueDataFromShortcut(valueData);
          } else {
            if (valueData == null) {
              valueData = true;
            } else {
              if (isFinite(valueData)) {
                valueData = Number(valueData);
              }
            }
          }
          config[valueName] = valueData;
        }
        //console.log(valueName, valueData)
        return config;
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
    _._convertBindingValue = function(sourceObj, bindingValue, element = null) {
      var captured, dpValue, e, evalString, r, result, resultValue;
      try {
        if (typeof bindingValue === 'string') {
          // * Replace all HDP
          if (bindingValue.contains("hdp")) {
            r = new RegExp("(\\d+)hdp", "g");
            result = r.exec(bindingValue);
            while ((result != null)) {
              dpValue = Number(result[1]);
              resultValue = KDCore.Utils.convertDP(dpValue, true);
              bindingValue = bindingValue.replace(/(\d+)hdp/, resultValue);
              result = r.exec(bindingValue);
            }
          }
          // * Replace all DP
          if (bindingValue.contains("dp")) {
            r = new RegExp("(\\d+)dp", "g");
            result = r.exec(bindingValue);
            while ((result != null)) {
              dpValue = Number(result[1]);
              resultValue = KDCore.Utils.convertDP(dpValue, false);
              bindingValue = bindingValue.replace(/(\d+)dp/, resultValue);
              result = r.exec(bindingValue);
            }
          }
          // * FORCE EVAL
          if (bindingValue.contains("@") && bindingValue[0] === "@") {
            evalString = bindingValue.replace("@", "");
            return eval(evalString);
          }
          // * EXTRA $ calculations
          if (bindingValue.contains("~") && bindingValue[0] === "~") { // * POST EVAL
            if (bindingValue.contains("$")) {
              r = new RegExp("(\\$[\\w+.]*)", "g");
              result = r.exec(bindingValue);
              if (result != null) {
                //console.log(result)
                captured = result[1];
                if (String.any(captured)) {
                  resultValue = this._convertSingleBindingValue$(sourceObj, captured, element);
                  if (resultValue == null) {
                    return null;
                  }
                  if (typeof resultValue === 'function') {
                    return resultValue;
                  } else {
                    if (String.any(resultValue)) {
                      bindingValue = bindingValue.replace(captured, resultValue);
                      return this._convertBindingValue(sourceObj, bindingValue, element);
                    } else {
                      return null;
                    }
                  }
                }
              }
            } else {
              evalString = bindingValue.replace("~", "");
              return eval(evalString);
            }
          }
          
          // * Default old style simple $
          if (bindingValue.contains("$")) {
            return this._convertSingleBindingValue$(...arguments);
          }
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return bindingValue;
    };
    _._convertSingleBindingValue$ = function(sourceObj, bindingValue, element) {
      var e, field, parts, subData, subField;
      try {
        field = bindingValue.replace("$", "");
        if (field.contains(".")) { //$parent.width
          parts = field.split(".");
          // * Только одно вхождение
          field = parts[0];
          subField = parts[1];
          if (!String.any(field) && String.any(subField)) {
            if (element != null) {
              return this._convertSingleBindingValue$(element, "$" + subField, element);
            } else {
              return null;
            }
          }
          if (String.any(field) && !String.any(subField)) {
            return this._convertSingleBindingValue$(sourceObj, "$" + field, element);
          }
          if (sourceObj != null) {
            if (typeof sourceObj[field] === 'function') {
              subData = sourceObj[field]();
            } else {
              subData = sourceObj[field];
            }
            return this._convertSingleBindingValue$(subData, "$" + subField, element);
          } else {
            return null;
          }
        } else {
          if ((sourceObj != null) && (sourceObj[field] != null)) {
            if (typeof sourceObj[field] === 'function') {
              return sourceObj[field]();
            } else {
              return sourceObj[field];
            }
          } else {
            return null; // * We can't find value
          }
        }
      } catch (error) {
        e = error;
        return KDCore.warning(e);
      }
    };
  })();
  //@[EXTEND]
  KDCore.UI = KDCore.UI || {};
  return KDCore.UI.Builder = Builder;
});


// Generated by CoffeeScript 2.6.1
KDCore.registerLibraryToLoad(function() {
  var alias_WBDTEX_KDCore29122021;
  // * <center>, для RPG Maker MZ и если нету Visu Message Core
  if (KDCore.isMZ()) {
    alias_WBDTEX_KDCore29122021 = Window_Base.prototype.drawTextEx;
    Window_Base.prototype.drawTextEx = function(text, x, y, width) {
      var e, newText;
      try {
        if (Imported.VisuMZ_1_MessageCore !== true) { // * В Visu уже есть <center>
          if (String.any(text) && text.contains("<center>")) {
            if (text[0] === "<" && text[1] === "c") { // * Должен быть в начале строки
              newText = text.replace("<center>", "");
              return this.drawTextExInCenter(newText, x, y, width);
            }
          }
        }
      } catch (error) {
        e = error;
        KDCore.warning(e);
      }
      return alias_WBDTEX_KDCore29122021.call(this, ...arguments);
    };
  }
  //?NEW
  Window_Base.prototype.drawTextExInCenter = function(text, x, y, width, height) {
    var e, newX, newY, textSize;
    try {
      if (KDCore.isMV()) { // * В MV нет поддержки данного метода
        this.drawTextEx(...arguments);
        return;
      }
      textSize = this.textSizeEx(text);
      newX = x + width / 2 - textSize.width / 2;
      if ((height != null) && height > 0) {
        newY = y + height / 2 - textSize.height / 2;
      } else {
        newY = y;
      }
      return this.drawTextEx(text, newX, newY, width);
    } catch (error) {
      e = error;
      KDCore.warning(e);
      return this.drawTextEx(text, x, y, width);
    }
  };
  //?NEW
  Window_Base.prototype.drawTextExWithWordWrap = function(text, x, y, width, maxLines) {
    var maxWidth, wrappedText;
    this.drawTextEx("", 0, 0, 100);
    maxWidth = this.contentsWidth();
    wrappedText = Window_Message.prototype.pWordWrap.call(this, text, width || maxWidth, maxLines);
    this.__lastWrappedText = wrappedText;
    return this.drawTextEx(wrappedText, x, y, width);
  };
  //?NEW
  return Window_Message.prototype.pWordWrap = function(text, maxWidth, maxLines) {
    var i, j, k, l, line, lines, newLines, ref, ref1, result, spaceLeft, spaceWidth, wordWidth, wordWidthWithSpace, words;
    lines = text.split('\n');
    maxWidth = maxWidth;
    spaceWidth = this.contents.measureTextWidth(' ');
    result = '';
    newLines = 1;
    for (i = k = 0, ref = lines.length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
      spaceLeft = maxWidth;
      line = lines[i];
      words = line.split(' ');
      for (j = l = 0, ref1 = words.length; (0 <= ref1 ? l < ref1 : l > ref1); j = 0 <= ref1 ? ++l : --l) {
        wordWidth = this.contents.measureTextWidth(words[j].replaceAll(/\\C\[\d+\]/g, ""));
        wordWidthWithSpace = wordWidth + spaceWidth;
        if (j === 0 || wordWidthWithSpace > spaceLeft) {
          if (j > 0) {
            if (maxLines === newLines) {
              return result;
            }
            result += '\n';
            newLines++;
          }
          result += words[j];
          spaceLeft = maxWidth - wordWidth;
          if (j === 0 && line.match(/\\n\w*\s*<\s*\\n\[\w*\s*\]\s*>*/gi)) {
            spaceLeft += 200;
          }
        } else {
          spaceLeft -= wordWidthWithSpace;
          result += ' ' + words[j];
        }
      }
      if (i < lines.length - 1) {
        result += '\n';
      }
    }
    return result;
  };
});






// Generated by CoffeeScript 2.6.1
// * Последний файл (после всех классов)
// * Загружает библиотеки
var i, len, lib, ref, text;

if (KDCore._requireLoadLibrary === true) {
  ref = KDCore[KDCore._loader];
  for (i = 0, len = ref.length; i < len; i++) {
    lib = ref[i];
    lib(KDCore);
  }
  KDCore[KDCore._loader] = [];
  text = "%c  KDCore is loaded " + KDCore.Version + " + NUI " + KDCore.nuiVersion;
  console.log(text, 'background: #222; color: #82b2ff');
}

// ==========================================================================
// ==========================================================================

//   END OF PLUGINS CORE LIBRARY
//   (Next code is this plugin code)

// ==========================================================================
// ==========================================================================

//Plugin KDCore builded by PKD PluginBuilder 2.2.2 - 23.11.2024

//build: 47 
var KDNUI;
(function (KDNUI) {
    /**
     * The version of the KDNUI Library.
     * @type {string}
     */
    KDNUI.Version = "1.7";
    /**
     * Add NUI file to the list of files to be loaded.
     * @type {string} - The folder where the file is located.
     * @type {string} - The name of the file (without extension).
     */
    function RegisterNUIFile(folder, filnename) {
        let _name = "$" + folder + "_" + filnename;
        let src = folder + "/" + filnename + ".json";
        /* @ts-ignore */
        DataManager._databaseFiles.push({ name: _name, src: src });
    }
    KDNUI.RegisterNUIFile = RegisterNUIFile;
    /**
     * Creates a `KNSprite` instance from a given scheme and optionally attaches it to a parent or owner.
     *
     * @param scheme - The scheme to create the sprite from. It can be either a `NUIScheme` or a record of `NUIScheme`.
     * @param owner - (Optional) The owner object to bind the sprite to.
     * @param parent - (Optional) The parent `Sprite` to attach the created sprite to.
     * @returns The created `KNSprite` instance or `null` if creation fails.
     *
     * @remarks
     * - If the `scheme` contains a `type`, it uses `KNBuilder.Make` to create the sprite.
     * - If the `scheme` is a record of `NUIScheme`, it uses `KNBuilder.Factory` to create the sprite.
     * - If a `parent` is provided, the created sprite is added as a child to the parent.
     * - If no `parent` is provided but an `owner` with an `addChild` method is provided, the sprite is added as a child to the owner.
     * - The created sprite's bindings are refreshed with the owner.
     * - If an error occurs during creation, a warning is logged and a new `KNSprite` instance is returned.
     */
    function FromScheme(scheme, owner, parent, extraRefreshDelayMS = 100) {
        try {
            let element;
            if (KDX.any(scheme) && KDX.any(scheme['type'])) {
                element = KNBuilder.Make(scheme, owner, parent);
            }
            else if (KDX.any(scheme)) {
                element = KNBuilder.Factory(scheme, owner, extraRefreshDelayMS)[0];
            }
            if (KDX.any(element)) {
                if (KDX.any(parent)) {
                    parent.addChild(element);
                }
                else {
                    if (KDX.any(owner) && owner['addChild']) {
                        owner['addChild'](element);
                    }
                }
                element.refreshBindings(owner, true);
                return element;
            }
        }
        catch (error) {
            console.warn(error);
        }
        return new KNSprite();
    }
    KDNUI.FromScheme = FromScheme;
})(KDNUI || (KDNUI = {}));
(function () {
    if (Utils.RPGMAKER_NAME.includes("MV"))
        return;
    // * В версии RPG Maker MZ 1.5.0 появился баг что картинки не успевают прогрузится
    // * Данный фикс, возвращает старое поведение
    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ Bitmap.ts
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    (() => {
        //@[DEFINES]
        const _ = Bitmap.prototype;
        if (Bitmap['_isExtenedByKDNUI'])
            return;
        Bitmap['_isExtenedByKDNUI'] = true;
        //@[ALIAS]
        /*@ts-ignore*/
        const ALIAS___startLoading = _._startLoading;
        _['_startLoading'] = function (...args) {
            /*@ts-ignore*/
            if (Utils.hasEncryptedImages()) {
                ALIAS___startLoading.call(this, ...args);
            }
            else {
                this._image = new Image();
                this._image.onload = this._onLoad.bind(this);
                this._image.onerror = this._onError.bind(this);
                this._destroyCanvas();
                this._loadingState = 'loading';
                this._image.src = this._url;
            }
        };
    })();
    // ■ END Bitmap.ts
    //---------------------------------------------------------------------------
})();
/**
* All available NUI elements types.
*/
var KNItemsTypes;
(function (KNItemsTypes) {
    KNItemsTypes["rect"] = "rect";
    KNItemsTypes["circle"] = "circle";
    KNItemsTypes["plane"] = "plane";
    KNItemsTypes["text"] = "text";
    KNItemsTypes["image"] = "image";
    KNItemsTypes["group"] = "group";
    KNItemsTypes["screen"] = "screen";
    KNItemsTypes["textPro"] = "textPro";
    KNItemsTypes["button"] = "button";
    KNItemsTypes["imageButton"] = "imageButton";
    KNItemsTypes["list"] = "list";
    KNItemsTypes["face"] = "face";
    KNItemsTypes["gauge"] = "gauge";
})(KNItemsTypes || (KNItemsTypes = {}));
var KNSpriteEffects;
(function (KNSpriteEffects) {
    KNSpriteEffects["Blur"] = "blur";
    KNSpriteEffects["Shadow"] = "shadow";
    KNSpriteEffects["Outline"] = "outline";
    KNSpriteEffects["Glow"] = "glow";
    KNSpriteEffects["Tint"] = "tint";
    KNSpriteEffects["Desaturate"] = "desaturate";
})(KNSpriteEffects || (KNSpriteEffects = {}));
var KBitmap;
(function (KBitmap) {
    let _loadedIconsCache = {};
    let _emptyBitmap = null;
    /**
     * Draws an icon onto the specified bitmap at the given coordinates.
     *
     * @param inputBitmap - The bitmap on which the icon will be drawn.
     * @param icon - The icon to draw, which can be either an icon index (number) or a Bitmap.
     * @param x - The x-coordinate where the icon will be drawn.
     * @param y - The y-coordinate where the icon will be drawn.
     * @param size - The size of the icon to draw. Defaults to 32.
     *
     * @throws Will log a warning to the console if an error occurs during the drawing process.
     */
    function DrawIcon(inputBitmap, icon, x, y, size = 32) {
        try {
            let bitmapToDraw = null;
            if (icon instanceof Bitmap) {
                bitmapToDraw = icon;
            }
            else {
                bitmapToDraw = GetIconBitmap(icon);
            }
            DrawInside(inputBitmap, bitmapToDraw, x, y, size, size);
        }
        catch (error) {
            console.warn(error);
        }
    }
    KBitmap.DrawIcon = DrawIcon;
    /**
     * Draws a bitmap inside another bitmap at the specified coordinates.
     *
     * @param inputBitmap - The bitmap where the other bitmap will be drawn.
     * @param bitmapToDraw - The bitmap to draw inside the input bitmap.
     * @param x - The x-coordinate where the bitmap will be drawn.
     * @param y - The y-coordinate where the bitmap will be drawn.
     * @param sw - The width to scale the drawn bitmap to. Defaults to the width of the bitmap to draw.
     * @param sh - The height to scale the drawn bitmap to. Defaults to the height of the bitmap to draw.
     *
     * @throws Will log a warning to the console if an error occurs during the drawing process.
     */
    function DrawInside(inputBitmap, bitmapToDraw, x, y, sw = 0, sh = 0) {
        try {
            if (sw <= 0)
                sw = bitmapToDraw.width;
            if (sh <= 0)
                sh = bitmapToDraw.height;
            inputBitmap.blt(bitmapToDraw, 0, 0, bitmapToDraw.width, bitmapToDraw.height, x, y, sw, sh);
        }
        catch (error) {
            console.warn(error);
        }
    }
    KBitmap.DrawInside = DrawInside;
    /**
     * Fills the input bitmap with the contents of another bitmap.
     *
     * @param inputBitmap - The bitmap to be filled.
     * @param bitmapToFill - The bitmap used to fill the input bitmap.
     */
    function FillWith(inputBitmap, bitmapToFill) {
        try {
            DrawInside(inputBitmap, bitmapToFill, 0, 0, inputBitmap.width, inputBitmap.height);
        }
        catch (error) {
            console.warn(error);
        }
    }
    KBitmap.FillWith = FillWith;
    /**
     * Draws the specified text on the given bitmap at the specified position.
     *
     * @param inputBitmap - The bitmap on which the text will be drawn.
     * @param text - The text to be drawn on the bitmap.
     * @param position - The position where the text will be aligned. Can be 'center', 'left', or 'right'.
     *
     * @throws Will log a warning to the console if an error occurs during the drawing process.
     */
    function DrawTextFull(inputBitmap, text, position) {
        try {
            inputBitmap.drawText(text, 0, 0, inputBitmap.width, inputBitmap.height, position);
        }
        catch (error) {
            console.warn(error);
        }
    }
    KBitmap.DrawTextFull = DrawTextFull;
    /**
     * Returns a singleton instance of an empty Bitmap.
     * If the instance does not exist, it creates a new Bitmap.
     *
     * @returns {Bitmap} A singleton instance of an empty Bitmap.
     */
    function GetEmptyBitmap() {
        if (!_emptyBitmap) {
            _emptyBitmap = new Bitmap();
        }
        return _emptyBitmap;
    }
    KBitmap.GetEmptyBitmap = GetEmptyBitmap;
    /**
     * Retrieves the bitmap for a specified icon index. If the icon is not already cached,
     * it loads the icon from the system icon set, caches it, and then returns the bitmap.
     * If an error occurs during this process, an empty bitmap is returned.
     *
     * @param {number} iconIndex - The index of the icon to retrieve.
     * @returns {Bitmap} The bitmap of the specified icon, or an empty bitmap if an error occurs.
     */
    function GetIconBitmap(iconIndex) {
        try {
            if (!_loadedIconsCache[iconIndex]) {
                let iconset = ImageManager.loadSystem("IconSet");
                let pw = 0;
                let ph = 0;
                if (KDX.isMV()) {
                    /* @ts-ignore */
                    pw = Window_Base._iconWidth;
                    /* @ts-ignore */
                    ph = Window_Base._iconHeight;
                }
                else {
                    pw = ImageManager.iconWidth;
                    ph = ImageManager.iconHeight;
                }
                let sx = iconIndex % 16 * pw;
                let sy = Math.floor(iconIndex / 16) * ph;
                let iconBitmap = new Bitmap(pw, ph);
                iconBitmap.blt(iconset, sx, sy, pw, ph, 0, 0);
                _loadedIconsCache[iconIndex] = iconBitmap;
            }
            return _loadedIconsCache[iconIndex];
        }
        catch (error) {
            console.warn(error);
            return GetEmptyBitmap();
        }
    }
})(KBitmap || (KBitmap = {}));
var KColor;
(function (KColor) {
    /**
     * Generates a random hexadecimal color code.
     *
     * @returns A string representing a random color code in the format "#RRGGBB".
     */
    function Random() {
        return `#${Math.floor(Math.random() * 16777215).toString(16)}`;
    }
    KColor.Random = Random;
    /**
     * Generates a lighter shade of the given hex color by a specified factor.
     *
     * @param {string} hex - The hex color code to lighten.
     * @param {number} [factor=0.2] - The factor by which to lighten the color. Default is 0.2.
     * @returns {string} The hex color code of the lighter shade.
     * @throws Will log a warning and return `#000000` if the input hex color is invalid.
     */
    function LighterColor(hex, factor = 0.2) {
        try {
            let [r, g, b] = HexToColor(hex);
            r = Math.min(255, r + 255 * factor);
            g = Math.min(255, g + 255 * factor);
            b = Math.min(255, b + 255 * factor);
            return HexFromColor(r, g, b);
        }
        catch (error) {
            console.warn(error);
            return `#000000`;
        }
    }
    KColor.LighterColor = LighterColor;
    /**
     * Darkens a given hex color by a specified factor.
     *
     * @param {string} hex - The hex color code to be darkened.
     * @param {number} [factor=0.2] - The factor by which to darken the color. Default is 0.2.
     * @returns {string} - The darkened hex color code.
     *
     * @throws Will log a warning and return `#000000` if the input hex color is invalid.
     */
    function DarkerColor(hex, factor = 0.2) {
        try {
            let [r, g, b] = HexToColor(hex);
            r = Math.max(0, r - 255 * factor);
            g = Math.max(0, g - 255 * factor);
            b = Math.max(0, b - 255 * factor);
            return HexFromColor(r, g, b);
        }
        catch (error) {
            console.warn(error);
            return `#000000`;
        }
    }
    KColor.DarkerColor = DarkerColor;
    /**
     * Converts RGB color values to a hexadecimal color string.
     *
     * @param r - The red component of the color, an integer between 0 and 255.
     * @param g - The green component of the color, an integer between 0 and 255.
     * @param b - The blue component of the color, an integer between 0 and 255.
     * @returns A string representing the hexadecimal color, prefixed with '#'.
     *          If an error occurs, returns "#000000".
     */
    function HexFromColor(r, g, b) {
        try {
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }
        catch (error) {
            console.warn(error);
            return "#000000";
        }
    }
    KColor.HexFromColor = HexFromColor;
    /**
     * Converts a short hexadecimal color code to a long hexadecimal color code.
     *
     * @param hex - The short hexadecimal color code (e.g., "#RGB").
     * @returns The long hexadecimal color code (e.g., "#RRGGBB"). If the input is already a long hexadecimal color code, it returns the input as is.
     *
     * @throws Will log a warning and return "#000000" if an error occurs during conversion.
     */
    function ToLongHex(hex) {
        try {
            if (hex.length == 4) {
                let r = hex[1];
                let g = hex[2];
                let b = hex[3];
                return `#${r}${r}${g}${g}${b}${b}`;
            }
            return hex;
        }
        catch (error) {
            console.warn(error);
            return "#000000";
        }
    }
    KColor.ToLongHex = ToLongHex;
    /**
     * Converts a hexadecimal color string to an RGB array.
     *
     * @param {string} hex - The hexadecimal color string (e.g., "#FFFFFF" or "FFFFFF").
     * @returns {number[]} An array containing the RGB values [r, g, b].
     *                      If the conversion fails, returns [0, 0, 0].
     * @throws Will log a warning to the console if the conversion fails.
     */
    function HexToColor(hex) {
        try {
            let _hex = ToLongHex(hex);
            let r = parseInt(_hex.substring(1, 3), 16);
            let g = parseInt(_hex.substring(3, 5), 16);
            let b = parseInt(_hex.substring(5, 7), 16);
            return [r, g, b];
        }
        catch (error) {
            console.warn(error);
            return [0, 0, 0];
        }
    }
    KColor.HexToColor = HexToColor;
    /**
     * Converts a hexadecimal color string to a color number.
     *
     * @param hex - The hexadecimal color string (e.g., "#RRGGBB" or "RRGGBB").
     * @returns The color number representation of the given hexadecimal color.
     */
    function HexToColorNumber(hex) {
        let [r, g, b] = HexToColor(hex);
        return r << 16 | g << 8 | b;
    }
    KColor.HexToColorNumber = HexToColorNumber;
    /**
     * Converts a hexadecimal color code to a CSS color string.
     *
     * @param {string} hex - The hexadecimal color code to convert.
     * @param {number} [alpha] - Optional alpha value for the color (0 to 1).
     * @returns {string} The CSS color string in `rgb` or `rgba` format.
     * @throws Will log a warning and return `rgb(0,0,0)` if the conversion fails.
     */
    function HexToCss(hex, alpha) {
        try {
            if (alpha) {
                return `rgba(${HexToColor(hex).join(",")},${alpha})`;
            }
            return `rgb(${HexToColor(hex).join(",")})`;
        }
        catch (error) {
            console.warn(error);
            return `rgb(0,0,0)`;
        }
    }
    KColor.HexToCss = HexToCss;
})(KColor || (KColor = {}));
var KNBuilder;
(function (KNBuilder) {
    function Factory(schemes, owner, extraRefreshAfterMs = 0) {
        let items = [];
        for (let key in schemes) {
            let item = Make(schemes[key], owner);
            if (KDX.any(item)) {
                items.push(item);
            }
        }
        // * Refresh all bindings
        /*for(let item of items) {
            item.refreshBindings(owner, true);
        }*/
        // * Обновить привязки через MS ещё раз
        if (extraRefreshAfterMs > 0) {
            setTimeout(() => {
                try {
                    for (let item of items) {
                        item === null || item === void 0 ? void 0 : item.refreshBindings(owner, true);
                    }
                }
                catch (error) {
                    console.warn(error);
                }
            }, extraRefreshAfterMs);
        }
        return items;
    }
    KNBuilder.Factory = Factory;
    function Make(scheme, owner, parent) {
        if (!scheme)
            return null;
        if (!scheme.type)
            return null;
        try {
            if (!isShouldCreate(scheme, owner))
                return null;
            let { type, parameters } = extractTypeAndParameters(scheme);
            //console.log(type);
            //console.log(parameters);
            let item = createItemByType(type, parameters);
            if (!item)
                return null;
            // * Parent нужен чтобы работали настройки положения (center, %) и т.д.
            if (KDX.any(parent)) {
                parent.addChild(item);
            }
            else {
                // * Owner - это не только главный родитель, но и к кому мы прописываем все поля по ID
                if (KDX.any(owner) && owner instanceof Sprite) {
                    owner.addChild(item);
                }
            }
            // * Сохраняем схему (но только этого элемента, без "детей")
            item.setJsonSchema(Object.assign({}, scheme, { children: [] }));
            // * Константы доступны не только у каждого элемента в схеме, но и у общего родителя
            if (KDX.any(scheme.constants)) {
                item.addUIConstants(scheme.constants);
                if (KDX.any(owner) && owner instanceof KNSprite) {
                    owner.addUIConstants(scheme.constants);
                }
            }
            // * Обновляем все связи (переменные) в элементе
            //item.refreshBindings(owner, true);
            // * Применяем эффекты
            if (KDX.any(scheme.effects)) {
                try {
                    ApplyEffects(item, scheme.effects);
                }
                catch (error) {
                    console.warn(error);
                }
            }
            // * Если есть дети, то создаем их
            if (KDX.any(scheme.childrens)) {
                for (let childScheme of scheme.childrens) {
                    // * Дети всегда имеют родителя - этот элемент (а не owner)
                    Make(childScheme, owner, item);
                }
            }
            // * Если у элемента есть ID, то сохраняем его в общий объект
            if (KDX.any(scheme.id)) {
                item['id'] = scheme.id;
                if (KDX.any(owner)) {
                    owner[scheme.id] = item;
                }
            }
            // * Если у элемента есть родитель, то добавляем его в родительский элемент
            try {
                if (KDX.any(scheme.parent)) {
                    let parent = scheme.parent;
                    if (KDX.any(owner) && owner[parent] && owner[parent] instanceof Sprite) {
                        owner[parent].addChild(item);
                    }
                }
            }
            catch (error) {
                console.warn(error);
            }
            // * Обновляем все связи (переменные) в элементе ещё раз (после всех детей)
            //item.refreshBindings(owner, true);
            // * Применяем анимации
            if (KDX.any(scheme.animations)) {
                try {
                    applyAnimations(item, scheme.animations);
                }
                catch (error) {
                    console.warn(error);
                }
            }
            return item;
        }
        catch (error) {
            console.warn(error);
        }
        return null;
    }
    KNBuilder.Make = Make;
    function extractTypeAndParameters(scheme) {
        let type = scheme.type;
        let parameters = {};
        try {
            // * Shortcut type:X;parameters:Y
            if (type.includes("type:")) {
                //console.log("Convert shortcut");
                let shortcutData = NBindingsConverter.ConvertShortcut(scheme.type);
                //console.log(shortcutData);
                if (shortcutData) {
                    type = shortcutData.type;
                    parameters = shortcutData.parameters;
                }
            }
            else {
                parameters = scheme.parameters;
            }
            if (typeof parameters === "string" && KString.any(parameters)) {
                //console.log("Convert parameters");
                parameters = NBindingsConverter.ConvertShortcut(parameters);
            }
        }
        catch (error) {
            console.warn(error);
        }
        return { type: type, parameters: parameters };
    }
    function isShouldCreate(scheme, owner) {
        if (!KDX.any(scheme.createIf))
            return true;
        if (typeof scheme.createIf === "boolean")
            return scheme.createIf;
        if (typeof scheme.createIf === "string" && KString.any(scheme.createIf)) {
            let value = NBindingsConverter.ConvertBindingValue(owner, scheme.createIf);
            if (!value) {
                return false;
            }
        }
        return true;
    }
    function createItemByType(type, parameters = {}) {
        switch (type) {
            case "rect": return new KNSprite_BaseRect(parameters);
            case "circle": return new KNSprite_BaseCircle(parameters);
            case "plane": return new KNSprite_Plane(parameters);
            case "text": return new KNSprite_Text(parameters);
            case "image": return new KNSprite_Image(parameters);
            case "group": return new KNSprite_Group(parameters);
            case "screen": return new KNSprite_Screen();
            case "textPro": return new KNSprite_TextPro(parameters);
            case "button": return new KNSprite_Button(parameters);
            case "imageButton": return new KNSprite_ImageButton(parameters);
            case "list": return new KNSprite_ItemsList(parameters);
            case "face": return new KNSprite_ActorFace(parameters);
            case "gauge": return new KNSprite_Gauge(parameters);
            default: {
                console.warn("Unknown NUI element type: " + type);
                return null;
            }
        }
    }
    function ApplyEffects(item, effects) {
        try {
            if (!KDX.any(item))
                return;
            if (!KDX.any(effects))
                return;
            for (let effect of effects) {
                if (KString.isString(effect)) {
                    try {
                        let effectData = NBindingsConverter.ConvertShortcut(effect);
                        if (effectData['color'] && KString.isString(effectData['color'])) {
                            effectData['color'] = KColor.HexToColorNumber(effectData['color']);
                        }
                        if (effectData['shadow']) {
                            item.addShadowEffect(effectData);
                            continue;
                        }
                        if (effectData['blur']) {
                            item.addBlurEffect(effectData);
                            continue;
                        }
                        if (effectData['outline']) {
                            item.addOutlineEffect(effectData);
                            continue;
                        }
                        if (effectData['glow']) {
                            item.addGlowEffect(effectData);
                            continue;
                        }
                        if (effectData['tint']) {
                            item.addTintEffect(effectData);
                        }
                        if (effectData['desaturate']) {
                            item.addDesaturateEffect();
                        }
                    }
                    catch (error) {
                        console.warn(error);
                    }
                }
                else {
                    try {
                        item.addEffect(effect);
                    }
                    catch (error) {
                        console.warn(error);
                    }
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    KNBuilder.ApplyEffects = ApplyEffects;
    function applyAnimations(item, animations) {
        try {
            if (KDX.any(animations)) {
                for (let animation of animations) {
                    item.addAnimationRule(animation);
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
})(KNBuilder || (KNBuilder = {}));
class KSprite extends Sprite {
    constructor(bitmap) {
        super(bitmap);
        this._alphaCheckThreshold = 100;
    }
    static FromRect(width, height, color = "#FFFFFF") {
        let sprite = new KSprite(new Bitmap(width, height));
        sprite.fillAll(color);
        return sprite;
    }
    getGlobalPositionNew() {
        let bounds = this.getBounds();
        let p = { x: bounds.x, y: bounds.y };
        return p;
    }
    getLocalPosition() {
        let bounds = this.getLocalBounds();
        let p = { x: bounds.x, y: bounds.y };
        return p;
    }
    getGlobalRect() {
        let bounds = this.getBounds();
        return new Rectangle(bounds.x, bounds.y, bounds.width, bounds.height);
    }
    getLocalRect() {
        let localBounds = this.getLocalBounds();
        let globalBounds = this.getBounds();
        return new Rectangle(localBounds.x, localBounds.y, globalBounds.width, globalBounds.height);
    }
    toLocalPoint(point) {
        return this.worldTransform.applyInverse(point);
    }
    toGlobalPoint(point) {
        return this.worldTransform.apply(point);
    }
    isContainGlobalPoint(point) {
        let rect = this.getGlobalRect();
        return rect.contains(point.x, point.y);
    }
    isCursorInside() {
        return this.isContainGlobalPoint(TouchInput);
    }
    isNeedCheckAlphaPixels() {
        return false;
    }
    isHoveredByCursor() {
        if (!this.isNeedCheckAlphaPixels())
            return this.isCursorInside();
        if (!this.bitmap)
            return false;
        if (!this.bitmap.isReady())
            return false;
        try {
            let localPoint = this.toLocalPoint(new Point(TouchInput.x, TouchInput.y));
            let localBounds = this.getLocalBounds();
            let x = Math.floor(localPoint.x - localBounds.x);
            let y = Math.floor(localPoint.y - localBounds.y);
            if (x < 0 || y < 0)
                return false;
            if (x >= this.bitmap.width || y >= this.bitmap.height)
                return false;
            let alpha = Number(this.bitmap.getAlphaPixel(x, y));
            return alpha > this._alphaCheckThreshold;
        }
        catch (error) {
            console.warn(error);
            return false;
        }
    }
    removeFromParent() {
        if (this.parent) {
            this.parent.removeChild(this);
        }
    }
    isVisible() {
        return this.worldVisible == true;
    }
    fillAll(color = "#FFFFFF") {
        if (this.bitmap) {
            this.bitmap.fillAll(color);
        }
    }
    setCommonAnchor(x, y) {
        try {
            if (y === undefined)
                y = x;
            this.anchor.set(x, y);
            // * Set the anchor for each children
            for (let child of this.children) {
                if (!child)
                    continue;
                if (child['setCommonAnchor']) {
                    child['setCommonAnchor'](x, y);
                }
                else {
                    if (!child['anchor'])
                        continue;
                    /*@ts-ignore*/
                    child.anchor.set(x, y);
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    onBitmapLoaded(callback) {
        if (this.bitmap && this.bitmap.isReady()) {
            callback();
        }
        else {
            this.bitmap.addLoadListener(() => {
                callback();
            });
        }
    }
}
var KDNUI;
(function (KDNUI) {
    let EasingFunc;
    (function (EasingFunc) {
        EasingFunc["Linear"] = "linear";
        EasingFunc["EaseInQuad"] = "easeInQuad";
        EasingFunc["EaseOutQuad"] = "easeOutQuad";
        EasingFunc["EaseInOutQuad"] = "easeInOutQuad";
        EasingFunc["EaseInCubic"] = "easeInCubic";
        EasingFunc["EaseOutCubic"] = "easeOutCubic";
        EasingFunc["EaseInOutCubic"] = "easeInOutCubic";
    })(EasingFunc = KDNUI.EasingFunc || (KDNUI.EasingFunc = {}));
    class EasingFuncs {
        /**
         * Linear easing function.
         * @param t Current time
         * @param b Start value
         * @param c Change in value
         * @param d Duration
         * @returns The calculated value
         */
        static linear(t, b, c, d) {
            return c * t / d + b;
        }
        /**
         * Ease in quadratic function.
         * @param t Current time
         * @param b Start value
         * @param c Change in value
         * @param d Duration
         * @returns The calculated value
         */
        static easeInQuad(t, b, c, d) {
            t /= d;
            return c * t * t + b;
        }
        /**
         * Ease out quadratic function.
         * @param t Current time
         * @param b Start value
         * @param c Change in value
         * @param d Duration
         * @returns The calculated value
         */
        static easeOutQuad(t, b, c, d) {
            t /= d;
            return -c * t * (t - 2) + b;
        }
        /**
         * Ease in and out quadratic function.
         * @param t Current time
         * @param b Start value
         * @param c Change in value
         * @param d Duration
         * @returns The calculated value
         */
        static easeInOutQuad(t, b, c, d) {
            t /= d / 2;
            if (t < 1)
                return c / 2 * t * t + b;
            t--;
            return -c / 2 * (t * (t - 2) - 1) + b;
        }
        /**
         * Ease in cubic function.
         * @param t Current time
         * @param b Start value
         * @param c Change in value
         * @param d Duration
         * @returns The calculated value
         */
        static easeInCubic(t, b, c, d) {
            t /= d;
            return c * t * t * t + b;
        }
        /**
         * Ease out cubic function.
         * @param t Current time
         * @param b Start value
         * @param c Change in value
         * @param d Duration
         * @returns The calculated value
         */
        static easeOutCubic(t, b, c, d) {
            t = t / d - 1;
            return c * (t * t * t + 1) + b;
        }
        /**
         * Ease in and out cubic function.
         * @param t Current time
         * @param b Start value
         * @param c Change in value
         * @param d Duration
         * @returns The calculated value
         */
        static easeInOutCubic(t, b, c, d) {
            t /= d / 2;
            if (t < 1)
                return c / 2 * t * t * t + b;
            t -= 2;
            return c / 2 * (t * t * t + 2) + b;
        }
    }
    KDNUI.EasingFuncs = EasingFuncs;
})(KDNUI || (KDNUI = {}));
var NUtils;
(function (NUtils) {
    function GetSpriteRealSize(forField, sprite) {
        try {
            if (!sprite) {
                return 0;
            }
            if (forField == "width" || forField == "x") {
                if (sprite["realWidth"])
                    return sprite["realWidth"]();
                else
                    return sprite.width;
            }
            if (forField == "height" || forField == "y") {
                if (sprite["realHeight"])
                    return sprite["realHeight"]();
                else
                    return sprite.height;
            }
        }
        catch (error) {
            console.warn(error);
        }
        return 0;
    }
    NUtils.GetSpriteRealSize = GetSpriteRealSize;
    function ConvertDimension(value, scaleFactor = 1.0) {
        try {
            if (typeof value == "string") {
                value = NBindingsConverter.ConvertAllDimensionValues(value, scaleFactor);
                if (KString.any(value))
                    return Number(value);
            }
            else {
                return value;
            }
        }
        catch (error) {
            console.warn(error);
        }
        return 0;
    }
    NUtils.ConvertDimension = ConvertDimension;
})(NUtils || (NUtils = {}));
var KDNUI;
(function (KDNUI) {
    class AnimationKeyFrame {
        /**
         * Creates an instance of AnimationKeyFrame.
         * @param startValue The starting value of the animation.
         * @param endValue The ending value of the animation.
         * @param duration The duration of the animation in seconds.
         * @param func The easing function name.
         */
        constructor(startValue, endValue, duration = 1, func = 'linear') {
            this.startValue = startValue;
            this.endValue = endValue;
            this._t = 0;
            this._d = duration * 60; // Convert to Frames
            this._c = this.endValue - this.startValue; // Change
            this.func = func || 'linear';
        }
        /**
         * Resets the animation timer.
         */
        reset() {
            this._t = 0;
        }
        /**
         * Updates the animation timer.
         */
        update() {
            if (this._t < this._d) {
                this._t += 1;
            }
        }
        /**
         * Checks if the animation has ended.
         * @returns True if the animation has ended, otherwise false.
         */
        isEnd() {
            return this._t >= this._d || this._d <= 0;
        }
        /**
         * Gets the current value of the animation.
         * @returns The current value of the animation.
         */
        getValue() {
            if (this._d <= 0) {
                return this.endValue;
            }
            else {
                return this.easingFunc()(this._t, this.startValue, this._c, this._d);
            }
        }
        /**
         * Gets the easing function based on the function name.
         * @returns {KDNUI.IEasingFunction} The easing function.
         */
        easingFunc() {
            if (this.func && KDNUI.EasingFuncs[this.func]) {
                return KDNUI.EasingFuncs[this.func];
            }
            else {
                console.warn(`Easing func ${this.func} not found!`);
                return this.linear;
            }
        }
        /**
         * Default linear easing function.
         * @param t Current time
         * @param b Start value
         * @param c Change in value
         * @param d Duration
         * @returns The calculated value
         */
        linear(t, b, c, d) {
            return c * t / d + b;
        }
    }
    KDNUI.AnimationKeyFrame = AnimationKeyFrame;
})(KDNUI || (KDNUI = {}));
var KDNUI;
(function (KDNUI) {
    class AnimationKeyLine {
        /**
         * Creates an instance of AnimationKeyLine.
         * @param keyFramesList The list of keyframes.
         * @param totalDuration The total duration of the animation.
         * @param func The easing function name.
         */
        constructor(keyFramesList, totalDuration = 1, func = 'linear') {
            this.totalDuration = totalDuration;
            this.keyFrames = this._parseKeyFrames(keyFramesList, func);
            this.repeatsLeftBase = 0;
            this.repeatsLeft = 0;
            this.keyIndex = 0;
            this._relativeValue = 0;
            this._isStarted = false;
        }
        /**
         * Sets the relative value.
         * @param _relativeValue The relative value.
         */
        setRelativeValue(_relativeValue) {
            this._relativeValue = _relativeValue;
        }
        /**
         * Sets the number of repeats.
         * @param repeatsLeftBase The number of repeats.
         */
        setRepeatsCount(repeatsLeftBase) {
            this.repeatsLeftBase = repeatsLeftBase;
            this.repeatsLeft = repeatsLeftBase;
        }
        /**
         * Sets the animation to loop indefinitely.
         */
        setLoop() {
            this.setRepeatsCount(-1);
        }
        /**
         * Starts the animation with an optional delay.
         * @param startDelay The delay before starting the animation.
         */
        start(startDelay = 0) {
            if (startDelay === 0) {
                this._isStarted = true;
            }
            else {
                this._startTimer = startDelay * 60;
            }
        }
        /**
         * Pauses the animation.
         */
        pause() {
            this._isStarted = false;
            this._startTimer = null;
        }
        /**
         * Checks if the animation has started.
         * @returns True if the animation has started, otherwise false.
         */
        isStarted() {
            return this._isStarted === true;
        }
        /**
         * Completes the animation.
         */
        complete() {
            this.keyIndex = this.keyFrames.length;
            this.repeatsLeft = 0;
        }
        /**
         * Resets the animation.
         */
        reset() {
            this.repeatsLeft = this.repeatsLeftBase;
            this._resetKeyframes();
        }
        /**
         * Updates the animation.
         */
        update() {
            if (this._startTimer != null) {
                this._updateStartTimer();
            }
            if (!this.isStarted())
                return;
            if (this.isEnd()) {
                if (this.repeatsLeft === 0) {
                    return; // No repeats at all
                }
                else if (this.repeatsLeft < 0) { // Infinite Loop
                    this._resetKeyframes();
                }
                else {
                    this.repeatsLeft -= 1;
                    this._resetKeyframes();
                }
            }
            this.keyFrames[this.keyIndex].update();
            if (this.keyFrames[this.keyIndex].isEnd()) {
                this.keyIndex++;
            }
        }
        /**
         * Checks if the animation has ended.
         * @returns True if the animation has ended, otherwise false.
         */
        isEnd() {
            return this.keyIndex > this.keyFrames.length - 1;
        }
        /**
         * Gets the current value of the animation.
         * @returns The current value of the animation.
         */
        getValue() {
            let value;
            if (this.isEnd()) {
                value = this.keyFrames[this.keyFrames.length - 1].getValue();
            }
            else {
                value = this.keyFrames[this.keyIndex].getValue();
            }
            return value + this._relativeValue;
        }
        /**
         * Parses the keyframes.
         * @param keyframes The keyframes to parse.
         * @param func The easing function name.
         * @returns The parsed keyframes.
         */
        _parseKeyFrames(keyframes, func) {
            const keyframesOutput = [];
            const endValues = [];
            const keys = [];
            let index = 0;
            try {
                for (const key in keyframes) {
                    if (keyframes.hasOwnProperty(key)) {
                        let startValue;
                        if (endValues.length > 0) {
                            startValue = endValues[index - 1];
                        }
                        else {
                            startValue = 0;
                        }
                        const value = NUtils.ConvertDimension(keyframes[key]);
                        const endValue = value;
                        let duration;
                        if (key === "0") {
                            duration = 0;
                        }
                        else {
                            const prevKey = keys[index - 1];
                            duration = this._calculateDuration(prevKey, key);
                        }
                        const kf = new KDNUI.AnimationKeyFrame(startValue, endValue, duration, func);
                        keys[index] = key;
                        endValues[index] = value;
                        keyframesOutput.push(kf);
                        index++;
                    }
                }
            }
            catch (e) {
                console.warn(e);
            }
            return keyframesOutput;
        }
        /**
         * Calculates the duration between two keyframes.
         * @param rateA The start rate.
         * @param rateB The end rate.
         * @returns The calculated duration.
         */
        _calculateDuration(rateA, rateB) {
            try {
                const rateANum = Number(rateA) / 100.0;
                const rateBNum = Number(rateB) / 100.0;
                const timeA = this.totalDuration * rateANum;
                const timeB = this.totalDuration * rateBNum;
                const d = timeB - timeA;
                return d;
            }
            catch (e) {
                console.warn(e);
                return 0;
            }
        }
        /**
         * Resets the keyframes.
         */
        _resetKeyframes() {
            try {
                this.keyIndex = 0;
                for (const f of this.keyFrames) {
                    f.reset();
                }
            }
            catch (e) {
                console.warn(e);
            }
        }
        /**
         * Updates the start timer.
         */
        _updateStartTimer() {
            try {
                if (this._startTimer == null)
                    return;
                this._startTimer -= 1;
                if (this._startTimer <= 0) {
                    this._isStarted = true;
                    this._startTimer = null;
                }
            }
            catch (e) {
                console.warn(e);
            }
        }
    }
    KDNUI.AnimationKeyLine = AnimationKeyLine;
})(KDNUI || (KDNUI = {}));
var KDNUI;
(function (KDNUI) {
    class AnimationRule {
        /**
         * Creates an instance of AnimationRule.
         * @param animationConfig The animation configuration.
         * @param obj The object to apply the animation to.
         */
        constructor(animationConfig, obj) {
            if (typeof animationConfig === "string") {
                animationConfig = NBindingsConverter.ConvertShortcut(animationConfig);
            }
            this.animationConfig = Object.assign(AnimationRule.DefaultConfig(), animationConfig);
            const { condition } = this.animationConfig;
            if (KString.any(condition)) {
                if (eval(condition) === false) {
                    return;
                }
            }
            const { keyframes, duration, func, repeats, delay } = this.animationConfig;
            this.prepareKeyFrames(keyframes, obj);
            this.keyLine = new KDNUI.AnimationKeyLine(keyframes, duration, func);
            this.keyLine.setRepeatsCount(repeats !== null && repeats !== void 0 ? repeats : 0);
            if (obj && this.animationConfig.field === "_scaleFactor") {
                this.prepareObject(obj);
            }
            if (this.animationConfig.relative === true && obj) {
                this.keyLine.setRelativeValue(obj[this.animationConfig.field]);
            }
            this.keyLine.start(delay);
            if (obj && delay <= 0) {
                this.applyAnimation(obj);
            }
        }
        // * DefaultSettings in JSON format (for easy copy-paste)
        /**
         * Gets the default configuration for the animation.
         * @returns The default configuration.
         */
        static DefaultConfig() {
            return {
                "field": "opacity",
                "duration": 1,
                "func": "linear",
                "delay": 0,
                "repeats": 0,
                "relative": false,
                "keyframes": {
                    "0": 0,
                    "100": 255
                },
                "condition": null
            };
        }
        /**
         * Prepares the keyframes for the animation.
         * @param keyframes The keyframes to prepare.
         * @param obj The object to apply the animation to.
         */
        prepareKeyFrames(keyframes, obj) {
            for (const key in keyframes) {
                if (keyframes.hasOwnProperty(key)) {
                    if (keyframes[key] === "@") {
                        if (obj && obj[this.animationConfig.field] != null) {
                            keyframes[key] = obj[this.animationConfig.field];
                        }
                        else {
                            keyframes[key] = 0;
                        }
                    }
                }
            }
        }
        /**
         * Sets the end callback for the animation.
         * @param onEndCallback The callback to call when the animation ends.
         */
        setEndCallback(onEndCallback) {
            this.onEndCallback = onEndCallback;
        }
        /**
         * Checks if there is an end callback.
         * @returns True if there is an end callback, otherwise false.
         */
        isHaveEndCallback() {
            try {
                // Callback works only for single-shot animations
                if (this.animationConfig.repeats !== 0) {
                    return false;
                }
                return this.onEndCallback != null;
            }
            catch (e) {
                console.warn(e);
                return false;
            }
        }
        /**
         * Updates the animation.
         */
        update() {
            var _a;
            if (!this.keyLine)
                return;
            this.keyLine.update();
            if (this.isHaveEndCallback() && this.keyLine.isEnd()) {
                try {
                    (_a = this.onEndCallback) === null || _a === void 0 ? void 0 : _a.call(this);
                }
                catch (e) {
                    console.warn(e);
                }
                this.onEndCallback = null;
            }
        }
        /**
         * Applies the animation to the object.
         * @param obj The object to apply the animation to.
         */
        applyAnimation(obj) {
            try {
                if (!obj || !this.keyLine)
                    return;
                obj[this.animationConfig.field] = this.keyLine.getValue();
            }
            catch (e) {
                console.warn(e);
            }
        }
        /**
         * Prepares the object for the animation.
         * @param obj The object to prepare.
         */
        prepareObject(obj) {
            try {
                if (obj && obj.onBeforeChangeScaleFactor) {
                    obj.onBeforeChangeScaleFactor();
                }
            }
            catch (e) {
                console.warn(e);
            }
        }
    }
    KDNUI.AnimationRule = AnimationRule;
})(KDNUI || (KDNUI = {}));
class KFilteredSprite extends KSprite {
    constructor() {
        super();
        this._activeFilters = {};
    }
    addEffect(effectSettings) {
        try {
            switch (effectSettings.type) {
                case KNSpriteEffects.Blur:
                    this.addBlurEffect(effectSettings.settings);
                    break;
                case KNSpriteEffects.Shadow:
                    this.addShadowEffect(effectSettings.settings);
                    break;
                case KNSpriteEffects.Outline:
                    this.addOutlineEffect(effectSettings.settings);
                    break;
                case KNSpriteEffects.Glow:
                    this.addGlowEffect(effectSettings.settings);
                    break;
                case KNSpriteEffects.Tint:
                    this.addTintEffect(effectSettings.settings);
                    break;
                case KNSpriteEffects.Desaturate:
                    this.addDesaturateEffect();
                    break;
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    addBlurEffect(settings = {}) {
        try {
            if (!PIXI.filters['BlurFilter']) {
                console.warn("The blur effect is not available in the current version of PIXI.js.");
                return;
            }
            let strength = settings.strength || 8;
            let quality = settings.quality || 4;
            let filterObject = new PIXI.filters.BlurFilter(strength, quality);
            this._addFilter(KNSpriteEffects.Blur, filterObject);
        }
        catch (error) {
            console.warn(error);
        }
    }
    // * MZ only
    addShadowEffect(settings = {}) {
        try {
            if (!PIXI.filters['DropShadowFilter']) {
                console.warn("The shadow effect is not available in the current version of PIXI.js.");
                return;
            }
            if (KDX.isMV()) {
                console.warn("The shadow effect is not available in MV.");
                return;
            }
            let rotation = settings.rotation || 45;
            let color = settings.color || 0x000000;
            let alpha = settings.alpha || 0.5;
            let distance = settings.distance || 5;
            let shadowOnly = settings.shadowOnly || false;
            let blur = settings.blur || 2;
            let quality = settings.quality || 3;
            /*@ts-ignore*/
            let filterObject = new PIXI.filters.DropShadowFilter({
                rotation,
                color,
                alpha,
                distance,
                shadowOnly,
                blur,
                quality
            });
            this._addFilter(KNSpriteEffects.Shadow, filterObject);
        }
        catch (error) {
            console.warn(error);
        }
    }
    // * MZ only
    addOutlineEffect(settings = {}) {
        try {
            if (!PIXI.filters['OutlineFilter']) {
                console.warn("The outline effect is not available in the current version of PIXI.js.");
                return;
            }
            if (KDX.isMV()) {
                console.warn("The outline effect is not available in MV.");
                return;
            }
            let thickness = settings.thickness || 1;
            let color = settings.color || 0xffffff;
            let quality = settings.quality || 0.1;
            let knockout = settings.knockout || false;
            /*@ts-ignore*/
            let filterObject = new PIXI.filters.OutlineFilter(thickness, color, quality, true, knockout);
            this._addFilter(KNSpriteEffects.Outline, filterObject);
        }
        catch (error) {
            console.warn(error);
        }
    }
    addGlowEffect(settings = {}) {
        try {
            if (!PIXI.filters['GlowFilter']) {
                console.warn("The glow effect is not available in the current version of PIXI.js.");
                return;
            }
            let color = settings.color || 0xffffff;
            let distance = settings.distance || 10;
            let outerStrength = settings.outerStrength || 4;
            let innerStrength = settings.innerStrength || 0;
            let quality = settings.quality || 0.1;
            let knockout = settings.knockout || false;
            /*@ts-ignore*/
            let filterObject = new PIXI.filters.GlowFilter({ distance, outerStrength, innerStrength, color, quality, knockout });
            this._addFilter(KNSpriteEffects.Glow, filterObject);
        }
        catch (error) {
            console.warn(error);
        }
    }
    addTintEffect(settings = {}) {
        try {
            if (!PIXI.filters['ColorOverlayFilter']) {
                console.warn("The tint effect is not available in the current version of PIXI.js.");
                return;
            }
            let color = settings.color || 0xffffff;
            let alpha = settings.alpha || 0.5;
            /*@ts-ignore*/
            let filterObject = new PIXI.filters.ColorOverlayFilter(color, alpha);
            this._addFilter(KNSpriteEffects.Tint, filterObject);
        }
        catch (error) {
            console.warn(error);
        }
    }
    addDesaturateEffect() {
        try {
            if (!PIXI.filters['ColorMatrixFilter']) {
                console.warn("The desaturate effect is not available in the current version of PIXI.js.");
                return;
            }
            let filterObject = new PIXI.filters.ColorMatrixFilter();
            filterObject.desaturate();
            this._addFilter(KNSpriteEffects.Desaturate, filterObject);
        }
        catch (error) {
            console.warn(error);
        }
    }
    removeEffect(effectType) {
        try {
            this._removeFilter(effectType);
        }
        catch (error) {
            console.warn(error);
        }
    }
    _removeFilter(filter) {
        try {
            let filterObj = this._activeFilters[filter];
            if (filterObj) {
                if (KDX.isMV()) {
                    /*@ts-ignore*/
                    this._filters = this._filters.filter(f => f !== filterObj);
                }
                else {
                    this.filters = this.filters.filter(f => f !== filterObj);
                }
            }
            delete this._activeFilters[filter];
        }
        catch (error) {
            console.warn(error);
        }
    }
    _addFilter(filter, filterObject) {
        try {
            if (this._activeFilters[filter]) {
                this._removeFilter(filter);
            }
            if (KDX.isMV()) {
                /*@ts-ignore*/
                if (!this._filters) {
                    this._filters = [];
                }
            }
            else {
                if (!this.filters) {
                    this.filters = [];
                }
            }
            if (KDX.isMV()) {
                /*@ts-ignore*/
                this._filters.push(filterObject);
            }
            else {
                this.filters.push(filterObject);
            }
            this._activeFilters[filter] = filterObject;
        }
        catch (error) {
            console.warn(error);
        }
    }
}
let globalHandledSprite = null;
class KHandledSprite extends KFilteredSprite {
    static GlobalHandledSprite() {
        return globalHandledSprite;
    }
    static DeactivateGlobalHandledSprite(reference = null) {
        if (globalHandledSprite && globalHandledSprite != reference) {
            globalHandledSprite._deactivateHandler();
        }
    }
    constructor() {
        super();
        this._handledIndex = 0;
        this._handleManagerActive = false;
        this._handlerActive = false;
    }
    get handledIndex() {
        return this._handledIndex;
    }
    set handledIndex(value) {
        this._handledIndex = value;
    }
    addChild(child) {
        super.addChild(child);
        if (child instanceof KHandledSprite) {
            if (child.isSupportKeyboardHandle()) {
                child.handledIndex = this._pGetAllHandlers().length - 1;
            }
        }
        return child;
    }
    destroy(options) {
        this._deactivateHandler();
        super.destroy(options);
    }
    update() {
        super.update();
        if (this.isHandlerActive()) {
            this._handleKeyboardInputs();
        }
    }
    // * This should be TRUE if element can be selected (activated) or navigated by keyboard
    isSupportKeyboardHandle() {
        return false;
    }
    isVerticalKeyboardNavigation() {
        return true;
    }
    isFreeKeyboardNavigation() {
        return false;
    }
    isHandlerActive() {
        return this._handleManagerActive || this._handlerActive;
    }
    isAnyHandlerSelected() {
        return globalHandledSprite != null;
    }
    activateHandlerManagment() {
        if (this.isFreeKeyboardNavigation()) {
            this._handleUpAction = this._freeSelectionUpHandler.bind(this);
            this._handleDownAction = this._freeSelectionDownHandler.bind(this);
            this._handleLeftAction = this._freeSelectionLeftHandler.bind(this);
            this._handleRightAction = this._freeSelectionRightHandler.bind(this);
        }
        else {
            this._handleUpAction = this._selectPreviousHandlerItem.bind(this);
            this._handleDownAction = this._selectNextHandlerItem.bind(this);
        }
        this._handleManagerActive = true;
    }
    deactivateHandlerManagment() {
        this._handleManagerActive = false;
        if (globalHandledSprite == this) {
            this._deactivateHandler();
        }
        this._handleUpAction = null;
        this._handleDownAction = null;
        this._handleLeftAction = null;
        this._handleRightAction = null;
    }
    _handleKeyboardInputs() {
        try {
            if (Input.isTriggered('left')) {
                this._handleKeyLeft();
            }
            else if (Input.isTriggered('right')) {
                this._handleKeyRight();
            }
            else if (Input.isTriggered('up')) {
                this._handleKeyUp();
            }
            else if (Input.isTriggered('down')) {
                this._handleKeyDown();
            }
            else if (Input.isTriggered('ok')) {
                this._handleKeyOk();
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _handleKeyLeft(ignoreNavigation = false) {
        try {
            if (this.isVerticalKeyboardNavigation() || ignoreNavigation) {
                if (this._handleLeftAction) {
                    this._handleLeftAction();
                    this._onActionHandled();
                }
            }
            else {
                this._handleKeyUp(true);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _handleKeyRight(ignoreNavigation = false) {
        try {
            if (this.isVerticalKeyboardNavigation() || ignoreNavigation) {
                if (this._handleRightAction) {
                    this._handleRightAction();
                    this._onActionHandled();
                }
            }
            else {
                this._handleKeyDown(true);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _handleKeyUp(ignoreNavigation = false) {
        try {
            if (this.isVerticalKeyboardNavigation() || ignoreNavigation) {
                if (this._handleUpAction) {
                    this._handleUpAction();
                    this._onActionHandled();
                }
            }
            else {
                this._handleKeyLeft(true);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _handleKeyDown(ignoreNavigation = false) {
        try {
            if (this.isVerticalKeyboardNavigation() || ignoreNavigation) {
                if (this._handleDownAction) {
                    this._handleDownAction();
                    this._onActionHandled();
                }
            }
            else {
                this._handleKeyRight(true);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _handleKeyOk() {
        try {
            if (this._handleOkAction) {
                this._handleOkAction();
                this._onActionHandled();
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _onActionHandled() {
        Input.clear();
    }
    _selectPreviousHandlerItem() {
        if (!this.isAnyHandlerSelected()) {
            this._trySelectHandler(0);
        }
        else {
            this._trySelectHandler(this._selectedHandlerIndex() - 1);
        }
    }
    _selectedHandlerIndex() {
        return globalHandledSprite.handledIndex;
    }
    _trySelectHandler(index) {
        let handlers = this._pGetAllHandlers();
        let handler = handlers.find(h => h.handledIndex == index);
        if (handler) {
            handler._activateHandler();
        }
        this._onActionHandled();
    }
    _pGetAllHandlers() {
        let handlers = [];
        for (let child of this.children) {
            if (child instanceof KHandledSprite) {
                if (child.isSupportKeyboardHandle()) {
                    handlers.push(child);
                }
            }
        }
        return handlers;
    }
    _selectNextHandlerItem() {
        if (!this.isAnyHandlerSelected()) {
            this._trySelectHandler(0);
        }
        else {
            this._trySelectHandler(this._selectedHandlerIndex() + 1);
        }
    }
    _activateHandler() {
        if (globalHandledSprite && globalHandledSprite != this) {
            globalHandledSprite._deactivateHandler();
        }
        globalHandledSprite = this;
        this._handlerActive = true;
        this._activateHandlerVisually();
    }
    _activateHandlerVisually() {
        this.addGlowEffect({ distance: 15, outerStrength: 4 });
    }
    _deactivateHandler() {
        if (globalHandledSprite == this) {
            globalHandledSprite = null;
        }
        this._handlerActive = false;
        this._deactivateHandlerVisually();
    }
    _deactivateHandlerVisually() {
        this.removeEffect(KNSpriteEffects.Glow);
    }
    _getClosestItemToYx(x, y, fromItems) {
        let items = [];
        if (y >= 0) {
            items = fromItems.filter(i => i.y > y);
        }
        else {
            items = fromItems.filter(i => i.y < Math.abs(y));
        }
        if (items.length == 0) {
            return null;
        }
        let itemsInRow = items.filter(i => i.x == x);
        if (itemsInRow.length > 0) {
            itemsInRow.sort((a, b) => a.y - b.y);
            return itemsInRow[0];
        }
        else {
            let distances = [];
            let rY = Math.abs(y);
            let index = 0;
            for (let item of items) {
                distances.push([index, Math.abs(item.x - x) + Math.abs(item.y - rY)]);
                index++;
            }
            distances.sort((a, b) => a[1] - b[1]);
            return items[distances[0][0]];
        }
    }
    _getClosestItemToXy(x, y, fromItems) {
        let items = [];
        if (x >= 0) {
            items = fromItems.filter(i => i.x > x);
        }
        else {
            items = fromItems.filter(i => i.x < Math.abs(x));
        }
        if (items.length == 0) {
            return null;
        }
        let itemsInRow = items.filter(i => i.y == y);
        if (itemsInRow.length > 0) {
            itemsInRow.sort((a, b) => a.x - b.x);
            return itemsInRow[0];
        }
        else {
            let distances = [];
            let rX = Math.abs(x);
            let index = 0;
            for (let item of items) {
                distances.push([index, Math.abs(item.x - rX) + Math.abs(item.y - y)]);
                index++;
            }
            distances.sort((a, b) => a[1] - b[1]);
            return items[distances[0][0]];
        }
    }
    _freeSelectionUpHandler() {
        try {
            let allItems = this._pGetAllHandlers();
            if (allItems.length == 0) {
                return;
            }
            if (this.isAnyHandlerSelected()) {
                let item = this._getClosestItemToYx(globalHandledSprite.x, -globalHandledSprite.y, allItems);
                if (item) {
                    item._activateHandler();
                }
            }
            else {
                allItems[0]._activateHandler();
            }
        }
        catch (error) {
            console.warn(error);
        }
        this._onActionHandled();
    }
    _freeSelectionDownHandler() {
        try {
            let allItems = this._pGetAllHandlers();
            if (allItems.length == 0) {
                return;
            }
            if (this.isAnyHandlerSelected()) {
                let item = this._getClosestItemToYx(globalHandledSprite.x, globalHandledSprite.y, allItems);
                if (item) {
                    item._activateHandler();
                }
            }
            else {
                allItems[0]._activateHandler();
            }
        }
        catch (error) {
            console.warn(error);
        }
        this._onActionHandled();
    }
    _freeSelectionLeftHandler() {
        try {
            let allItems = this._pGetAllHandlers();
            if (allItems.length == 0) {
                return;
            }
            if (this.isAnyHandlerSelected()) {
                let item = this._getClosestItemToXy(-globalHandledSprite.x, globalHandledSprite.y, allItems);
                if (item) {
                    item._activateHandler();
                }
            }
            else {
                allItems[0]._activateHandler();
            }
        }
        catch (error) {
            console.warn(error);
        }
        this._onActionHandled();
    }
    _freeSelectionRightHandler() {
        try {
            let allItems = this._pGetAllHandlers();
            if (allItems.length == 0) {
                return;
            }
            if (this.isAnyHandlerSelected()) {
                let item = this._getClosestItemToXy(globalHandledSprite.x, globalHandledSprite.y, allItems);
                if (item) {
                    item._activateHandler();
                }
            }
            else {
                allItems[0]._activateHandler();
            }
        }
        catch (error) {
            console.warn(error);
        }
        this._onActionHandled();
    }
}
var NBindingsConverter;
(function (NBindingsConverter) {
    function ConvertBindingValue(sourceElement, bindingValue, element = null) {
        try {
            // * ["%1 %2", value1, value2]
            if (Array.isArray(bindingValue)) {
                let bindingValuesArray = bindingValue;
                let sourceText = bindingValuesArray[0];
                if (!KString.any(sourceText))
                    return "";
                for (let i = 1; i < bindingValuesArray.length; i++) {
                    if (KString.any(bindingValuesArray[i])) {
                        try {
                            let value = _convertSingleBindingValue(sourceElement, bindingValuesArray[i], element);
                            if (KString.any(value)) {
                                sourceText = sourceText.replace(`%${i}`, value);
                            }
                        }
                        catch (error) {
                            console.warn(error);
                        }
                    }
                }
                return sourceText;
            }
            else {
                return _convertSingleBindingValue(sourceElement, bindingValue, element);
            }
        }
        catch (error) {
            console.warn(error);
        }
        return bindingValue.toString();
    }
    NBindingsConverter.ConvertBindingValue = ConvertBindingValue;
    function _convertSingleBindingValue(sourceElement, bindingValue, element = null) {
        try {
            if (typeof bindingValue != "string") {
                return bindingValue;
            }
            // * CONVERT THERNARY OPERATORS
            // * example: "value ? true : false"
            let regex = new RegExp("(.+?)\\?(.+?):(.+)", "g");
            let result = regex.exec(bindingValue);
            if (result) {
                let condition = result[1].trim();
                let trueValue = result[2].trim();
                let falseValue = result[3].trim();
                let value = _convertSingleBindingValue(sourceElement, condition, element);
                if (value) {
                    return _convertSingleBindingValue(sourceElement, trueValue, element);
                }
                else {
                    return _convertSingleBindingValue(sourceElement, falseValue, element);
                }
            }
            // * CONVERT DIMENSION VALUES (HDP and DP)
            let scaleFactor = 1.0;
            if (sourceElement) {
                if (sourceElement['dimensionScaleFactor']) {
                    scaleFactor = sourceElement['dimensionScaleFactor']();
                }
            }
            bindingValue = ConvertAllDimensionValues(bindingValue, scaleFactor);
            // * FORCE EVAL
            if (bindingValue[0] == '@') {
                let evalString = bindingValue.replace("@", "");
                return eval(evalString);
            }
            // * EXTRA $ calculations (POST EVAL)
            if (bindingValue[0] == '~') {
                if (bindingValue.includes("$")) {
                    let regex = new RegExp("(\\$[\\w+.]*)", "g");
                    let result = regex.exec(bindingValue);
                    if (result) {
                        let captured = result[1];
                        if (KDX.any(captured)) {
                            let resultValue = _convertSingleBindingValue$(sourceElement, captured, element);
                            if (!KDX.any(resultValue)) {
                                return null;
                            }
                            if (typeof resultValue == "function") {
                                return resultValue;
                            }
                            else {
                                if (KDX.any(resultValue)) {
                                    bindingValue = bindingValue.replace(captured, resultValue);
                                    return ConvertBindingValue(sourceElement, bindingValue, element);
                                }
                                else {
                                    return null;
                                }
                            }
                        }
                    }
                }
                else {
                    let evalString = bindingValue.replace("~", "");
                    return eval(evalString);
                }
            }
            // * DEFAULT OLD STYLE SIMPLE $
            if (bindingValue.includes('$')) {
                return _convertSingleBindingValue$(sourceElement, bindingValue, element);
            }
        }
        catch (error) {
            console.warn(error);
        }
        return bindingValue;
    }
    function ConvertAllDimensionValues(value, scaleFactor = 1.0) {
        if (value.includes('hdp')) {
            let regex = new RegExp("(\\d+)hdp", "g");
            let result = regex.exec(value);
            while (result) {
                let dpValue = parseInt(result[1]);
                let converted = Math.round(ConvertDimenstionToPixels(dpValue, true) * scaleFactor);
                value = value.replace(result[0], converted.toString());
                result = regex.exec(value);
            }
        }
        if (value.includes('dp')) {
            let regex = new RegExp("(\\d+)dp", "g");
            let result = regex.exec(value);
            while (result) {
                let dpValue = parseInt(result[1]);
                let converted = Math.round(ConvertDimenstionToPixels(dpValue, false) * scaleFactor);
                value = value.replace(result[0], converted.toString());
                result = regex.exec(value);
            }
        }
        return value;
    }
    NBindingsConverter.ConvertAllDimensionValues = ConvertAllDimensionValues;
    function _convertSingleBindingValue$(sourceElement, bindingValue, element) {
        try {
            let field = bindingValue.replace("$", "");
            if (field.includes(".")) { // * example: $parent.width
                let parts = field.split(".");
                // * Только одно вхождение (одна точка)
                field = parts[0];
                let subField = parts[1];
                if (!KString.any(field) && KString.any(subField)) {
                    if (element) {
                        return _convertSingleBindingValue$(element, "$" + subField, element);
                    }
                    else {
                        return null;
                    }
                }
                if (KString.any(field) && !KString.any(subField)) {
                    return _convertSingleBindingValue$(sourceElement, "$" + field, element);
                }
                if (sourceElement) {
                    let subData = _getSourceElementFieldValue(sourceElement, field);
                    return _convertSingleBindingValue$(subData, "$" + subField, element);
                }
                else {
                    return null;
                }
            }
            else {
                return _getSourceElementFieldValue(sourceElement, field);
            }
        }
        catch (error) {
            console.warn(error);
        }
        return null;
    }
    function _getSourceElementFieldValue(sourceElement, field) {
        try {
            if (sourceElement && sourceElement[field]) {
                if (typeof sourceElement[field] == "function") {
                    return sourceElement[field]();
                }
                else {
                    return sourceElement[field];
                }
            }
            else {
                return null; // * We can't find value
            }
        }
        catch (error) {
            console.warn(error);
        }
        return null;
    }
    function ConvertDimenstionToPixels(value = 0, isHalf = false) {
        try {
            if (Graphics.width == 816 && Graphics.height == 624) {
                return value;
            }
            let modX = Graphics.width / 816;
            let modY = Graphics.height / 624;
            let mod = (modX + modY) / 2;
            if (mod == 0)
                return 0;
            if (isHalf) {
                if (mod < 1) {
                    let d = 1 - mod;
                    mod += d * 0.5;
                }
                else if (mod > 1) {
                    let d = mod - 1;
                    mod = 1 + (d * 0.5);
                }
            }
            return Math.round(value * mod);
        }
        catch (error) {
            console.warn(error);
        }
        return 0;
    }
    NBindingsConverter.ConvertDimenstionToPixels = ConvertDimenstionToPixels;
    function ConvertPercentageValues(value, forField, spriteParent) {
        try {
            if (value.includes("%")) {
                let regex = new RegExp("(\\d+)%", "g");
                let result = regex.exec(value);
                while (result) {
                    let percentageValue = parseInt(result[1]);
                    let resultValue = 0;
                    if (spriteParent) {
                        let parentRefSize = NUtils.GetSpriteRealSize(forField, spriteParent);
                        resultValue = parentRefSize * (percentageValue / 100.0);
                    }
                    value = value.replace(result[0], resultValue.toString());
                    result = regex.exec(value);
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
        return value;
    }
    NBindingsConverter.ConvertPercentageValues = ConvertPercentageValues;
    /**
     * Converts a shortcut string to a configuration object.
     * @param shortcut The shortcut string to convert.
     * @param outerSep The outer separator (default is ";").
     * @param innerSep The inner separator (default is ":").
     * @returns The configuration object.
     */
    function ConvertShortcut(shortcut, outerSep = ";", innerSep = ":") {
        try {
            const config = {};
            const values = shortcut.split(outerSep);
            for (const value of values) {
                if (!String(value).trim())
                    continue;
                const pair = value.split(innerSep);
                const valueName = pair[0];
                let valueData = pair[1];
                if (valueData && valueData.includes("=")) {
                    valueData = _convertValueDataFromShortcut(valueData);
                }
                else {
                    if (valueData == null) {
                        valueData = true;
                    }
                    else {
                        if (isFinite(valueData))
                            valueData = Number(valueData);
                    }
                }
                config[valueName] = valueData;
            }
            return config;
        }
        catch (e) {
            console.warn(e);
            return {};
        }
    }
    NBindingsConverter.ConvertShortcut = ConvertShortcut;
    /**
     * Converts a value data string from a shortcut format to an object.
     * @param valueData The value data string to convert.
     * @returns The converted object.
     */
    function _convertValueDataFromShortcut(valueData) {
        try {
            if (valueData.includes("|")) {
                const data = {};
                const outerItems = valueData.split("|");
                for (const item of outerItems) {
                    const p = item.split("=");
                    const n = p.shift();
                    let v = p;
                    if (v.length === 0) {
                        v = true;
                    }
                    else {
                        if (v.length === 1) {
                            v = v[0];
                            if (isFinite(v))
                                v = Number(v);
                        }
                        else {
                            v = _convertValueDataFromShortcut(v.join("="));
                        }
                    }
                    if (n)
                        data[n] = v;
                }
                return data;
            }
            const data = ConvertShortcut(valueData, ",", "=");
            return data;
        }
        catch (e) {
            console.warn(e);
            return {};
        }
    }
})(NBindingsConverter || (NBindingsConverter = {}));
let globalUnderMouseSprite = null;
function IsAnyKNButtonUnderMouse() {
    if (!globalUnderMouseSprite) {
        return false;
    }
    if (globalUnderMouseSprite) {
        if (!globalUnderMouseSprite.parent) {
            globalUnderMouseSprite = null;
            return false;
        }
        if (!globalUnderMouseSprite.worldVisible) {
            return false;
        }
    }
    return true;
}
class KClickableSprite extends KHandledSprite {
    constructor() {
        super(...arguments);
        this._isHovered = false;
        this._isPressed = false;
        this._isDisabled = false;
    }
    static GlobalUnderMouseSprite() {
        return globalUnderMouseSprite;
    }
    static DeactivateGlobalUnderMouseSprite(reference = null) {
        if (globalUnderMouseSprite && globalUnderMouseSprite != reference) {
            globalUnderMouseSprite._clearClickState();
        }
        else {
            globalUnderMouseSprite = null;
        }
    }
    _activateHandler() {
        KClickableSprite.DeactivateGlobalUnderMouseSprite(this);
        super._activateHandler();
    }
    isCanHandleTouch() {
        return false;
    }
    isClickEnabled() {
        return this.worldVisible;
    }
    isDisabled() {
        return this._isDisabled;
    }
    isPressed() {
        return this._isPressed;
    }
    isHovered() {
        return this._isHovered;
    }
    isFocused() {
        return this.isHandlerActive();
    }
    update() {
        super.update();
        if (this.isCanHandleTouch()) {
            this._updateTouch();
        }
    }
    onMouseEnter() {
        this._activateHandler();
        //console.log("Mouse enter");
    }
    onMouseExit() {
        this._deactivateHandler();
        //console.log("Mouse exit");
    }
    onClick() {
        this._handleKeyOk();
        //console.log("Click");
    }
    onPress() {
        //console.log("Press");
    }
    onReleased() {
        //console.log("Released");
    }
    setClickHandler(handler) {
        this._handleOkAction = handler;
    }
    _handleKeyOk() {
        if (this.isDisabled()) {
            return;
        }
        if (this.isClickEnabled()) {
            super._handleKeyOk();
        }
    }
    _updateTouch() {
        if (this.isClickEnabled()) {
            if (this.isHoveredByCursor()) {
                /*@ts-ignore*/
                if (!this.isHovered() && !TouchInput.isPressed()) {
                    this._isHovered = true;
                    if (!this.isDisabled()) {
                        this.onMouseEnter();
                    }
                    globalUnderMouseSprite = this;
                    KHandledSprite.DeactivateGlobalHandledSprite(this);
                }
            }
            else {
                if (this.isHovered()) {
                    this._clearClickState();
                    if (!this.isDisabled()) {
                        this.onMouseExit();
                    }
                }
            }
            if (TouchInput.isPressed() && this.isHovered() && !this.isDisabled()) {
                if (!this.isPressed()) {
                    this._isPressed = true;
                    this.onPress();
                }
            }
            if (TouchInput.isReleased() && this.isPressed() && !this.isDisabled()) {
                this._isPressed = false;
                this.onReleased();
                if (this.isHovered()) {
                    this.onClick();
                }
            }
        }
        else {
            this._clearClickState();
        }
    }
    _clearClickState() {
        this._isHovered = false;
        this._isPressed = false;
        if (globalUnderMouseSprite == this) {
            globalUnderMouseSprite = null;
        }
    }
    destroy(options) {
        this._clearClickState();
        super.destroy(options);
    }
}
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Map.ts
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(() => {
    //@[DEFINES]
    const _ = Scene_Map.prototype;
    //@[ALIAS]
    const ALIAS__isAnyButtonPressed = _.isAnyButtonPressed;
    _.isAnyButtonPressed = function () {
        if (IsAnyKNButtonUnderMouse()) {
            return true;
        }
        return ALIAS__isAnyButtonPressed.call(this);
    };
    //@[ALIAS]
    const ALIAS__start = _.start;
    _.start = function () {
        globalUnderMouseSprite = null;
        ALIAS__start.call(this);
    };
    if (Utils.RPGMAKER_NAME.includes("MV")) {
        //@[ALIAS]
        const ALIAS__processMapTouch = _.processMapTouch;
        _.processMapTouch = function () {
            if (IsAnyKNButtonUnderMouse()) {
                return;
            }
            ALIAS__processMapTouch.call(this);
        };
    }
})();
// ■ END Scene_Map.ts
//---------------------------------------------------------------------------
class KNSprite extends KClickableSprite {
    constructor() {
        super();
        this._scaleFactor = null;
        this._isNotHaveBounds = false;
        this._requiredFuncs = null;
        this._loadListeners = null;
        this._animationRules = null;
        this._uiJsonSchema = null;
        this._dataBindingsCache = null;
        this._uiConstants = null;
        this._shouldRefreshBindings = false;
        this._initialRefrshBindings = false;
        this._bindingsArgs = null;
        this._dimensionScaleFactor = 1.0;
    }
    isNotHaveBounds() {
        return this._isNotHaveBounds == true;
    }
    isLoaded() {
        return true;
    }
    isShouldAlwaysKeepCentered() {
        return this._anchoredCenterX != null;
    }
    realWidth() {
        try {
            if (this.isNotHaveBounds()) {
                return 0;
            }
            if (this.width == 0) {
                let child = this.children[0];
                if (child) {
                    if (child["realWidth"])
                        return child["realWidth"]();
                    else
                        return child.width;
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
        return this.width;
    }
    realHeight() {
        try {
            if (this.isNotHaveBounds()) {
                return 0;
            }
            if (this.height == 0) {
                let child = this.children[0];
                if (child) {
                    if (child["realHeight"])
                        return child["realHeight"]();
                    else
                        return child.height;
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
        return this.height;
    }
    setJsonSchema(schema) {
        this._uiJsonSchema = schema;
    }
    getJsonSchema() {
        return this._uiJsonSchema;
    }
    addUIConstants(constants) {
        if (!this._uiConstants) {
            this._uiConstants = {};
        }
        this._uiConstants = Object.assign(this._uiConstants, constants);
    }
    uiConstant(key, defaultValue = undefined) {
        if (!this._uiConstants) {
            this._uiConstants = {};
        }
        if (KDX.any(this._uiConstants[key])) {
            return this._uiConstants[key];
        }
        else {
            return defaultValue;
        }
    }
    dataBindings() {
        if (!this._dataBindingsCache) {
            this._dataBindingsCache = {
                x: (v) => this.setPosition(v, this.y),
                y: (v) => this.setPosition(this.x, v),
                position: (v) => this.setPosition(v.x, v.y),
                visible: (v) => { this.visible = v; },
                opacity: (v) => { if (KDX.any(v)) {
                    this.opacity = v;
                } },
                scale: (v) => { if (KDX.any(v)) {
                    this.scale.set(v);
                } },
                rotation: (v) => { if (KDX.any(v)) {
                    this.rotation = v;
                } },
                physicalBounds: (v) => { this._isNotHaveBounds = !v; },
                anchor: (v) => { if (KDX.any(v)) {
                    this.setCommonAnchor(v);
                } },
                animation: (v) => { if (v) {
                    this.addAnimationRule(v);
                } },
                centeredScale: (v) => { if (KDX.any(v)) {
                    this.setCenteredScale(v);
                } },
                dimensionScale: (v) => { if (KDX.any(v)) {
                    this.setDimensionScaleFactor(v);
                } }
            };
        }
        return this._dataBindingsCache;
    }
    refreshBindings(dataObject = null, resursive = true) {
        if (!this._initialRefrshBindings) {
            this._initialRefrshBindings = true;
            this._refreshBindings(dataObject, resursive);
            return;
        }
        this._shouldRefreshBindings = true;
        this._bindingsArgs = [dataObject, resursive];
    }
    callBinding(key, value) {
        try {
            let bindings = this.dataBindings();
            if (bindings[key]) {
                bindings[key](value);
            }
            else {
                console.warn("Binding not found", key);
            }
        }
        catch (error) {
            console.warn("Binding call error", error);
        }
    }
    addAnimationRule(rule) {
        try {
            if (!this._animationRules) {
                this._animationRules = [];
            }
            let animationRule = new KDNUI.AnimationRule(rule, this);
            this._animationRules.push(animationRule);
            return animationRule;
        }
        catch (error) {
            console.warn(error);
            return null;
        }
    }
    setAnimationRule(rule) {
        try {
            this._animationRules = []; // * Clear all rules
            if (rule) {
                return this.addAnimationRule(rule);
            }
        }
        catch (error) {
            console.warn(error);
        }
        return null;
    }
    addLoadListener(func) {
        try {
            if (this.isLoaded()) {
                func();
            }
            else {
                this._addLoadListener(func);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    setCenteredScale(value) {
        if (!this.isLoaded()) {
            this.requireFunc("setCenteredScale", arguments);
            return;
        }
        this._refreshAnchoredCenter();
        this._scaleFactor = value;
    }
    // * For Animation Rule (callback)
    onBeforeChangeScaleFactor() {
        try {
            if (this.isShouldAlwaysKeepCentered()) {
                this._refreshAnchoredCenter();
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    // * Examples: setPosition(10, 10), setPosition("center") - for both x and y
    setPosition(x, y, bindedObject) {
        try {
            if (!this.isLoaded()) {
                this.requireFunc("setPosition", arguments);
                return;
            }
            if (typeof x == "string") {
                if (y == null || y == undefined) { // * If single string argument X, then Y = X
                    y = x;
                }
                x = this.convertStringSizeValue(x, "x", bindedObject);
            }
            if (y == null || y == undefined) {
                y = this.y;
            }
            if (typeof y == "string") {
                y = this.convertStringSizeValue(y, "y", bindedObject);
            }
            if (!isNaN(x) && !isNaN(y)) {
                this.move(x, y);
            }
            else {
                console.warn("Invalid position values X, Y ", x, y);
            }
        }
        catch (error) {
            console.warn(error);
            this.move(0, 0);
        }
    }
    setDimensionScaleFactor(value) {
        try {
            if (!this.isLoaded()) {
                this.requireFunc("setDimensionScaleFactor", arguments);
                return;
            }
            if (typeof value == "string") {
                value = Number(value);
            }
            if (value == null || value == undefined || isNaN(value) || value <= 0) {
                value = 1.0;
            }
            this._dimensionScaleFactor = value;
        }
        catch (error) {
            console.warn(error);
            this._dimensionScaleFactor = 1.0;
        }
    }
    update() {
        if (this._shouldRefreshBindings) {
            this._shouldRefreshBindings = false;
            this._refreshBindings.apply(this, this._bindingsArgs);
            this._bindingsArgs = null;
        }
        super.update();
        this._updateAnimationRules();
        if (this._scaleFactor != null) {
            this._updateScaleFactor(); // * For Centered Scale
        }
    }
    dimensionScaleFactor() {
        try {
            // * First, collect scale factor from the parent
            if (this.parent && this.parent['dimensionScaleFactor']) {
                return this.parent['dimensionScaleFactor']() * this._dimensionScaleFactor;
            }
        }
        catch (error) {
            console.warn(error);
        }
        return this._dimensionScaleFactor || 1.0;
    }
    convertStringSizeValue(value, forField, owner) {
        try {
            if (typeof value == "number") {
                return value;
            }
            /* @ts-ignore */
            if (isFinite(value)) {
                return Number(value);
            }
            if (typeof value != "string") {
                return 0;
            }
            if (value[0] == '$' || value[0] == '@') {
                let v = NBindingsConverter.ConvertBindingValue(owner, value, this);
                return this.convertStringSizeValue(v, forField, owner);
            }
            if (value.includes("prev")) {
                if (value.includes("prevX")) {
                    value = value.replace("prevX", this.getPreviousChildData("x"));
                    return this.convertStringSizeValue(value, forField, owner);
                }
                if (value.includes("prevY")) {
                    value = value.replace("prevY", this.getPreviousChildData("y"));
                    return this.convertStringSizeValue(value, forField, owner);
                }
                if (value.includes("prevHeight")) {
                    value = value.replace("prevHeight", this.getPreviousChildData("height"));
                    return this.convertStringSizeValue(value, forField, owner);
                }
                if (value.includes("prevWidth")) {
                    value = value.replace("prevWidth", this.getPreviousChildData("width"));
                    return this.convertStringSizeValue(value, forField, owner);
                }
                if (value.includes("prevEndX")) {
                    value = value.replace("prevEndX", this.getPreviousChildData("x") + this.getPreviousChildData("width"));
                    return this.convertStringSizeValue(value, forField, owner);
                }
                if (value.includes("prevEndY")) {
                    value = value.replace("prevEndY", this.getPreviousChildData("y") + this.getPreviousChildData("height"));
                    return this.convertStringSizeValue(value, forField, owner);
                }
            }
            if (value.includes("end")) {
                value = value.replace("end", "100%");
            }
            if (value.includes("begin")) {
                if (forField == "y") {
                    value = value.replace("begin", "-height");
                }
                else {
                    value = value.replace("begin", "-width");
                }
            }
            if (value.includes("right")) {
                value = value.replace("right", "100% - width");
                return this.convertStringSizeValue(value, forField, owner);
            }
            if (value.includes("left")) {
                value = value.replace("left", "0");
                return this.convertStringSizeValue(value, forField, owner);
            }
            if (value.includes("top")) {
                value = value.replace("top", "0");
                return this.convertStringSizeValue(value, forField, owner);
            }
            if (value.includes("bottom")) {
                value = value.replace("bottom", "100% - height");
                return this.convertStringSizeValue(value, forField, owner);
            }
            // * Replace all %
            if (value.includes("%")) {
                if (this.parent) {
                    value = NBindingsConverter.ConvertPercentageValues(value, forField, this.parent);
                }
                else {
                    value = NBindingsConverter.ConvertPercentageValues(value, forField, this);
                }
            }
            // * Replace HDP and DP
            value = NBindingsConverter.ConvertAllDimensionValues(value, this.dimensionScaleFactor());
            if (value.includes('center')) {
                let v = this.convertStringSizeValue('50%', forField, owner);
                let exValue = NUtils.GetSpriteRealSize(forField, this);
                exValue = v - (exValue / 2);
                value = value.replace('center', exValue.toString());
                return this.convertStringSizeValue(value, forField, owner);
            }
            if (value.includes('height')) {
                let exValue = NUtils.GetSpriteRealSize('height', this);
                value = value.replace('height', exValue.toString());
                return this.convertStringSizeValue(value, forField, owner);
            }
            if (value.includes('width')) {
                let exValue = NUtils.GetSpriteRealSize('width', this);
                value = value.replace('width', exValue.toString());
                return this.convertStringSizeValue(value, forField, owner);
            }
            let v = value;
            if (typeof value == "string") {
                v = eval(value);
            }
            return this.convertStringSizeValue(v, forField, owner);
        }
        catch (error) {
            console.warn(error);
        }
        return 0;
    }
    getPreviousChildData(forField) {
        try {
            if (!this.parent)
                return 0;
            if (this.parent.children.length <= 1)
                return 0;
            let myIndex = this.parent.children.indexOf(this);
            let prevChild = this.parent.children[myIndex - 1];
            if (!prevChild)
                return 0;
            if (forField == "x") {
                return prevChild.x;
            }
            if (forField == "y") {
                return prevChild.y;
            }
            return NUtils.GetSpriteRealSize(forField, prevChild);
        }
        catch (error) {
            console.warn(error);
        }
        return 0;
    }
    requireFunc(funcName, args) {
        try {
            if (!this._requiredFuncs) {
                this._requiredFuncs = {};
            }
            this._requiredFuncs[funcName] = args;
        }
        catch (error) {
            console.warn(error);
        }
    }
    executeRequiredFuncs() {
        try {
            if (!this._requiredFuncs) {
                return;
            }
            for (let funcName in this._requiredFuncs) {
                try {
                    if (this[funcName]) {
                        this[funcName].apply(this, this._requiredFuncs[funcName]);
                    }
                    else {
                        console.warn(`Function ${funcName} not found in KNSprite.`);
                    }
                }
                catch (error) {
                    console.warn(`Error executing required function ${funcName}:`, error);
                }
            }
            this._requiredFuncs = null;
        }
        catch (error) {
            console.warn(error);
        }
    }
    executeLoadListeners() {
        try {
            if (!this._loadListeners) {
                return;
            }
            for (let i = 0; i < this._loadListeners.length; i++) {
                try {
                    this._loadListeners[i]();
                }
                catch (error) {
                    console.warn(error);
                }
            }
            this._loadListeners = null;
        }
        catch (error) {
            console.warn(error);
        }
    }
    _addLoadListener(func) {
        try {
            if (!this._loadListeners) {
                this._loadListeners = [];
            }
            this._loadListeners.push(func);
        }
        catch (error) {
            console.warn(error);
        }
    }
    _updateAnimationRules() {
        try {
            if (!this._animationRules) {
                return;
            }
            for (let i = 0; i < this._animationRules.length; i++) {
                this._animationRules[i].update();
                this._animationRules[i].applyAnimation(this);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _refreshAnchoredCenter() {
        try {
            if (this._lastCenterBaseX != this.x || this._lastCenterBaseY != this.y) {
                this._lastCenterBaseX = this.x;
                this._lastCenterBaseY = this.y;
            }
            this._anchoredCenterX = this._lastCenterBaseX + (this.realWidth() / 2);
            this._anchoredCenterY = this._lastCenterBaseY + (this.realHeight() / 2);
        }
        catch (error) {
            console.warn(error);
        }
    }
    _refreshRelativeToCenterPosition() {
        try {
            if (this._anchoredCenterX != null) {
                this.x = this._anchoredCenterX - (this.realWidth() * this.scale.x / 2);
                this.y = this._anchoredCenterY - (this.realHeight() * this.scale.y / 2);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _updateScaleFactor() {
        try {
            if (this.scale.x != this._scaleFactor || this.scale.y != this._scaleFactor) {
                this.scale.set(this._scaleFactor);
                if (this.isShouldAlwaysKeepCentered()) {
                    this._refreshRelativeToCenterPosition();
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _refreshBindings(dataObject = null, resursive = true) {
        let _isUseDataObjectForChildrens = true;
        if (!dataObject) {
            dataObject = this;
            _isUseDataObjectForChildrens = false;
        }
        let validDataBindings = this.dataBindings();
        if (this._uiJsonSchema) {
            let { bindings } = this._uiJsonSchema;
            if (bindings) {
                for (let key in bindings) {
                    if (!validDataBindings.hasOwnProperty(key)) {
                        continue;
                    }
                    try {
                        let value = NBindingsConverter.ConvertBindingValue(dataObject, bindings[key], this);
                        this.callBinding(key, value);
                    }
                    catch (error) {
                        console.warn(error);
                    }
                }
            }
        }
        if (resursive) {
            for (let child of this.children) {
                if (!child)
                    continue;
                try {
                    if (child['_refreshBindings']) {
                        if (_isUseDataObjectForChildrens) {
                            child['_refreshBindings'](dataObject, resursive);
                        }
                        else {
                            child['_refreshBindings'](null, resursive);
                        }
                    }
                }
                catch (error) {
                    console.warn(error);
                }
            }
        }
    }
}
class KNSpriteWithScheme extends KNSprite {
    constructor() {
        super();
        this._create();
    }
    _create() {
        KDNUI.FromScheme(this._scheme(), this);
    }
    _scheme() {
        return {
            "type": "group"
        };
    }
}
// * NUI 1.2
// * rev 10.09.24
// * "type": "face"
class KNSprite_ActorFace extends KNSprite {
    /**
     * Creates an instance of Sprite_ActorFace.
     * @param settings The settings for the sprite.
     */
    constructor(settings) {
        super();
        this.settings = Object.assign({}, KNSprite_ActorFace.DefaultSettings(), settings);
        this._create();
        this.draw(this.settings.faceName, this.settings.faceIndex);
        this.flipX(this.settings.mirror);
    }
    /**
     * Checks if the sprite is loaded.
     * @returns True if the sprite is loaded, otherwise false.
     */
    isLoaded() {
        return true;
    }
    /**
     * Gets the default settings for the sprite.
     * @returns The default settings.
     */
    static DefaultSettings() {
        return {
            "faceName": "",
            "faceIndex": 0,
            "size": 144,
            "mirror": false
        };
    }
    /**
     * Gets the real width of the sprite.
     * @returns The real width.
     */
    realWidth() {
        if (this.isNotHaveBounds())
            return 0;
        return this.settings.size;
    }
    /**
     * Gets the real height of the sprite.
     * @returns The real height.
     */
    realHeight() {
        if (this.isNotHaveBounds())
            return 0;
        return this.settings.size;
    }
    /**
     * Gets the data bindings for the sprite.
     * @returns The data bindings.
     */
    dataBindings() {
        return Object.assign(super.dataBindings(), {
            // * For compatibility with old format
            size: (v) => this.setSize(v),
            faceSize: (v) => this.setSize(v),
            faceName: (v) => this.draw(v, this.settings.faceIndex),
            faceIndex: (v) => this.draw(this.settings.faceName, v),
            mirror: (v) => this.flipX(v)
        });
    }
    /**
     * Sets the size of the sprite.
     * @param size The size to set.
     */
    setSize(size = 144) {
        try {
            size = this.convertStringSizeValue(size, 'width', this);
            if (size != null)
                this.settings.size = size;
            this._onResize();
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Draws the face image.
     * @param faceName The name of the face image.
     * @param faceIndex The index of the face image.
     */
    draw(faceName = "", faceIndex = 0) {
        try {
            this.settings.faceName = faceName;
            this.settings.faceIndex = faceIndex;
            if (faceName === "") {
                this.image.bitmap.clear();
                return;
            }
            this._drawFaceImage(faceName);
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Flips the sprite horizontally.
     * @param isMirror Whether to flip the sprite.
     */
    flipX(isMirror) {
        try {
            if (isMirror) {
                this.image.scale.x = -1;
                this.image.x = this.settings.size;
            }
            else {
                this.image.scale.x = 1;
                this.image.x = 0;
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Creates the sprite.
     */
    _create() {
        try {
            this.image = new KSprite(new Bitmap(1, 1));
            this.addChild(this.image);
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Draws the face image.
     * @param faceName The name of the face image.
     */
    _drawFaceImage(faceName) {
        try {
            this._srcBitmap = ImageManager.loadFace(faceName);
            this._srcBitmap.addLoadListener(this._onBitmapLoaded.bind(this));
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Called when the bitmap is loaded.
     */
    _onBitmapLoaded() {
        try {
            this._onResize();
            this.executeRequiredFuncs();
            this.executeLoadListeners();
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Resizes the sprite.
     */
    _onResize() {
        try {
            this.image.bitmap = new Bitmap(this.realWidth(), this.realHeight());
            if (!this._srcBitmap)
                return;
            const b = this._srcBitmap;
            let fw, fh;
            if (KDX.isMZ()) {
                fw = ImageManager.faceWidth;
                fh = ImageManager.faceHeight;
            }
            else {
                /* @ts-ignore */
                fw = Window_Base._faceWidth;
                /* @ts-ignore */
                fh = Window_Base._faceHeight;
            }
            const size = this.settings.size;
            const sx = (this.settings.faceIndex % 4) * fw;
            const sy = Math.floor(this.settings.faceIndex / 4) * fh;
            this.image.bitmap.blt(b, sx, sy, fw, fh, 0, 0, size, size);
            this.setFrame(0, 0, size, size);
            this.flipX(this.settings.mirror);
        }
        catch (e) {
            console.warn(e);
        }
    }
}
// * NUI 1.0
// * rev 10.09.24
// * "type": "circle"
class KNSprite_BaseCircle extends KNSprite {
    constructor(settings) {
        super();
        this._requestRedraw = false;
        this._settings = Object.assign({}, KNSprite_BaseCircle.DefaultSettings(), settings);
        this._create();
        this._applySettings();
    }
    // * DefaultSettings in JSON format (for easy copy-paste)
    /**
     * Returns the default settings for the base circle sprite.
     * @returns {BaseCircleSpriteSettings} The default settings.
     */
    static DefaultSettings() {
        return {
            "width": 100,
            "height": 100,
            "fillColor": "#FFFFFF",
            "fillAlpha": 1,
            "strokeWidth": 4,
            "strokeColor": "#000000",
            "strokeAlpha": 1
        };
    }
    /**
     * Gets the current settings of the base circle sprite.
     * @returns {BaseCircleSpriteSettings} The current settings.
     */
    get settings() {
        return this._settings;
    }
    /**
     * Applies the current settings to the sprite.
     */
    refresh() {
        try {
            this._applySettings();
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Returns an object with data bindings for width, height, size, stroke, and fill.
     * @returns {Record<string, any>} The data bindings.
     */
    dataBindings() {
        return Object.assign(super.dataBindings(), {
            width: (v) => { if (v)
                this.setSize(v, this.settings.height); },
            height: (v) => { if (v)
                this.setSize(this.settings.width, v); },
            size: (v) => { if (v)
                this.setSize(v.width, v.height); },
            stroke: (v) => { if (v)
                this.setStroke(v.color, v.width, v.alpha); },
            fill: (v) => { if (v)
                this.setFill(v.color, v.alpha); }
        });
    }
    /**
     * Sets the size of the base circle sprite.
     * @param {number | string} [width=100] - The width of the sprite.
     * @param {number | string} [height=100] - The height of the sprite.
     */
    setSize(width = 100, height = 100) {
        try {
            let _width = this.convertStringSizeValue(width, 'width', this);
            let _height = this.convertStringSizeValue(height, 'height', this);
            if (_width != null)
                this._settings.width = _width;
            if (_height != null)
                this._settings.height = _height;
            this.refresh();
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Sets the stroke properties of the base circle sprite.
     * @param {string} [color="#FFFFFF"] - The stroke color.
     * @param {number} [width=0] - The stroke width.
     * @param {number} [alpha=1] - The stroke alpha.
     */
    setStroke(color = "#FFFFFF", width = 0, alpha = 1) {
        this._settings.strokeColor = color;
        this._settings.strokeWidth = width;
        this._settings.strokeAlpha = alpha;
        this.refresh();
    }
    /**
     * Sets the fill properties of the base circle sprite.
     * @param {string} [color="#FFFFFF"] - The fill color.
     * @param {number} [alpha=1] - The fill alpha.
     */
    setFill(color = "#FFFFFF", alpha = 1) {
        this._settings.fillColor = color;
        this._settings.fillAlpha = alpha;
        this.refresh();
    }
    update() {
        super.update();
        if (this._requestRedraw) {
            this._redrawProcess();
            this._requestRedraw = false;
        }
    }
    /**
     * Creates the graphics object and adds it as a child.
     * @private
     */
    _create() {
        this._graphics = new PIXI.Graphics();
        this.addChild(this._graphics);
    }
    /**
     * Applies the current settings to the base circle sprite.
     * @private
     */
    _applySettings() {
        if (!this._settings)
            return;
        if (!this._graphics)
            return;
        this._applySize();
        this._requestRedraw = true;
    }
    _redrawProcess() {
        try {
            this._graphics.clear();
            this._drawBaseCircle();
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Draws the base circle with the current settings.
     * @private
     */
    _drawBaseCircle() {
        // * Fill circle
        this._graphics.beginFill(KColor.HexToColorNumber(this._settings.fillColor), this._settings.fillAlpha);
        this._graphics.drawEllipse(0, 0, this._settings.width / 2, this._settings.height / 2);
        this._graphics.endFill();
        if (this._settings.strokeWidth > 0) {
            // * Stroke circle
            this._graphics.lineStyle(this._settings.strokeWidth, KColor.HexToColorNumber(this._settings.strokeColor), this._settings.strokeAlpha);
            this._graphics.drawEllipse(0, 0, this._settings.width / 2, this._settings.height / 2);
        }
    }
    /**
     * Applies the size settings to the base circle sprite and its graphics object.
     * @private
     */
    _applySize() {
        this.width = this._settings.width;
        this.height = this._settings.height;
        // * Круг (элипс) рисуется от центра, что не удобно  при расчёте координат, поэтому сдвигаем в левый вверхний угол
        this._graphics.position.set(this._settings.width / 2, this._settings.height / 2);
    }
}
// * NUI 1.0
// * rev 19.06.25
// * "type": "rect"
class KNSprite_BaseRect extends KNSprite {
    constructor(settings) {
        super();
        this._baseRectDataBindingsCache = null;
        this._requestRedraw = false;
        this._settings = Object.assign({}, KNSprite_BaseRect.DefaultSettings(), settings);
        this._create();
        this._applySettings();
    }
    // * DefaultSettings in JSON format (for easy copy-paste)
    /**
     * Returns the default settings for the base rectangle sprite.
     * @returns {BaseRectSpriteSettings} The default settings.
     */
    static DefaultSettings() {
        return {
            "width": 100,
            "height": 100,
            "corners": 0,
            "fillGradient": null,
            "gradientStart": { "x": 0, "y": 0 },
            "gradientEnd": { "x": 0, "y": 100 },
            "fillColor": "#FFFFFF",
            "fillAlpha": 1,
            "strokeWidth": 4,
            "strokeColor": "#000000",
            "strokeAlpha": 1
        };
    }
    /**
     * Returns the default gradient settings.
     * @returns {Record<string, string>} The default gradient settings.
     */
    static DefaultGradientSettings() {
        return {
            "0": "#9ff",
            "1": "#033"
        };
    }
    /**
     * Returns the default corner settings.
     * @returns {RectCorners} The default corner settings.
     */
    static DefaultCornerSettings() {
        return {
            "topLeft": 0,
            "topRight": 0,
            "bottomRight": 0,
            "bottomLeft": 0
        };
    }
    /**
     * Gets the current settings of the base rectangle sprite.
     * @returns {BaseRectSpriteSettings} The current settings.
     */
    get settings() {
        return this._settings;
    }
    /**
     * Checks if the sprite has a gradient fill.
     * @returns {boolean} True if the sprite has a gradient fill, otherwise false.
     */
    isHaveGradient() {
        return this._settings.fillGradient != null;
    }
    /**
     * Applies the current settings to the sprite.
     */
    refresh() {
        try {
            this._applySettings();
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Returns an object with data bindings for width, height, size, stroke, fill, gradient start, and gradient end.
     * @returns {Record<string, any>} The data bindings.
     */
    dataBindings() {
        if (!this._baseRectDataBindingsCache) {
            this._baseRectDataBindingsCache = Object.assign(super.dataBindings(), {
                width: (v) => { if (v)
                    this.setSize(v, this.settings.height); },
                height: (v) => { if (v)
                    this.setSize(this.settings.width, v); },
                size: (v) => { if (v)
                    this.setSize(v.width, v.height); },
                stroke: (v) => { if (v)
                    this.setStroke(v.color, v.width, v.alpha); },
                fill: (v) => { if (v)
                    this.setFill(v.color, v.alpha); },
                gradientStart: (v) => { if (v)
                    this.setGradientStartEnd(v, this.settings.gradientEnd); },
                gradientEnd: (v) => { if (v)
                    this.setGradientStartEnd(this.settings.gradientStart, v); }
            });
        }
        return this._baseRectDataBindingsCache;
    }
    /**
     * Sets the size of the base rectangle sprite.
     * @param {number | string} [width=100] - The width of the sprite.
     * @param {number | string} [height=100] - The height of the sprite.
     */
    setSize(width = 100, height = 100) {
        try {
            let _width = this.convertStringSizeValue(width, 'width', this);
            let _height = this.convertStringSizeValue(height, 'height', this);
            if (_width != null)
                this._settings.width = _width;
            if (_height != null)
                this._settings.height = _height;
            this.refresh();
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Sets the stroke properties of the base rectangle sprite.
     * @param {string} [color="#FFFFFF"] - The stroke color.
     * @param {number} [width=0] - The stroke width.
     * @param {number} [alpha=1] - The stroke alpha.
     */
    setStroke(color = "#FFFFFF", width = 0, alpha = 1) {
        this._settings.strokeColor = color;
        this._settings.strokeWidth = width;
        this._settings.strokeAlpha = alpha;
        this.refresh();
    }
    /**
     * Sets the fill properties of the base rectangle sprite.
     * @param {string} [color="#FFFFFF"] - The fill color.
     * @param {number} [alpha=1] - The fill alpha.
     */
    setFill(color = "#FFFFFF", alpha = 1) {
        this._settings.fillColor = color;
        this._settings.fillAlpha = alpha;
        this._settings.fillGradient = null;
        this.refresh();
    }
    /**
     * Sets the gradient start and end points for the base rectangle sprite.
     * @param {{ x: number, y: number }} start - The start point of the gradient.
     * @param {{ x: number, y: number }} end - The end point of the gradient.
     */
    setGradientStartEnd(start, end) {
        try {
            if (start) {
                start.x = this.convertStringSizeValue(start.x, 'width', this);
                start.y = this.convertStringSizeValue(start.y, 'height', this);
            }
            if (end) {
                end.x = this.convertStringSizeValue(end.x, 'width', this);
                end.y = this.convertStringSizeValue(end.y, 'height', this);
            }
            this._settings.gradientStart = start;
            this._settings.gradientEnd = end;
            this.refresh();
        }
        catch (error) {
            console.warn(error);
        }
    }
    update() {
        super.update();
        if (this._requestRedraw) {
            this._redrawProcess();
            this._requestRedraw = false;
        }
    }
    /**
     * Creates the graphics object and adds it as a child.
     * @private
     */
    _create() {
        this._graphics = new PIXI.Graphics();
        this.addChild(this._graphics);
    }
    /**
     * Applies the current settings to the base rectangle sprite.
     * @private
     */
    _applySettings() {
        if (!this._settings)
            return;
        if (!this._graphics)
            return;
        this._applySize();
        this._requestRedraw = true;
    }
    _redrawProcess() {
        try {
            this._graphics.clear();
            this._applyGradient();
            this._drawCornerRect();
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Applies the gradient fill to the base rectangle sprite.
     * @private
     */
    _applyGradient() {
        try {
            if (!this.isHaveGradient())
                return;
            if (KDX.isMV())
                return;
            let gradientFillSettings = Object.assign({}, KNSprite_BaseRect.DefaultGradientSettings(), this._settings.fillGradient);
            let canvas = document.createElement("canvas");
            let ctx = canvas.getContext("2d");
            let gradient = ctx.createLinearGradient(this._settings.gradientStart.x, this._settings.gradientStart.y, this._settings.gradientEnd.x, this._settings.gradientEnd.y);
            for (let key in gradientFillSettings) {
                let color = this._convertGradientStopColor(gradientFillSettings[key]);
                gradient.addColorStop(Number(key), color);
            }
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, this._settings.width, this._settings.height);
            let texture = PIXI.Texture.from(canvas);
            this._graphics.beginTextureFill({ texture: texture });
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Converts a gradient stop color to a CSS color string.
     * @param {string} color - The color to convert.
     * @returns {string} The converted color.
     * @private
     */
    _convertGradientStopColor(color) {
        if (!KString.any(color))
            return "#000000";
        try {
            if (color.includes("%")) {
                let [hex, opacity] = color.split("%");
                return KColor.HexToCss(hex, parseFloat(opacity));
            }
            else {
                return color;
            }
        }
        catch (error) {
            console.warn(error);
        }
        return "#000000";
    }
    /**
     * Draws the rectangle with rounded corners.
     * @private
     */
    _drawCornerRect() {
        try {
            if (typeof this._settings.corners == "number") {
                this._drawRoundRect(this._settings.corners);
            }
            else {
                let corners = Object.assign({}, KNSprite_BaseRect.DefaultCornerSettings(), this.settings.corners);
                this._drawAllCornersRect(corners);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Draws a rounded rectangle.
     * @param {number} radius - The radius of the corners.
     * @private
     */
    _drawRoundRect(radius) {
        if (!this.isHaveGradient()) {
            this._graphics.beginFill(KColor.HexToColorNumber(this._settings.fillColor), this._settings.fillAlpha);
        }
        this._graphics.drawRoundedRect(0, 0, this._settings.width, this._settings.height, radius);
        if (this._settings.strokeWidth > 0) {
            let strokeWidth = this._settings.strokeWidth;
            // * Draw Stroke Around the Rect
            this._graphics.lineStyle(this._settings.strokeWidth, KColor.HexToColorNumber(this._settings.strokeColor), this._settings.strokeAlpha);
            this._graphics.drawRoundedRect(-strokeWidth / 2, -strokeWidth / 2, this._settings.width + strokeWidth / 2, this._settings.height + strokeWidth / 2, radius);
        }
        if (!this.isHaveGradient()) {
            this._graphics.endFill();
        }
    }
    /**
     * Draws a rectangle with different corner radii.
     * @param {RectCorners} corners - The radii of the corners.
     * @private
     */
    _drawAllCornersRect(corners) {
        if (!this.isHaveGradient()) {
            this._graphics.beginFill(KColor.HexToColorNumber(this._settings.fillColor), this._settings.fillAlpha);
        }
        this._drawRoundedRectComplex(0, 0, this._settings.width, this._settings.height, corners.topLeft, corners.topRight, corners.bottomRight, corners.bottomLeft);
        if (this._settings.strokeWidth > 0) {
            let strokeWidth = this._settings.strokeWidth;
            // * Draw Stroke Around the Rect
            this._graphics.lineStyle(this._settings.strokeWidth, KColor.HexToColorNumber(this._settings.strokeColor), this._settings.strokeAlpha);
            this._drawRoundedRectComplex(-strokeWidth / 2, -strokeWidth / 2, this._settings.width + strokeWidth / 2, this._settings.height + strokeWidth / 2, corners.topLeft, corners.topRight, corners.bottomRight, corners.bottomLeft);
            // this._graphics.closePath();
        }
        if (!this.isHaveGradient()) {
            this._graphics.endFill();
        }
    }
    /**
     * Draws a complex rounded rectangle with different corner radii.
     * @param {number} x - The x-coordinate of the rectangle.
     * @param {number} y - The y-coordinate of the rectangle.
     * @param {number} width - The width of the rectangle.
     * @param {number} height - The height of the rectangle.
     * @param {number} radiusTL - The radius of the top-left corner.
     * @param {number} radiusTR - The radius of the top-right corner.
     * @param {number} radiusBR - The radius of the bottom-right corner.
     * @param {number} radiusBL - The radius of the bottom-left corner.
     * @private
     */
    _drawRoundedRectComplex(x, y, width, height, radiusTL, radiusTR, radiusBR, radiusBL) {
        this._graphics.moveTo(x + radiusTL, y);
        this._graphics.lineTo(x + width - radiusTR, y);
        if (radiusTR > 0)
            this._graphics.quadraticCurveTo(x + width, y, x + width, y + radiusTR);
        this._graphics.lineTo(x + width, y + height - radiusBR);
        if (radiusBR > 0)
            this._graphics.quadraticCurveTo(x + width, y + height, x + width - radiusBR, y + height);
        this._graphics.lineTo(x + radiusBL, y + height);
        if (radiusBL > 0)
            this._graphics.quadraticCurveTo(x, y + height, x, y + height - radiusBL);
        this._graphics.lineTo(x, y + radiusTL);
        if (radiusTL > 0)
            this._graphics.quadraticCurveTo(x, y, x + radiusTL, y);
    }
    /**
     * Applies the size settings to the base rectangle sprite and its graphics object.
     * @private
     */
    _applySize() {
        this.width = this._settings.width;
        this.height = this._settings.height;
    }
}
class KNSprite_Button extends KNSprite {
    constructor(_settings) {
        super();
        this._settings = _settings;
        this._isForcePressed = false;
        this._buttonDataBindingsCache = null;
        this._settings = Object.assign(KNSprite_Button.DefaultSettings(), _settings);
        this._create();
        this._applySettings();
    }
    static DefaultSettings() {
        return {
            "imageName": "",
            "folderName": "pictures",
            "imageMargins": 20,
            "width": 160,
            "height": 60,
            "clickSe": "Cursor1",
            "desaturateWhenDisabled": false,
            "tint": "",
            "tintAlpha": 0.5,
            "overTint": "#FFFFDD",
            "overTintAlpha": 0.5,
            "activeTint": "#AAAAAA",
            "activeTintAlpha": 0.5,
            "disabledTint": "#AAAAAA",
            "disabledTintAlpha": 0.5,
            "keyboardKey": "",
            "keyboardHandled": true,
            "enabled": true,
        };
    }
    isCanHandleTouch() {
        return true;
    }
    isSupportKeyboardHandle() {
        return this._settings.keyboardHandled == true;
    }
    isClickEnabled() {
        return super.isClickEnabled() && this.opacity != 0;
    }
    onPress() {
        super.onPress();
        this._refreshTint();
    }
    onReleased() {
        super.onReleased();
        this._refreshTint();
    }
    onMouseEnter() {
        super.onMouseEnter();
        this._refreshTint();
    }
    onMouseExit() {
        super.onMouseExit();
        this._refreshTint();
    }
    onClick() {
        try {
            if (this.isDisabled())
                return;
            if (this.isClickEnabled()) {
                KAudio.PlaySE(this._settings.clickSe);
            }
            super.onClick();
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Gets the current settings of the Button.
     * @returns {ButtonSpriteSettings} The current settings.
     */
    get settings() {
        return this._settings;
    }
    /**
     * Returns an object with data bindings for width, height, and size.
     * @returns {Record<string, any>} The data bindings.
     */
    dataBindings() {
        if (!this._buttonDataBindingsCache) {
            this._buttonDataBindingsCache = Object.assign(super.dataBindings(), {
                width: (v) => { if (v)
                    this.setSize(v, this.settings.height); },
                height: (v) => { if (v)
                    this.setSize(this.settings.width, v); },
                size: (v) => { if (v)
                    this.setSize(v.width, v.height); },
                style: (v) => { if (KDX.any(v))
                    this.setStyle(v); },
                enable: (v) => { if (KDX.any(v))
                    this.setEnabledState(v); },
                handler: (v) => { this.addClickHandler(v); }
            });
        }
        return this._buttonDataBindingsCache;
    }
    setStyle(style) {
        this._settings = Object.assign(this._settings, style);
        this._applySettings();
    }
    /**
     * Sets the size of the sprite button.
     *
     * @param {number | string} [width=160] - The width of the button. Can be a number or a string.
     * @param {number | string} [height=60] - The height of the button. Can be a number or a string.
     *
     * @throws {Error} Will throw an error if the width or height cannot be converted.
     */
    setSize(width = 160, height = 60) {
        try {
            let _width = this.convertStringSizeValue(width, 'width', this);
            let _height = this.convertStringSizeValue(height, 'height', this);
            if (_width != null)
                this._settings.width = _width;
            if (_height != null)
                this._settings.height = _height;
            this._applySettings();
        }
        catch (error) {
            console.warn(error);
        }
    }
    realWidth() {
        if (this.isNotHaveBounds())
            return 0;
        return this._settings.width;
    }
    realHeight() {
        if (this.isNotHaveBounds())
            return 0;
        return this._settings.height;
    }
    update() {
        super.update();
        if (this.isClickEnabled()) {
            this._updateButtonKeyboardHandling();
        }
    }
    isEnabled() {
        return !this.isDisabled();
    }
    setEnabledState(enabled) {
        try {
            this._settings.enabled = enabled;
            if (enabled) {
                this._enable();
            }
            else {
                this._disable();
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    addClickHandler(handler) {
        this._handleOkAction = handler;
    }
    // * Only visual
    simulateClickEffect() {
        this._isForcePressed = true;
        setTimeout(() => {
            try {
                this._isForcePressed = false;
                this._refreshTint();
            }
            catch (error) {
                console.warn(error);
            }
        }, 100);
        this._refreshTint();
    }
    enable() {
        this.setEnabledState(true);
    }
    disable() {
        this.setEnabledState(false);
    }
    _create() {
        this._buttonPlane = new KNSprite_Plane({
            "width": this._settings.width,
            "height": this._settings.height,
            "margins": this._settings.imageMargins,
            "imageName": this._settings.imageName,
            "folderName": this._settings.folderName,
        });
        this.addChild(this._buttonPlane);
    }
    _applySettings() {
        try {
            this._onResize();
            this._refreshTint();
            this._refreshState();
        }
        catch (error) {
            console.warn(error);
        }
    }
    _onResize() {
        try {
            this.width = this._settings.width;
            this.height = this._settings.height;
            this._buttonPlane.setSize(this._settings.width, this._settings.height);
        }
        catch (error) {
            console.warn(error);
        }
    }
    _refreshTint() {
        try {
            if (this.isPressed() || this._isForcePressed) {
                this._applyTint(this._settings.activeTint, this._settings.activeTintAlpha);
            }
            else if (this.isHovered()) {
                this._applyTint(this._settings.overTint, this._settings.overTintAlpha);
            }
            else {
                this._applyTint(this._settings.tint, this._settings.tintAlpha);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _applyTint(color, alpha = 0.5) {
        try {
            if (!KString.any(color)) {
                this._buttonPlane.removeEffect(KNSpriteEffects.Tint);
                return;
            }
            else {
                let tintColor = KColor.HexToColorNumber(color);
                this._buttonPlane.addTintEffect({
                    "color": tintColor,
                    "alpha": alpha
                });
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _refreshState() {
        try {
            this.setEnabledState(this._settings.enabled);
        }
        catch (error) {
            console.warn(error);
        }
    }
    _enable() {
        this._isDisabled = false;
        try {
            if (this._settings.desaturateWhenDisabled) {
                this.removeEffect(KNSpriteEffects.Desaturate);
            }
            this._refreshTint();
        }
        catch (error) {
            console.warn(error);
        }
    }
    _disable() {
        try {
            this._isDisabled = true;
            if (this._settings.desaturateWhenDisabled) {
                this.addDesaturateEffect();
            }
            else if (KString.any(this._settings.disabledTint)) {
                this._applyTint(this._settings.disabledTint, this._settings.disabledTintAlpha);
            }
            else {
                this._applyTint(this._settings.tint, this._settings.tintAlpha);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _updateButtonKeyboardHandling() {
        if (KString.any(this._settings.keyboardKey)) {
            if (Input.isTriggered(this._settings.keyboardKey)) {
                try {
                    Input.clear();
                    this.onClick();
                }
                catch (error) {
                    console.warn(error);
                }
            }
        }
    }
    _activateHandlerVisually() {
        try {
            if (this.isDisabled()) {
                super._activateHandlerVisually();
                return;
            }
            this._applyTint(this._settings.overTint, this._settings.overTintAlpha);
        }
        catch (error) {
            console.warn(error);
        }
    }
    _deactivateHandlerVisually() {
        try {
            if (this.isDisabled()) {
                super._deactivateHandlerVisually();
                return;
            }
            this._refreshTint();
        }
        catch (error) {
            console.warn(error);
        }
    }
}
// * NUI 1.1
// * rev 19.06.25
// * "type": "gauge"
class KNSprite_Gauge extends KNSprite {
    constructor(_settings) {
        super();
        this._settings = _settings;
        this._gaugeDataBindingsCache = null;
        this._settings = Object.assign({}, KNSprite_Gauge.DefaultSettings(), _settings);
        this._loaded = false;
        this._lastValue = 1;
        this._create();
        this._applySettings();
    }
    /**
     * Returns the default settings for the gauge sprite.
     * @returns {GaugeSpriteSettings} The default settings.
     */
    static DefaultSettings() {
        return {
            "fillMode": "color",
            "fillColor": "#ffffff",
            "fillOpacity": 255,
            "imageName": "",
            "folderName": "pictures",
            "margins": 2,
            "width": "auto",
            "height": "auto",
            "mask": "",
            "backColor": "#000000",
            "backImage": "",
            "backOpacity": 255,
            "vertical": false
        };
    }
    /**
     * Checks if the gauge sprite is loaded.
     * @returns {boolean} True if loaded, otherwise false.
     */
    isLoaded() {
        try {
            return this._loaded === true;
        }
        catch (e) {
            console.warn(e);
        }
        return false;
    }
    /**
     * Gets the real width of the gauge sprite.
     * @returns {number} The real width.
     */
    realWidth() {
        try {
            if (this.isNotHaveBounds())
                return 0;
            if (this._settings.width !== "auto") {
                return this._settings.width;
            }
            else if (this._gaugeSpr) {
                return this._gaugeSpr.realWidth();
            }
        }
        catch (e) {
            console.warn(e);
        }
        return this.width;
    }
    /**
     * Gets the real height of the gauge sprite.
     * @returns {number} The real height.
     */
    realHeight() {
        try {
            if (this.isNotHaveBounds())
                return 0;
            if (this._settings.height !== "auto") {
                return this._settings.height;
            }
            else if (this._gaugeSpr) {
                return this._gaugeSpr.realHeight();
            }
        }
        catch (e) {
            console.warn(e);
        }
        return this.height;
    }
    /**
     * Returns an object with data bindings for width, height, size, rate, fillImage, fillColor, and fillOpacity.
     * @returns {Record<string, any>} The data bindings.
     */
    dataBindings() {
        if (!this._gaugeDataBindingsCache) {
            this._gaugeDataBindingsCache = Object.assign(super.dataBindings(), {
                width: (v) => { if (v)
                    this.setSize(v, this._settings.height); },
                height: (v) => { if (v)
                    this.setSize(this._settings.width, v); },
                size: (v) => { if (v)
                    this.setSize(v.width, v.height); },
                rate: (v) => { if (v)
                    this.draw(v); },
                fillImage: (v) => { if (v)
                    this.setFillImage(v); },
                fillColor: (v) => { if (v)
                    this.setFillColor(v); },
                fillOpacity: (v) => { if (v)
                    this.setFillOpacity(v); }
            });
        }
        return this._gaugeDataBindingsCache;
    }
    /**
     * Draws the gauge with the specified percentage.
     * @param {number} [percent=1] - The percentage to draw.
     */
    draw(percent = 1) {
        try {
            if (!this.isLoaded()) {
                this.requireFunc('draw', arguments);
                return;
            }
            this._lastValue = percent;
            this._drawGauge(percent);
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Sets the fill opacity of the gauge.
     * @param {number} opacity - The fill opacity.
     */
    setFillOpacity(opacity) {
        try {
            this._settings.fillOpacity = opacity;
            if (this._fillLayer) {
                this._fillLayer.opacity = opacity;
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Sets the fill color of the gauge.
     * @param {string} color - The fill color.
     */
    setFillColor(color) {
        try {
            this._settings.fillColor = color;
            if (this._fillColorBitmap) {
                this._createColorGaugeFillColorBitmap();
                this._drawGauge(this._lastValue);
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Sets the fill image of the gauge.
     * @param {string} imageName - The name of the fill image.
     */
    setFillImage(imageName) {
        try {
            this._settings.imageName = imageName;
            this._applySettings();
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Sets the size of the gauge sprite.
     * @param {number | string} [width="auto"] - The width of the sprite.
     * @param {number | string} [height="auto"] - The height of the sprite.
     */
    setSize(width = "auto", height = "auto") {
        try {
            if (width !== "auto") {
                width = this.convertStringSizeValue(width, 'width', this);
            }
            if (height !== "auto") {
                height = this.convertStringSizeValue(height, 'height', this);
            }
            if (width == this._settings.width && height == this._settings.height) {
                return;
            }
            if (width)
                this._settings.width = width;
            if (height)
                this._settings.height = height;
            this._applySettings();
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Creates the base layer sprite.
     * @private
     */
    _create() {
        this._gaugeBaseLayer = new KSprite();
        this.addChild(this._gaugeBaseLayer);
    }
    /**
     * Applies the current settings to the gauge sprite.
     * @private
     */
    _applySettings() {
        try {
            this._loaded = false;
            this._createGaugeFromSettings();
            this.draw(this._lastValue);
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Destroys the existing gauge sprite.
     * @private
     */
    _destroyExistGauge() {
        try {
            if (!this._gaugeSpr)
                return;
            this._gaugeSpr.removeFromParent();
            this._gaugeSpr = null;
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Creates the gauge sprite based on the current settings.
     * @private
     */
    _createGaugeFromSettings() {
        try {
            this._destroyExistGauge();
            this._gaugeSpr = new KNSprite();
            this._gaugeBaseLayer.addChild(this._gaugeSpr);
            switch (this._settings.fillMode) {
                case "image":
                    this._createImageGauge();
                    break;
                case "plane":
                    this._createPlaneGauge();
                    break;
                case "color":
                    this._createColorGauge();
                    break;
                default:
                    console.warn("Unknown Gauge fillMode: " + this._settings.fillMode);
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Creates the image gauge.
     * @private
     */
    _createImageGauge() {
        try {
            this._gaugeSourceImage = new KNSprite_Image({
                imageName: this._settings.imageName,
                folderName: this._settings.folderName,
                width: this._settings.width,
                height: this._settings.height
            });
            this._gaugeSourceImage.addLoadListener(this._onGaugeFillImageLoaded.bind(this));
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Handles the event when the gauge fill image is loaded.
     * @private
     */
    _onGaugeFillImageLoaded() {
        try {
            //@ts-ignore
            this._gaugeSourceImage._resizeProcess();
            let width = this._gaugeSourceImage.realWidth();
            let height = this._gaugeSourceImage.realHeight();
            this._addBackground(width, height);
            if (this._fillLayer) {
                this._fillLayer.removeFromParent();
            }
            this._fillLayer = new KSprite(new Bitmap(width, height));
            this._fillLayer.opacity = this._settings.fillOpacity;
            this._gaugeSpr.addChild(this._fillLayer);
            this._addMask();
            this._onGaugeLoadedAndReady();
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Handles the event when the gauge is loaded and ready.
     * @private
     */
    _onGaugeLoadedAndReady() {
        try {
            this._loaded = true;
            this.width = this.realWidth();
            this.height = this.realHeight();
            this.executeRequiredFuncs();
            this.executeLoadListeners();
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Creates the plane gauge.
     * @private
     */
    _createPlaneGauge() {
        try {
            // * Нельзя создать Plane Gauge с auto размером, поэтому задаём стандартные значения
            if (this._settings.width === "auto")
                this._settings.width = 80;
            if (this._settings.height === "auto")
                this._settings.height = 20;
            this._addBackground(this._settings.width, this._settings.height);
            this._fillLayer = new KNSprite_Plane({
                imageName: this._settings.imageName,
                folderName: this._settings.folderName,
                width: this._settings.width,
                height: this._settings.height,
                margins: this._settings.margins
            });
            this._fillLayer.opacity = this._settings.fillOpacity;
            this._gaugeSpr.addChild(this._fillLayer);
            this._addMask();
            this._onGaugeLoadedAndReady();
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Creates the color gauge.
     * @private
     */
    _createColorGauge() {
        try {
            // * Нельзя создать цветную Gauge с auto размером, поэтому задаём стандартные значения
            if (this._settings.width === "auto")
                this._settings.width = 80;
            if (this._settings.height === "auto")
                this._settings.height = 20;
            this._addBackground(this._settings.width, this._settings.height);
            this._fillLayer = new KSprite(new Bitmap(this._settings.width, this._settings.height));
            this._fillLayer.opacity = this._settings.fillOpacity;
            this._createColorGaugeFillColorBitmap();
            this._gaugeSpr.addChild(this._fillLayer);
            this._addMask();
            this._onGaugeLoadedAndReady();
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Creates the fill color bitmap for the color gauge.
     * @private
     */
    _createColorGaugeFillColorBitmap() {
        try {
            this._fillColorBitmap = new Bitmap(this._settings.width, this._settings.height);
            this._fillColorBitmap.fillAll(this._settings.fillColor);
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Adds the background to the gauge sprite.
     * @param {number} width - The width of the background.
     * @param {number} height - The height of the background.
     * @private
     */
    _addBackground(width, height) {
        try {
            if (!this._gaugeSpr)
                return;
            let background = null;
            if (KString.any(this._settings.backImage)) {
                background = this._createGaugeBackgroundImage();
            }
            else if (KString.any(this._settings.backColor)) {
                background = this._createGaugeBackgroundColor(width, height, this._settings.backColor);
            }
            if (background) {
                if (this._settings.backOpacity) {
                    background.opacity = this._settings.backOpacity;
                }
                this._gaugeSpr.addChild(background);
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Adds the mask to the gauge sprite.
     * @private
     */
    _addMask() {
        try {
            if (!this._gaugeSpr)
                return;
            if (!KString.any(this._settings.mask))
                return;
            const gaugeMask = new KNSprite_Image({
                imageName: this._settings.mask,
                folderName: this._settings.folderName,
                width: this._settings.width,
                height: this._settings.height
            });
            this._gaugeSpr.mask = gaugeMask.image;
            this._gaugeSpr.addChild(gaugeMask);
        }
        catch (e) {
            console.warn(e);
            this._gaugeSpr.mask = null;
        }
    }
    /**
     * Creates the background color for the gauge sprite.
     * @param {number} width - The width of the background.
     * @param {number} height - The height of the background.
     * @param {string} color - The color of the background.
     * @returns {KSprite} The background sprite.
     * @private
     */
    _createGaugeBackgroundColor(width, height, color) {
        try {
            const background = new KSprite(new Bitmap(width, height));
            background.fillAll(color);
            return background;
        }
        catch (e) {
            console.warn(e);
            return new KSprite();
        }
    }
    /**
     * Creates the background image for the gauge sprite.
     * @returns {KNSprite_Image} The background image sprite.
     * @private
     */
    _createGaugeBackgroundImage() {
        try {
            return new KNSprite_Image({
                imageName: this._settings.backImage,
                folderName: this._settings.folderName,
                width: this._settings.width,
                height: this._settings.height
            });
        }
        catch (e) {
            console.warn(e);
            return new KNSprite();
        }
    }
    /**
     * Draws the gauge with the specified percentage.
     * @param {number} percent - The percentage to draw.
     * @private
     */
    _drawGauge(percent) {
        try {
            if (!this._fillLayer)
                return;
            if (this._settings.vertical == true) {
                this._drawVertical(percent);
            }
            else {
                this._drawHorizontal(percent);
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Draws the horizontal gauge based on the fill mode and percentage.
     * @param {number} percent - The percentage to fill the gauge.
     */
    _drawHorizontal(percent) {
        try {
            switch (this._settings.fillMode) {
                case "image":
                    this._drawImageGauge(percent);
                    break;
                case "plane":
                    this._drawPlaneGauge(percent);
                    break;
                case "color":
                    this._drawColorGauge(percent);
                    break;
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Draws the image gauge with the specified percentage.
     * @param {number} percent - The percentage to draw.
     * @private
     */
    _drawImageGauge(percent) {
        try {
            this._fillLayer.bitmap.clear();
            const fillBitmap = this._gaugeSourceImage.image.bitmap;
            this._drawGaugeBitmapBased(percent, fillBitmap);
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Draws the gauge based on the specified bitmap and percentage.
     * @param {number} percent - The percentage to draw.
     * @param {Bitmap} fillBitmap - The bitmap to use for drawing.
     * @private
     */
    _drawGaugeBitmapBased(percent, fillBitmap) {
        try {
            const w = this.realWidth() * percent;
            const h = this.realHeight();
            this._fillLayer.bitmap.blt(fillBitmap, 0, 0, w, h, 0, 0);
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Draws the horizontal color gauge based on the percentage.
     * @param {number} percent - The percentage to fill the gauge.
     */
    _drawColorGauge(percent) {
        try {
            this._fillLayer.bitmap.clear();
            const fillBitmap = this._fillColorBitmap;
            this._drawGaugeBitmapBased(percent, fillBitmap);
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Draws the horizontal plane gauge based on the percentage.
     * @param {number} percent - The percentage to fill the gauge.
     */
    _drawPlaneGauge(percent) {
        try {
            const w = this.realWidth() * percent;
            const h = this.realHeight();
            if (this._fillLayer['setSize'])
                this._fillLayer['setSize'](w, h);
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Draws the vertical gauge based on the fill mode and percentage.
     * @param {number} percent - The percentage to fill the gauge.
     */
    _drawVertical(percent) {
        try {
            switch (this._settings.fillMode) {
                case "image":
                    this._drawImageGaugeVertical(percent);
                    break;
                case "plane":
                    this._drawPlaneGaugeVertical(percent);
                    break;
                case "color":
                    this._drawColorGaugeVertical(percent);
                    break;
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Draws the vertical image gauge based on the percentage.
     * @param {number} percent - The percentage to fill the gauge.
     */
    _drawImageGaugeVertical(percent) {
        try {
            this._fillLayer.bitmap.clear();
            const fillBitmap = this._gaugeSourceImage.image.bitmap;
            this._drawGaugeBitmapBasedVertical(percent, fillBitmap);
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Draws the vertical gauge based on the bitmap and percentage.
     * @param {number} percent - The percentage to fill the gauge.
     * @param {Bitmap} fillBitmap - The bitmap to use for the gauge.
     */
    _drawGaugeBitmapBasedVertical(percent, fillBitmap) {
        try {
            const w = this.realWidth();
            const h = this.realHeight() * percent;
            this._fillLayer.bitmap.blt(fillBitmap, 0, 0, w, h, 0, 0);
            this._fillLayer.y = this.realHeight() - h;
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Draws the vertical color gauge based on the percentage.
     * @param {number} percent - The percentage to fill the gauge.
     */
    _drawColorGaugeVertical(percent) {
        try {
            this._fillLayer.bitmap.clear();
            const fillBitmap = this._fillColorBitmap;
            this._drawGaugeBitmapBasedVertical(percent, fillBitmap);
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Draws the vertical plane gauge based on the percentage.
     * @param {number} percent - The percentage to fill the gauge.
     */
    _drawPlaneGaugeVertical(percent) {
        try {
            const w = this.realWidth();
            const h = this.realHeight() * percent;
            if (this._fillLayer['setSize'])
                this._fillLayer['setSize'](w, h);
            this._fillLayer.y = this.realHeight() - h;
        }
        catch (e) {
            console.warn(e);
        }
    }
}
//NUI 1.0
//rev 19.06.25
//"type": "group"
class KNSprite_Group extends KNSprite {
    constructor(_settings) {
        super();
        this._settings = _settings;
        this._isNeedWaitLoadingChild = false;
        this._groupDataBindingsCache = null;
        this._settings = Object.assign({}, KNSprite_Group.DefaultSettings(), _settings);
        if (this._settings.horizontalNavigation === true) {
            this.isVerticalKeyboardNavigation = () => false;
        }
        if (this._settings.freeNavigation === true) {
            this.isFreeKeyboardNavigation = () => true;
        }
        this._applySettings();
        this._onResize();
    }
    /**
     * Gets the current settings of the image sprite.
     * @returns {GroupSpriteSettings} The current settings.
     */
    get settings() {
        return this._settings;
    }
    /**
     * Returns the default settings for the sprite group.
     * @returns {GroupSpriteSettings} The default settings.
     */
    static DefaultSettings() {
        return {
            "keyboardHandling": false,
            "horizontalNavigation": false,
            "freeNavigation": false,
            "width": "auto",
            "height": "auto"
        };
    }
    /**
     * Returns an object with data bindings for width, height, and size.
     * @returns {Record<string, any>} The data bindings.
     */
    dataBindings() {
        if (!this._groupDataBindingsCache) {
            this._groupDataBindingsCache = Object.assign(super.dataBindings(), {
                width: (v) => { if (v)
                    this.setSize(v, this._settings.height); },
                height: (v) => { if (v)
                    this.setSize(this._settings.width, v); },
                size: (v) => { if (v)
                    this.setSize(v.width, v.height); }
            });
        }
        return this._groupDataBindingsCache;
    }
    /**
     * Updates the sprite group.
     */
    update() {
        super.update();
        try {
            if (this._isNeedWaitLoadingChild === true) {
                this.refreshBindings(this._dataObjectRef, true);
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Refreshes the bindings for the sprite group.
     * @param {object} dataObject - The data object to bind.
     * @param {boolean} recursive - Whether to refresh bindings recursively.
     */
    refreshBindings(dataObject, recursive) {
        super.refreshBindings(dataObject, recursive);
        for (const c of this.children) {
            if (c instanceof KNSprite) {
                if (!c.isLoaded()) {
                    this._startWaitLoading(dataObject);
                    return;
                }
            }
        }
        this._isNeedWaitLoadingChild = false;
    }
    /**
     * Starts waiting for a child to load.
     * @param {object} dataObjectRef - The data object reference.
     */
    _startWaitLoading(dataObjectRef) {
        try {
            this._dataObjectRef = dataObjectRef;
            this._isNeedWaitLoadingChild = true;
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Sets the size of the sprite group.
     * @param {number | string} [width="auto"] - The width of the sprite group.
     * @param {number | string} [height="auto"] - The height of the sprite group.
     */
    setSize(width = 'auto', height = 'auto') {
        try {
            if (width !== "auto") {
                width = this.convertStringSizeValue(width, 'width', this);
            }
            if (height !== "auto") {
                height = this.convertStringSizeValue(height, 'height', this);
            }
            if (width != null)
                this._settings.width = width;
            if (height != null)
                this._settings.height = height;
            this._onResize();
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Gets the real width of the sprite group.
     * @returns {number} The real width.
     */
    realWidth() {
        try {
            if (this.isNotHaveBounds())
                return 0;
            if (this._settings.width === "auto") {
                return this._calculateMax("x", "width");
            }
        }
        catch (e) {
            console.warn(e);
        }
        return this._settings.width;
    }
    /**
     * Gets the real height of the sprite group.
     * @returns {number} The real height.
     */
    realHeight() {
        try {
            if (this.isNotHaveBounds())
                return 0;
            if (this._settings.height === "auto") {
                return this._calculateMax("y", "height");
            }
        }
        catch (e) {
            console.warn(e);
        }
        return this._settings.height;
    }
    /**
     * Calculates the maximum size of the sprite group.
     * @param {'x' | 'y'} axis - The axis to calculate.
     * @param {string} b - The size property to calculate.
     * @returns {number} The maximum size.
     */
    _calculateMax(axis, b) {
        let value = 0;
        try {
            for (const child of this.children) {
                const size = child[axis] + NUtils.GetSpriteRealSize(b, child);
                if (size > value)
                    value = size;
            }
            if (value < 0)
                value = 0;
        }
        catch (e) {
            console.warn(e);
            return 0;
        }
        return value;
    }
    /**
     * Applies the current settings to the sprite group.
     * @private
     */
    _applySettings() {
        try {
            if (this._settings.keyboardHandling === true) {
                this.activateHandlerManagment();
            }
            else {
                this.deactivateHandlerManagment();
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Resizes the sprite group based on its real width and height.
     * @private
     */
    _onResize() {
        try {
            this.width = this.realWidth();
            this.height = this.realHeight();
        }
        catch (e) {
            console.warn(e);
        }
    }
}
//NUI 1.0
//rev 19.06.25
// * "type": "image"
/**
 * Represents an image sprite used in the NUI system.
 * @class
 * @extends KNSprite
 */
class KNSprite_Image extends KNSprite {
    /**
     * Constructs a new instance of the NUI_Sprite_Image class.
     * @param _settings - The optional settings for the image sprite.
     */
    constructor(_settings) {
        super();
        this._settings = _settings;
        this._isLoaded = false;
        this._imageDataBindingsCache = null;
        this._lastWidth = 0;
        this._lastHeight = 0;
        this._isShouldResize = false;
        this._settings = Object.assign({}, KNSprite_Image.DefaultSettings(), _settings);
        this._create();
        this._onResize();
        this.draw(this._settings.imageName);
    }
    // * DefaultSettings in JSON format (for easy copy-paste)
    /**
     * Returns the default settings for the image sprite.
     * @returns {ImageSpriteSettings} The default settings.
     */
    static DefaultSettings() {
        return {
            "width": "auto",
            "height": "auto",
            "imageName": "",
            "folderName": "pictures",
            "keepAspect": false,
            "useAspectSize": false
        };
    }
    /**
     * Gets the current settings of the image sprite.
     * @returns {ImageSpriteSettings} The current settings.
     */
    get settings() {
        return this._settings;
    }
    /**
     * Gets the image sprite.
     * @returns {KSprite} The image sprite.
     */
    get image() {
        return this._image;
    }
    /**
     * Checks if the image sprite is loaded.
     * @returns {boolean} True if loaded, otherwise false.
     */
    isLoaded() {
        try {
            /*if(this.settings.width != 'auto' && this.settings.height != 'auto') {
                return true;
            }*/
            return this._isLoaded == true;
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    /**
     * Gets the real width of the image sprite.
     * @returns {number} The real width.
     */
    realWidth() {
        if (this.isNotHaveBounds())
            return 0;
        if (this.settings.useAspectSize == true && this._aspectWidth) {
            return this._aspectWidth;
        }
        if (this.settings.width == 'auto') {
            if (this._srcBitmap) {
                return this._srcBitmap.width;
            }
            else {
                if (this._image.bitmap && this._image.bitmap.isReady()) {
                    return this._image.bitmap.width;
                }
            }
        }
        else {
            return this.settings.width;
        }
        return this.width;
    }
    /**
     * Gets the real height of the image sprite.
     * @returns {number} The real height.
     */
    realHeight() {
        if (this.isNotHaveBounds())
            return 0;
        if (this.settings.useAspectSize == true && this._aspectHeight) {
            return this._aspectHeight;
        }
        if (this.settings.height == 'auto') {
            if (this._srcBitmap) {
                return this._srcBitmap.height;
            }
            else {
                if (this._image.bitmap && this._image.bitmap.isReady()) {
                    return this._image.bitmap.height;
                }
            }
        }
        else {
            return this.settings.height;
        }
        return this.height;
    }
    /**
     * Sets the image for the sprite.
     * @param {string} imageName - The name of the image.
     * @param {string} [folderName] - The name of the folder containing the image.
     */
    setImage(imageName, folderName) {
        if (KString.any(folderName)) {
            this._settings.folderName = folderName;
        }
        this.draw(imageName);
    }
    isHoveredByCursor() {
        if (this.image) {
            return this.image.isHoveredByCursor();
        }
        else {
            return super.isHoveredByCursor();
        }
    }
    /**
     * Returns an object with data bindings for width, height, size, image, and icon.
     * @returns {Record<string, any>} The data bindings.
     */
    dataBindings() {
        if (!this._imageDataBindingsCache) {
            this._imageDataBindingsCache = Object.assign(super.dataBindings(), {
                width: (v) => { if (v)
                    this.setSize(v, this.settings.height); },
                height: (v) => { if (v)
                    this.setSize(this.settings.width, v); },
                size: (v) => { if (v)
                    this.setSize(v.width, v.height); },
                image: (v) => { this.draw(v); },
                icon: (v) => { this.drawIcon(v); },
                imageOrIcon: (v) => {
                    //@ts-ignore
                    if (isFinite(v)) {
                        this.drawIcon(parseInt(v));
                    }
                    else {
                        this.draw(v);
                    }
                }
            });
        }
        return this._imageDataBindingsCache;
    }
    /**
     * Sets the size of the image sprite.
     * @param {number | string} [width='auto'] - The width of the sprite.
     * @param {number | string} [height='auto'] - The height of the sprite.
     */
    setSize(width = 'auto', height = 'auto') {
        try {
            if (width != 'auto')
                width = this.convertStringSizeValue(width, 'width', this);
            if (height != 'auto')
                height = this.convertStringSizeValue(height, 'height', this);
            if (width != null)
                this._settings.width = width;
            if (height != null)
                this._settings.height = height;
            this._onResize();
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Draws an icon on the sprite.
     * @param {number} iconIndex - The index of the icon.
     */
    drawIcon(iconIndex) {
        try {
            if (typeof (iconIndex) == 'number') {
                this.draw(iconIndex);
            }
            else {
                this.draw("");
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Draws an image or icon on the sprite.
     * @param {string | number} [imageName=""] - The name of the image or the index of the icon.
     */
    draw(imageName = "") {
        if (typeof (imageName) == 'string' && KString.any(imageName)) {
            this._drawImage(imageName);
            return;
        }
        if (typeof (imageName) == 'number' && imageName >= 0) {
            this._drawIcon(imageName);
            return;
        }
        this._srcBitmap = null;
        this._onResize();
    }
    /**
     * Disables the alpha pixel check for the image sprite.
     */
    disableAlphaPixelCheck() {
        this.isNeedCheckAlphaPixels = () => false;
        try {
            if (this._image) {
                this._image.isNeedCheckAlphaPixels = () => false;
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Draws an icon on the sprite.
     * @param {number} iconIndex - The index of the icon.
     * @private
     */
    _drawIcon(iconIndex) {
        try {
            let size = this.settings.width == 'auto' ? 32 : this.settings.width;
            this.settings.height = size;
            this._srcBitmap = new Bitmap(size, size);
            KBitmap.DrawIcon(this._srcBitmap, iconIndex, 0, 0, size);
            this._isLoaded = true;
            this._onResize();
            this._isShouldResize = true;
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Draws an image on the sprite.
     * @param {string} imageName - The name of the image.
     * @private
     */
    _drawImage(imageName) {
        this._isLoaded = false;
        this._srcBitmap = ImageManager.loadBitmap('img/' + this.settings.folderName + '/', imageName, 0, false);
        this._srcBitmap.addLoadListener(() => {
            this._isLoaded = true;
            this._onResize();
            this._isShouldResize = true;
            this.executeRequiredFuncs();
            this.executeLoadListeners();
        });
    }
    /**
     * Creates the image sprite and adds it as a child.
     * @private
     */
    _create() {
        this._image = new KSprite(new Bitmap(1, 1));
        this._image.isNeedCheckAlphaPixels = () => true;
        this.addChild(this._image);
    }
    /**
     * Request resize for the image sprite.
     * @private
     */
    _onResize() {
        try {
            let newWidth = this.realWidth();
            let newHeight = this.realHeight();
            if (this._lastWidth != newWidth || this._lastHeight != newHeight) {
                this._isShouldResize = true;
                this._lastWidth = newWidth;
                this._lastHeight = newHeight;
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    update() {
        super.update();
        if (this._isShouldResize) {
            this._resizeProcess();
            this._isShouldResize = false;
        }
    }
    /**
     * Resizes the image sprite.
     * @private
     */
    _resizeProcess() {
        try {
            this._aspectWidth = null;
            this._aspectHeight = null;
            this._image.bitmap = new Bitmap(this.realWidth(), this.realHeight());
            if (!this._srcBitmap)
                return;
            let fw = this.realWidth();
            let fh = this.realHeight();
            if (this.settings.keepAspect) {
                let aspect = this._calculateAspect(this._image.bitmap.width, this._image.bitmap.height, this._srcBitmap.width, this._srcBitmap.height);
                fw = aspect.width;
                fh = aspect.height;
                if (fh < this._image.bitmap.height) {
                    this._aspectHeight = fh;
                }
                else {
                    this._aspectHeight = this._image.bitmap.height;
                }
                if (fw < this._image.bitmap.width) {
                    this._aspectWidth = fw;
                }
                else {
                    this._aspectWidth = this._image.bitmap.width;
                }
            }
            this._image.bitmap.blt(this._srcBitmap, 0, 0, this._srcBitmap.width, this._srcBitmap.height, 0, 0, fw, fh);
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Calculates the aspect ratio for resizing.
     * @param {number} containerWidth - The width of the container.
     * @param {number} containerHeight - The height of the container.
     * @param {number} width - The width of the image.
     * @param {number} height - The height of the image.
     * @returns {{ width: number, height: number }} The calculated width and height.
     * @private
     */
    _calculateAspect(containerWidth, containerHeight, width, height) {
        let aspect = width / height;
        let containerAspectRatio = containerWidth / containerHeight;
        if (aspect > containerAspectRatio) {
            width = containerWidth;
            height = width / aspect;
        }
        else {
            height = containerHeight;
            width = height * aspect;
        }
        return { width, height };
    }
}
class KNSprite_ImageButton extends KNSprite {
    constructor(_settings) {
        super();
        this._settings = _settings;
        this._isSimulation = false;
        this._imageButtonDataBindingsCache = null;
        this._settings = Object.assign(KNSprite_ImageButton.DefaultSettings(), _settings);
        this._create();
        this._applySettings();
    }
    static DefaultSettings() {
        return {
            "folderName": "pictures",
            "imageName": "",
            "hoverImageName": "",
            "pressedImageName": "",
            "disabledImageName": "",
            "isCheckAlpha": false,
            "width": 160,
            "height": 60,
            "clickSe": "Cursor1",
            "desaturateWhenDisabled": false,
            "tint": "",
            "tintAlpha": 0.5,
            "overTint": "",
            "overTintAlpha": 0.5,
            "activeTint": "",
            "activeTintAlpha": 0.5,
            "disabledTint": "",
            "disabledTintAlpha": 0.5,
            "keyboardKey": "",
            "keyboardHandled": true,
            "enabled": true,
        };
    }
    isCanHandleTouch() {
        return true;
    }
    isSupportKeyboardHandle() {
        return this._settings.keyboardHandled == true;
    }
    isClickEnabled() {
        return super.isClickEnabled() && this.opacity != 0;
    }
    onPress() {
        super.onPress();
        this._refreshVisualState();
    }
    onReleased() {
        super.onReleased();
        this._refreshVisualState();
    }
    onMouseEnter() {
        super.onMouseEnter();
        this._refreshVisualState();
    }
    onMouseExit() {
        super.onMouseExit();
        this._refreshVisualState();
    }
    isHoveredByCursor() {
        if (this._buttonImage && this._buttonImage.visible && this._buttonImage.isHoveredByCursor()) {
            return true;
        }
        if (this._hoveredImage && this._hoveredImage.visible && this._hoveredImage.isHoveredByCursor()) {
            return true;
        }
        if (this._pressedImage && this._pressedImage.visible && this._pressedImage.isHoveredByCursor()) {
            return true;
        }
        if (this._disabledImage && this._disabledImage.visible && this._disabledImage.isHoveredByCursor()) {
            return true;
        }
        return false;
    }
    onClick() {
        try {
            if (this.isDisabled())
                return;
            if (this.isClickEnabled()) {
                KAudio.PlaySE(this._settings.clickSe);
            }
            super.onClick();
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Gets the current settings of the Button.
     * @returns {ImageButtonSpriteSettings} The current settings.
     */
    get settings() {
        return this._settings;
    }
    /**
     * Returns an object with data bindings for width, height, and size.
     * @returns {Record<string, any>} The data bindings.
     */
    dataBindings() {
        if (!this._imageButtonDataBindingsCache) {
            this._imageButtonDataBindingsCache = Object.assign(super.dataBindings(), {
                width: (v) => { if (v)
                    this.setSize(v, this.settings.height); },
                height: (v) => { if (v)
                    this.setSize(this.settings.width, v); },
                size: (v) => { if (v)
                    this.setSize(v.width, v.height); },
                style: (v) => { if (KDX.any(v))
                    this.setStyle(v); },
                enable: (v) => { if (KDX.any(v))
                    this.setEnabledState(v); },
                handler: (v) => { this.addClickHandler(v); },
                image: (v) => { if (KDX.any(v))
                    this.setImage(v); },
                // * Не используются, т.к. этих кнопок может не быть созданно, будет путанница
                //hoveredImage: (v: string) => {  if(KDX.any(v)) this.setHoveredImage(v) },
                //pressedImage: (v: string) => {  if(KDX.any(v)) this.setPressedImage(v) },
                //disabledImage: (v: string) => {  if(KDX.any(v)) this.setDisabledImage(v) }
            });
        }
        return this._imageButtonDataBindingsCache;
    }
    setStyle(style) {
        this._settings = Object.assign(this._settings, style);
        this._applySettings();
    }
    setImage(imageName) {
        var _a;
        try {
            this._settings.imageName = imageName;
            (_a = this._buttonImage) === null || _a === void 0 ? void 0 : _a.setImage(imageName);
        }
        catch (error) {
            console.warn(error);
        }
    }
    setHoveredImage(imageName) {
        var _a;
        try {
            this._settings.hoverImageName = imageName;
            (_a = this._hoveredImage) === null || _a === void 0 ? void 0 : _a.setImage(imageName);
        }
        catch (error) {
            console.warn(error);
        }
    }
    setPressedImage(imageName) {
        var _a;
        try {
            this._settings.pressedImageName = imageName;
            (_a = this._pressedImage) === null || _a === void 0 ? void 0 : _a.setImage(imageName);
        }
        catch (error) {
            console.warn(error);
        }
    }
    setDisabledImage(imageName) {
        var _a;
        try {
            this._settings.disabledImageName = imageName;
            (_a = this._disabledImage) === null || _a === void 0 ? void 0 : _a.setImage(imageName);
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Sets the size of the sprite button.
     *
     * @param {number | string} [width=160] - The width of the button. Can be a number or a string.
     * @param {number | string} [height=60] - The height of the button. Can be a number or a string.
     *
     * @throws {Error} Will throw an error if the width or height cannot be converted.
     */
    setSize(width = 160, height = 60) {
        try {
            let _width = this.convertStringSizeValue(width, 'width', this);
            let _height = this.convertStringSizeValue(height, 'height', this);
            if (_width != null)
                this._settings.width = _width;
            if (_height != null)
                this._settings.height = _height;
            this._applySettings();
        }
        catch (error) {
            console.warn(error);
        }
    }
    realWidth() {
        if (this.isNotHaveBounds())
            return 0;
        return this._settings.width;
    }
    realHeight() {
        if (this.isNotHaveBounds())
            return 0;
        return this._settings.height;
    }
    update() {
        super.update();
        if (this.isClickEnabled()) {
            this._updateButtonKeyboardHandling();
        }
    }
    isEnabled() {
        return !this.isDisabled();
    }
    setEnabledState(enabled) {
        try {
            this._settings.enabled = enabled;
            if (enabled) {
                this._enable();
            }
            else {
                this._disable();
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    addClickHandler(handler) {
        this._handleOkAction = handler;
    }
    // * Only visual
    simulateClickEffect() {
        this._isSimulation = true;
        setTimeout(() => {
            try {
                this._isSimulation = false;
                this._refreshVisualState();
            }
            catch (error) {
                console.warn(error);
            }
        }, 100);
        this._refreshVisualState();
    }
    enable() {
        this.setEnabledState(true);
    }
    disable() {
        this.setEnabledState(false);
    }
    _create() {
        if (this._settings.isPlane) {
            this._buttonImage = new KNSprite_Plane({
                "folderName": this._settings.folderName,
                "imageName": this._settings.imageName,
                "width": this._settings.width,
                "height": this._settings.height,
                "margins": this._settings.margins,
            });
        }
        else {
            this._buttonImage = new KNSprite_Image({
                "folderName": this._settings.folderName,
                "imageName": this._settings.imageName,
                "width": this._settings.width,
                "height": this._settings.height,
            });
        }
        this.addChild(this._buttonImage);
        if (KString.any(this._settings.hoverImageName)) {
            if (this._settings.isPlane) {
                this._hoveredImage = new KNSprite_Plane({
                    "folderName": this._settings.folderName,
                    "imageName": this._settings.hoverImageName,
                    "width": this._settings.width,
                    "height": this._settings.height,
                    "margins": this._settings.margins,
                });
            }
            else {
                this._hoveredImage = new KNSprite_Image({
                    "folderName": this._settings.folderName,
                    "imageName": this._settings.hoverImageName,
                    "width": this._settings.width,
                    "height": this._settings.height,
                });
            }
            this.addChild(this._hoveredImage);
        }
        if (KString.any(this._settings.pressedImageName)) {
            if (this._settings.isPlane) {
                this._pressedImage = new KNSprite_Plane({
                    "folderName": this._settings.folderName,
                    "imageName": this._settings.pressedImageName,
                    "width": this._settings.width,
                    "height": this._settings.height,
                    "margins": this._settings.margins,
                });
            }
            else {
                this._pressedImage = new KNSprite_Image({
                    "folderName": this._settings.folderName,
                    "imageName": this._settings.pressedImageName,
                    "width": this._settings.width,
                    "height": this._settings.height,
                });
            }
            this.addChild(this._pressedImage);
        }
        if (KString.any(this._settings.disabledImageName)) {
            if (this._settings.isPlane) {
                this._disabledImage = new KNSprite_Plane({
                    "folderName": this._settings.folderName,
                    "imageName": this._settings.disabledImageName,
                    "width": this._settings.width,
                    "height": this._settings.height,
                    "margins": this._settings.margins,
                });
            }
            else {
                this._disabledImage = new KNSprite_Image({
                    "folderName": this._settings.folderName,
                    "imageName": this._settings.disabledImageName,
                    "width": this._settings.width,
                    "height": this._settings.height,
                });
            }
            this.addChild(this._disabledImage);
        }
        if (this._settings.isCheckAlpha == true) {
            this._buttonImage.isNeedCheckAlphaPixels = () => true;
            if (this._hoveredImage)
                this._hoveredImage.isNeedCheckAlphaPixels = () => true;
            if (this._pressedImage)
                this._pressedImage.isNeedCheckAlphaPixels = () => true;
            if (this._disabledImage)
                this._disabledImage.isNeedCheckAlphaPixels = () => true;
        }
        else {
            this._buttonImage.disableAlphaPixelCheck();
            if (this._hoveredImage) {
                this._hoveredImage.disableAlphaPixelCheck();
            }
            if (this._pressedImage) {
                this._pressedImage.disableAlphaPixelCheck();
            }
            if (this._disabledImage) {
                this._disabledImage.disableAlphaPixelCheck();
            }
        }
    }
    _applySettings() {
        try {
            this._onResize();
            this._refreshVisualState();
            this._refreshState();
        }
        catch (error) {
            console.warn(error);
        }
    }
    _onResize() {
        try {
            this.width = this._settings.width;
            this.height = this._settings.height;
            if (this._buttonImage) {
                this._buttonImage.setSize(this._settings.width, this._settings.height);
            }
            if (this._hoveredImage) {
                this._hoveredImage.setSize(this._settings.width, this._settings.height);
            }
            if (this._pressedImage) {
                this._pressedImage.setSize(this._settings.width, this._settings.height);
            }
            if (this._disabledImage) {
                this._disabledImage.setSize(this._settings.width, this._settings.height);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _refreshVisualState() {
        try {
            this._refreshImage();
            this._refreshTint();
        }
        catch (error) {
            console.warn(error);
        }
    }
    _refreshImage() {
        if (this._isSimulation == true) {
            if (this._pressedImage) {
                this._showPressedImage();
            }
            else {
                this._showHoveredImage();
            }
            return;
        }
        if (this.isPressed()) {
            this._showPressedImage();
        }
        else if (this.isHovered()) {
            this._showHoveredImage();
        }
        else {
            this._hideAllButtonImages();
            this._buttonImage.visible = true;
        }
    }
    _hideAllButtonImages() {
        if (this._buttonImage) {
            this._buttonImage.visible = false;
        }
        if (this._hoveredImage) {
            this._hoveredImage.visible = false;
        }
        if (this._pressedImage) {
            this._pressedImage.visible = false;
        }
        if (this._disabledImage) {
            this._disabledImage.visible = false;
        }
    }
    _showHoveredImage() {
        this._hideAllButtonImages();
        if (this._hoveredImage) {
            this._hoveredImage.visible = true;
        }
        else {
            this._buttonImage.visible = true;
        }
    }
    _showPressedImage() {
        this._hideAllButtonImages();
        if (this._pressedImage) {
            this._pressedImage.visible = true;
        }
        else {
            this._buttonImage.visible = true;
        }
    }
    _showDisabledImage() {
        this._hideAllButtonImages();
        if (this._disabledImage) {
            this._disabledImage.visible = true;
        }
        else {
            this._buttonImage.visible = true;
        }
    }
    _refreshTint() {
        if (this.isPressed() || this._isSimulation) {
            this._applyTint(this._settings.activeTint, this._settings.activeTintAlpha);
        }
        else if (this.isHovered()) {
            this._applyTint(this._settings.overTint, this._settings.overTintAlpha);
        }
        else {
            this._applyTint(this._settings.tint, this._settings.tintAlpha);
        }
    }
    _applyTint(color, alpha = 0.5) {
        try {
            if (!KString.any(color)) {
                this.removeEffect(KNSpriteEffects.Tint);
                return;
            }
            else {
                let tintColor = KColor.HexToColorNumber(color);
                this.addTintEffect({
                    "color": tintColor,
                    "alpha": alpha
                });
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _refreshState() {
        try {
            this.setEnabledState(this._settings.enabled);
        }
        catch (error) {
            console.warn(error);
        }
    }
    _enable() {
        this._isDisabled = false;
        try {
            if (this._settings.desaturateWhenDisabled) {
                this.removeEffect(KNSpriteEffects.Desaturate);
            }
            this._refreshVisualState();
        }
        catch (error) {
            console.warn(error);
        }
    }
    _disable() {
        try {
            this._isDisabled = true;
            this._showDisabledImage();
            if (this._settings.desaturateWhenDisabled) {
                this.addDesaturateEffect();
            }
            else if (KString.any(this._settings.disabledTint)) {
                this._applyTint(this._settings.disabledTint, this._settings.disabledTintAlpha);
            }
            else {
                this._applyTint(this._settings.tint, this._settings.tintAlpha);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _updateButtonKeyboardHandling() {
        if (KString.any(this._settings.keyboardKey)) {
            if (Input.isTriggered(this._settings.keyboardKey)) {
                try {
                    Input.clear();
                    this.onClick();
                }
                catch (error) {
                    console.warn(error);
                }
            }
        }
    }
    _activateHandlerVisually() {
        try {
            if (this.isDisabled()) {
                super._activateHandlerVisually();
                return;
            }
            this._applyTint(this._settings.overTint, this._settings.overTintAlpha);
            this._showHoveredImage();
        }
        catch (error) {
            console.warn(error);
        }
    }
    _deactivateHandlerVisually() {
        try {
            if (this.isDisabled()) {
                super._deactivateHandlerVisually();
                return;
            }
            this._refreshVisualState();
        }
        catch (error) {
            console.warn(error);
        }
    }
}
//NUI 1.0
//rev 10.10.24
//type: "list"
class KNSprite_ItemsList extends KNSprite {
    constructor(settings = {}) {
        super();
        this._requireRecreateList = false;
        this._settings = Object.assign(KSelectableItemsList.DefaultSettings(), settings);
        this._reCreateList();
    }
    get settings() {
        return this._settings;
    }
    get list() {
        return this._list;
    }
    realWidth() {
        if (this.isNotHaveBounds())
            return 0;
        return this.settings.width;
    }
    realHeight() {
        if (this.isNotHaveBounds())
            return 0;
        return this.settings.height;
    }
    update() {
        super.update();
        if (this._requireRecreateList) {
            this._reCreateList();
            this._requireRecreateList = false;
        }
    }
    /**
     * Returns an object with data bindings for width, height, size, text, and style settings.
     * @returns {Record<string, any>} The data bindings.
     */
    dataBindings() {
        return Object.assign(super.dataBindings(), {
            width: (v) => { if (v)
                this.setSize(v, this.realHeight()); },
            height: (v) => { if (v)
                this.setSize(this.realWidth(), v); },
            size: (v) => { if (v)
                this.setSize(v.width, v.height); },
            maxCols: (v) => { if (v)
                this.setMaxCols(v); }
        });
    }
    setSize(width, height) {
        try {
            let _width = this.convertStringSizeValue(width, 'width', this);
            let _height = this.convertStringSizeValue(height, 'height', this);
            if (this.settings.width === _width && this.settings.height === _height)
                return;
            this.settings.width = _width;
            this.settings.height = _height;
            this._applySettings();
        }
        catch (error) {
            console.warn(error);
        }
    }
    setMaxCols(value) {
        try {
            if (this.settings.maxCols === value)
                return;
            this.settings.maxCols = value;
            this._applySettings();
        }
        catch (error) {
            console.warn(error);
        }
    }
    _applySettings() {
        this._requireRecreateList = true;
    }
    _destroyList() {
        if (!this.list)
            return null;
        let storedData = {
            listItems: this.list.getAllItems(),
            activeState: this.list.isOpenAndActive(),
            selectedIdx: this.list.index(),
            /*@ts-ignore*/
            handlers: this.list._handlers
        };
        /*@ts-ignore*/
        this.removeChild(this.list);
        this._list = null;
        return storedData;
    }
    _restoreData(data) {
        if (!data)
            return;
        if (!this.list)
            return;
        this._list.setItems(data.listItems);
        if (data.activeState) {
            this._list.activate(data.selectedIdx);
        }
        for (let key in data.handlers) {
            this._list.setHandler(key, data.handlers[key]);
        }
    }
    _reCreateList() {
        let storedListData = this._destroyList();
        /*@ts-ignore*/
        this._list = new KSelectableItemsList(0, 0, this.settings);
        /*@ts-ignore*/
        this.addChild(this._list);
        this._restoreData(storedListData);
    }
}
//Класс который позволяет сделать список (на основе Window_Selectable), но из Sprite элементов, а не Draw на Bitmap
class KSelectableItemsList extends Window_Selectable {
    constructor(x = 0, y = 0, settings = {}) {
        let _settings = Object.assign(KSelectableItemsList.DefaultSettings(), settings);
        if (KDX.isMV()) {
            /*@ts-ignore*/
            super(x, y, _settings.width, _settings.height);
        }
        else {
            super(new Rectangle(x, y, _settings.width, _settings.height));
        }
        this._settings = _settings;
        this._itemsSet = [];
        this._lastSelectedIndexForCallback = -1;
        this._prevSelectedIndex = -1;
        this._createItemsContainer();
        this._createWindowContentMask();
        this.setBackgroundType(this._settings.backgroundType);
    }
    get settings() {
        return this._settings;
    }
    get padding() {
        if (this.settings) {
            return this.settings.itemsPadding;
        }
        else {
            return 12;
        }
    }
    get width() {
        if (this.settings) {
            return this.settings.width;
        }
        else {
            return 240;
        }
    }
    get height() {
        if (this.settings) {
            return this.settings.height;
        }
        else {
            return 420;
        }
    }
    static DefaultSettings() {
        return {
            "width": 240,
            "height": 420,
            "maxCols": 1,
            "isHaveSelectionEffect": false,
            "selectionEffects": ["glow;distance:12;outerStrength:3"],
            "scaleItemsWidth": false,
            "scaleItemsHeight": false,
            "isDrawDefaultItemBack": false,
            "defaultItemHeight": 0,
            "backgroundType": 2,
            "itemsPadding": 12,
            "isHaveInOutAnimation": false,
            "isHorizontal": false,
            "inAnimation": "field:x;duration:0.15;keyframes:0=0,100=4",
            "outAnimation": "field:x;duration:0.15;keyframes:0=4,100=0",
            "isPlayOkSound": true,
            "isPlayCursorSound": true
        };
    }
    isHoveredByCursor() {
        return this.getAllItems().some((item) => item.isHoveredByCursor());
    }
    setSelectionHandler(callback) {
        this.setHandler('onSelectionChanged', callback);
    }
    setOkHandler(callback) {
        this.setHandler('ok', callback);
    }
    setCancelHandler(callback) {
        this.setHandler('cancel', callback);
    }
    getAllItems() {
        return this._itemsSet || [];
    }
    maxCols() {
        if (!this.settings)
            return 1;
        if (this.settings.isHorizontal) {
            return this.maxItems();
        }
        return this.settings.maxCols;
    }
    maxItems() {
        return this.getAllItems().length;
    }
    clear() {
        this.setItems([]);
    }
    selectedItem() {
        return this._itemsSet[this.index()];
    }
    itemAt(index) {
        return this._itemsSet[index];
    }
    lineHeight() {
        try {
            if (!this.settings)
                return 36; // * For super class
            if (this.settings.defaultItemHeight && this.settings.defaultItemHeight > 0) {
                return this.settings.defaultItemHeight;
            }
            if (this.maxItems() > 0) {
                return this.itemAt(0).realHeight();
            }
        }
        catch (error) {
            console.warn(error);
        }
        return 36;
    }
    activate(index) {
        try {
            if (index !== undefined) {
                this.refresh();
                this.safeSelect(index);
            }
        }
        catch (error) {
            console.warn(error);
        }
        super.activate();
    }
    select(index) {
        super.select(index);
        if (this._lastSelectedIndexForCallback !== index) {
            try {
                this.callHandler('onSelectionChanged');
            }
            catch (error) {
                console.warn(error);
            }
            this._lastSelectedIndexForCallback = index;
        }
    }
    safeSelect(index) {
        try {
            if (this.maxItems() > index) {
                this.select(index);
            }
            else {
                if (this.maxItems() > 0) {
                    this.select(0);
                }
                else {
                    this.select(-1);
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    setItems(items) {
        try {
            this._prevSelectedIndex = -1;
            this._itemsSet = items;
            this._itemsContainer.removeChildren();
            this.setTopRow(0);
            this.refresh();
            items.forEach((item, index) => this._addNewItemToList(item, index));
        }
        catch (error) {
            console.warn(error);
            this.setItems([]);
        }
    }
    isCursorVisible() {
        if (KDX.isMV()) {
            return super.isCursorVisible();
        }
        else {
            /*@ts-ignore*/
            return this.cursorVisible;
        }
    }
    playOkSound() {
        if (this.settings.isPlayOkSound == true) {
            super.playOkSound();
        }
    }
    playCursorSound() {
        if (this.settings.isPlayCursorSound == true) {
            super.playCursorSound();
        }
    }
    clearActivatedStateForItems() {
        try {
            this.getAllItems().forEach((item) => item === null || item === void 0 ? void 0 : item.setActivatedInListState(false));
        }
        catch (error) {
            console.warn(error);
        }
    }
    setActiveStateForItem(item, value) {
        try {
            this.clearActivatedStateForItems();
            item === null || item === void 0 ? void 0 : item.setActivatedInListState(value);
        }
        catch (error) {
            console.warn(error);
        }
    }
    setActiveStateForCurrentItem(value = true) {
        this.setActiveStateForItem(this.selectedItem(), value);
    }
    setActiveStateForItemAt(index, value = true) {
        this.setActiveStateForItem(this.itemAt(index), value);
    }
    processTouch() {
        if (KDX.isMV()) {
            if (this.isOpenAndActive()) {
                if (!TouchInput.isPressed() && this.isTouchedInsideFrame()) {
                    this.onTouch(false);
                }
            }
            super.processTouch();
        }
        else {
            super.processTouch();
        }
    }
    update() {
        super.update();
        /*@ts-ignore*/
        this._itemsContainer.y = -this._scrollY;
        this._updateItemsSelectionState();
    }
    _createItemsContainer() {
        this._windowItemsContentLayer = new KSprite();
        this._windowItemsContentLayer.move(this.padding, this.padding);
        this.addChild(this._windowItemsContentLayer);
        this._itemsContainer = new KSprite();
        this._windowItemsContentLayer.addChild(this._itemsContainer);
        try {
            if (this['_downArrowSprite']) {
                this.addChild(this['_downArrowSprite']);
            }
            if (this['_upArrowSprite']) {
                this.addChild(this['_upArrowSprite']);
            }
            if (!this.settings.isDrawDefaultItemBack) {
                if (this['_contentsBackSprite']) {
                    this['_contentsBackSprite'].visible = false;
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _createWindowContentMask() {
        try {
            let maskBitmap = new Bitmap(this.width - this.padding * 2, this.height - this.padding * 2);
            maskBitmap.fillAll('#ffffff');
            let maskSprite = new KSprite(maskBitmap);
            /*@ts-ignore*/
            this._windowItemsContentLayer.mask = maskSprite;
            this._windowItemsContentLayer.addChild(maskSprite);
        }
        catch (error) {
            console.warn(error);
        }
    }
    _updateItemsSelectionState() {
        try {
            if (!this.isOpenAndActive() || this.index() < 0 || !this.isCursorVisible) {
                this._disableSelectionForAll();
                return;
            }
            this._selectItemAtIndex(this.index());
        }
        catch (error) {
            console.warn(error);
        }
    }
    _disableSelectionForAll() {
        try {
            if (this._prevSelectedIndex == -2) {
                return;
            }
            this._prevSelectedIndex = -2;
            this.getAllItems().forEach((item) => this._deselectItem(item));
        }
        catch (error) {
            console.warn(error);
        }
    }
    _selectItemAtIndex(index) {
        try {
            if (this._prevSelectedIndex == index) {
                return;
            }
            let item = this.itemAt(index);
            if (item) {
                this._selectItem(item);
                this._prevSelectedIndex = index;
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _selectItem(item) {
        if (!item)
            return;
        try {
            if (this._prevSelectedIndex >= 0) {
                this._deselectItem(this.itemAt(this._prevSelectedIndex));
            }
            item.activateInList();
            this._playItemInAnimation(item);
            this._selectItemVisually(item);
        }
        catch (error) {
            console.warn(error);
        }
    }
    _deselectItem(item) {
        if (!item)
            return;
        try {
            item.deactivateInList();
            this._playItemOutAnimation(item);
            this._deselectItemVisually(item);
        }
        catch (error) {
            console.warn(error);
        }
    }
    _selectItemVisually(item) {
        try {
            if (!this.settings.isHaveSelectionEffect)
                return;
            if (!this.settings.selectionEffects)
                return;
            if (this.settings.selectionEffects.length == 0)
                return;
            KNBuilder.ApplyEffects(item, this.settings.selectionEffects);
        }
        catch (error) {
            console.warn(error);
        }
    }
    _playItemInAnimation(item) {
        try {
            if (!this.settings.isHaveInOutAnimation)
                return;
            if (KString.any(this.settings.inAnimation)) {
                this._playItemAnimation(item, this.settings.inAnimation);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _playItemOutAnimation(item) {
        try {
            if (!this.settings.isHaveInOutAnimation)
                return;
            if (KString.any(this.settings.outAnimation)) {
                this._playItemAnimation(item, this.settings.outAnimation);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _playItemAnimation(item, animation) {
        try {
            let child = item.children[0];
            if (!child)
                return;
            if (!child.setAnimationRule)
                return;
            child.setAnimationRule(animation);
        }
        catch (error) {
            console.warn(error);
        }
    }
    _deselectItemVisually(item) {
        try {
            if (!this.settings.isHaveSelectionEffect)
                return;
            item.filters = [];
        }
        catch (error) {
            console.warn(error);
        }
    }
    _addNewItemToList(item, index) {
        if (!item)
            return;
        try {
            let rect = this.itemRect(index);
            item.move(rect.x, rect.y);
            if (this.settings.scaleItemsHeight) {
                item.scale.y = rect.height / item.realHeight();
            }
            if (this.settings.scaleItemsWidth) {
                item.scale.x = rect.width / item.realWidth();
            }
            this._itemsContainer.addChild(item);
        }
        catch (error) {
            console.warn(error);
        }
    }
    //$[OVER]
    // * We don't need Default Cursor of Window_Selectable
    _updateCursor() {
        if (KDX.isMZ()) {
            /*@ts-ignore*/
            this._cursorSprite.visible = false;
        }
        else {
            /*@ts-ignore*/
            this.setCursorRect(0, 0, 0, 0);
        }
    }
}
// * NUI 1.0
// * rev 19.06.25
// * "type": "plane"
/**
 * Represents a NineSlicePlane sprite used in NUI system.
 */
class KNSprite_Plane extends KNSprite {
    /**
     * Constructs a new instance of the KNSprite_Plane class.
     * @param _settings - The settings for the plane sprite.
     */
    constructor(_settings) {
        super();
        this._settings = _settings;
        this._planeDataBindingsCache = null;
        this._settings = Object.assign({}, KNSprite_Plane.DefaultSettings(), _settings);
        this._create();
        this._applySettings();
    }
    // * DefaultSettings in JSON format (for easy copy-paste)
    /**
     * Returns the default settings for the plane sprite.
     * @returns {PlaneSpriteSettings} The default settings.
     */
    static DefaultSettings() {
        return {
            "width": 100,
            "height": 100,
            "margins": 20,
            "imageName": "",
            "folderName": "pictures"
        };
    }
    /**
     * Gets the current settings of the plane sprite.
     * @returns {PlaneSpriteSettings} The current settings.
     */
    get settings() {
        return this._settings;
    }
    /**
     * Gets the real width of the sprite.
     * @returns {number} The real width.
     */
    realWidth() {
        if (this.isNotHaveBounds())
            return 0;
        return this.settings.width;
    }
    /**
     * Gets the real height of the sprite.
     * @returns {number} The real height.
     */
    realHeight() {
        if (this.isNotHaveBounds())
            return 0;
        return this.settings.height;
    }
    /**
     * Applies the current settings to the sprite.
     */
    refresh() {
        try {
            this._applySettings();
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Returns an object with data bindings for width, height, and size.
     * @returns {Record<string, any>} The data bindings.
     */
    dataBindings() {
        if (!this._planeDataBindingsCache) {
            this._planeDataBindingsCache = Object.assign(super.dataBindings(), {
                width: (v) => { if (v)
                    this.setSize(v, this.settings.height); },
                height: (v) => { if (v)
                    this.setSize(this.settings.width, v); },
                size: (v) => { if (v)
                    this.setSize(v.width, v.height); },
                image: (v) => { this.setImage(v); }
            });
        }
        return this._planeDataBindingsCache;
    }
    /**
     * Sets the size of the sprite.
     * @param {number | string} [width=100] - The width of the sprite.
     * @param {number | string} [height=100] - The height of the sprite.
     */
    setSize(width = 100, height = 100) {
        try {
            let _width = this.convertStringSizeValue(width, 'width', this);
            let _height = this.convertStringSizeValue(height, 'height', this);
            if (_width != null)
                this._settings.width = _width;
            if (_height != null)
                this._settings.height = _height;
            this.refresh();
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Sets the image for the sprite.
     * @param {string} imageName - The name of the image.
     * @param {string} [folderName] - The name of the folder containing the image.
     */
    setImage(imageName, folderName) {
        if (KString.any(folderName)) {
            this._settings.folderName = folderName;
        }
        this._settings.imageName = imageName;
        this.refresh();
    }
    /**
     * Disables the alpha pixel check for the image sprite.
     */
    disableAlphaPixelCheck() {
        this.isNeedCheckAlphaPixels = () => false;
    }
    /**
     * Creates the plane container and adds it as a child.
     * @private
     */
    _create() {
        this._planeContainer = new KSprite();
        this.addChild(this._planeContainer);
    }
    /**
     * Applies the current settings to the plane sprite.
     * @private
     */
    _applySettings() {
        if (!this._settings)
            return;
        try {
            if (this._plane) {
                this._planeContainer.removeChild(this._plane);
                this._plane.destroy();
            }
            let margins = this._getMargins();
            let textureSource = ImageManager.loadBitmap('img/' + this._settings.folderName + "/", this._settings.imageName, 0, false);
            textureSource.addLoadListener(() => {
                let texture = new PIXI.Texture(textureSource.baseTexture);
                if (KDX.isMV()) {
                    /*@ts-ignore*/
                    this._plane = new PIXI.mesh.NineSlicePlane(texture, margins.left, margins.top, margins.right, margins.bottom);
                }
                else {
                    this._plane = new PIXI.NineSlicePlane(texture, margins.left, margins.top, margins.right, margins.bottom);
                }
                this._planeContainer.addChild(this._plane);
                this._applySize();
            });
        }
        catch (error) {
            console.warn(error);
        }
        this._applySize();
    }
    /**
     * Returns the margins for the plane sprite.
     * @returns {PlaneMargins} The margins.
     * @private
     */
    _getMargins() {
        let margins = this._settings.margins;
        if (typeof margins === "number") {
            return {
                left: margins,
                top: margins,
                right: margins,
                bottom: margins
            };
        }
        else {
            return margins;
        }
    }
    /**
     * Applies the size settings to the plane sprite and its container.
     * @private
     */
    _applySize() {
        this.width = this._settings.width;
        this.height = this._settings.height;
        if (!this._plane)
            return;
        this._plane.width = this._settings.width;
        this._plane.height = this._settings.height;
    }
}
//NUI 1.0
//rev 11.09.24
//"type": "screen"
class KNSprite_Screen extends KNSprite_Group {
    constructor() {
        super({
            width: Graphics.width,
            height: Graphics.height
        });
    }
    realWidth() {
        if (this.isNotHaveBounds())
            return 0;
        return Graphics.width;
    }
    realHeight() {
        if (this.isNotHaveBounds())
            return 0;
        return Graphics.height;
    }
}
//NUI 1.0
//rev 19.06.25
//"type": "text"
class KNSprite_Text extends KNSprite {
    /**
         * Creates an instance of Sprite_UIText2.
         * @param _settings The parameters for the sprite.
         * @param _userTextStyle The user-defined text style.
         */
    constructor(settings = {}, _userTextStyle = {}) {
        super();
        this._userTextStyle = _userTextStyle;
        this._textDataBindingsCache = null;
        this._requiredRedrawText = false;
        this._initialTextDraw = false;
        this._settings = KNSprite_Text.DefaultSettings();
        this._applySettings(settings);
        this._createTextSprite();
        if (KString.any(settings.text)) {
            this.drawText(settings.text);
        }
    }
    /**
     * Checks if the image sprite is loaded.
     * @returns {boolean} True if loaded, otherwise false.
     */
    isLoaded() {
        try {
            /*if(this.settings.width != 'auto' && this.settings.height != 'auto') {
                return true;
            }*/
            return !!this._textSpr;
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    /**
     * Gets the current settings of the image sprite.
     * @returns {TextSpriteSettings} The current settings.
     */
    get settings() {
        return this._settings;
    }
    get textColor() {
        return this._settings.textColor;
    }
    set textColor(value) {
        this.setTextColor(value);
    }
    static DefaultSettings() {
        return {
            "size": { "width": 60, "height": 20 },
            "alignment": "center",
            "font": {
                "face": null,
                "size": 18,
                "italic": false,
                "bold": false,
                "weight": 0
            },
            "margins": { "x": 0, "y": 0 },
            "outline": { "color": null, "width": 2 },
            "textColor": "#FFFFFF",
            "shadow": {
                "color": "#000",
                "opacity": 0,
                "margins": { "x": 1, "y": 1 }
            },
            "text": "",
            "multiline": false,
            "verticalCentered": true,
            "actualWidth": false,
            "actualHeight": false,
            "isLoadFontFromFile": false
        };
    }
    /**
     * Returns an object with data bindings for width, height, size, text, and style settings.
     * @returns {Record<string, any>} The data bindings.
     */
    dataBindings() {
        if (!this._textDataBindingsCache) {
            this._textDataBindingsCache = Object.assign(super.dataBindings(), {
                width: (v) => { if (v)
                    this.setSize(v, this.realHeight()); },
                height: (v) => { if (v)
                    this.setSize(this.realWidth(), v); },
                size: (v) => { if (v)
                    this.setSize(v.width, v.height); },
                text: (v) => { this.drawText(v); },
                style: (v) => { if (v)
                    this.setStyle(v, {}); },
                textColor: (v) => { if (v)
                    this.setTextColor(v); },
                fontSize: (v) => { if (KDX.any(v))
                    this.setFontSize(v); }
            });
        }
        return this._textDataBindingsCache;
    }
    setSize(width, height) {
        try {
            let _width = this.convertStringSizeValue(width, 'width', this);
            let _height = this.convertStringSizeValue(height, 'height', this);
            this.setStyle({ size: { width: _width, height: _height } }, {});
        }
        catch (error) {
            console.warn(error);
        }
    }
    setStyle(newStyleInOldFormat, newStyleInPixiFormat) {
        try {
            this._textStyle = this._convertToPixiStyle(newStyleInOldFormat, newStyleInPixiFormat);
            this._textSpr.style = this._textStyle;
            this.drawText(this._settings.text);
        }
        catch (error) {
            console.warn(error);
        }
    }
    setFontSize(size) {
        try {
            let font = Object.assign({}, this._settings.font);
            if (typeof size == "string") {
                size = this.convertStringSizeValue(size, 'height', this);
            }
            font.size = size;
            this.setStyle({ font }, {});
            this.drawText(this._settings.text);
        }
        catch (error) {
            console.warn(error);
        }
    }
    setTextColor(color) {
        try {
            this._settings.textColor = color;
            this.setStyle({ textColor: color }, {});
        }
        catch (error) {
            console.warn(error);
        }
    }
    getMetrics() {
        return PIXI.TextMetrics.measureText(this._textSpr.text, this._textSpr.style);
    }
    drawText(text) {
        try {
            if (!KString.any(text)) {
                text = "";
            }
            this._drawText(text);
        }
        catch (error) {
            console.warn(error);
        }
    }
    realWidth() {
        if (this.isNotHaveBounds())
            return 0;
        if (this._textSpr && this._settings.actualWidth == true) {
            return this.getMetrics().width;
        }
        if (this._settings.size.width > 0) {
            return this._settings.size.width;
        }
        return super.realWidth();
    }
    realHeight() {
        if (this.isNotHaveBounds())
            return 0;
        if (this._textSpr && this._settings.actualHeight == true) {
            return this.getMetrics().height;
        }
        if (this._settings.size.height > 0) {
            return this._settings.size.height;
        }
        return super.realHeight();
    }
    update() {
        super.update();
        if (this._requiredRedrawText) {
            this._drawTextProcess();
            this._requiredRedrawText = false;
        }
    }
    /**
         * Applies the parameters to the sprite.
         * @param settings The parameters to apply.
         */
    _applySettings(settings) {
        try {
            this._textStyle = this._convertToPixiStyle(settings, {});
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
         * Converts the old style parameters to the new (PIXI) style.
         * @param settings The old style parameters.
         * @param style The new style parameters.
         * @returns The converted text style.
         */
    _convertToPixiStyle(settings = {}, style) {
        try {
            this._settings = Object.assign(this._settings, settings);
            let _textStyle = (Object.assign({}, this._userTextStyle, style));
            if (KString.any(this._settings.font.face)) {
                this._loadFont();
                _textStyle.fontFamily = this._settings.font.face;
            }
            _textStyle.fontSize = this._settings.font.size;
            if (this._settings.font.italic === true) {
                _textStyle.fontStyle = 'italic';
            }
            if (this._settings.font.bold === true) {
                _textStyle.fontWeight = 'bold';
            }
            if (this._settings.font.weight && this._settings.font.weight > 0) {
                _textStyle.fontWeight = this._settings.font.weight.toString();
            }
            if (KString.any(this._settings.outline.color) && this._settings.outline.width > 0) {
                _textStyle.stroke = this._settings.outline.color;
                _textStyle.strokeThickness = this._settings.outline.width;
            }
            _textStyle.fill = this._settings.textColor;
            if (this._settings.shadow && this._settings.shadow.opacity > 0) {
                const { color, opacity, margins } = this._settings.shadow;
                _textStyle.dropShadow = true;
                _textStyle.dropShadowAngle = margins.y;
                _textStyle.dropShadowColor = color;
                _textStyle.dropShadowDistance = margins.x;
                _textStyle.dropShadowAlpha = opacity / 255.0;
            }
            if (this._settings.multiline === true) {
                _textStyle.align = this._settings.alignment || 'left';
                _textStyle.wordWrap = true;
                if (this._settings.font.size) {
                    _textStyle.lineHeight = this._settings.font.size + 2;
                }
                if (this.realWidth() > 0) {
                    _textStyle.wordWrapWidth = this.realWidth();
                }
            }
            return _textStyle;
        }
        catch (e) {
            console.warn(e);
            return new PIXI.TextStyle();
        }
    }
    _loadFont() {
        try {
            if (this._settings.isLoadFontFromFile != true)
                return;
            if (!KString.any(this._settings.font.face))
                return;
            //@ts-ignore
            if (KNSprite_Text._loadedFonts.includes(this._settings.font.face))
                return;
            if (KDX.isMV()) {
                let url = "fonts/" + Utils.encodeURI(this._settings.font.face) + ".ttf";
                var style = document.createElement('style');
                var head = document.getElementsByTagName('head');
                var rule = '@font-face { font-family: "' + this._settings.font.face + '"; src: url("' + url + '"); }';
                style.type = 'text/css';
                head.item(0).appendChild(style);
                style.sheet.insertRule(rule, 0);
            }
            else {
                //@ts-ignore
                FontManager.load(this._settings.font.face, this._settings.font.face + ".ttf");
            }
            KNSprite_Text._loadedFonts.push(this._settings.font.face);
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Creates the text sprite.
     */
    _createTextSprite() {
        try {
            const style = new PIXI.TextStyle(this._textStyle);
            this._textSpr = new PIXI.Text('', style);
            this.addChild(this._textSpr);
            this.executeRequiredFuncs();
            this.executeLoadListeners();
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Draws the text.
     * @param text The text to draw.
     */
    _drawText(text) {
        this._settings.text = text;
        if (!this._initialTextDraw) {
            this._initialTextDraw = true;
            this._drawTextProcess();
            return;
        }
        this._requiredRedrawText = true;
    }
    _drawTextProcess() {
        try {
            var text = this._settings.text;
            if (typeof text !== "string") {
                text = String(text);
            }
            try {
                text = TextProParser.ConvertControlCharacters(text);
            }
            catch (error) {
                console.warn(error);
            }
            this._textSpr.text = text;
            const { width: w, height: h } = this._settings.size;
            // * Fix for a bug with 0 font size
            if (this._textSpr.style.fontSize == 0) {
                this._textSpr.style.fontSize = 18;
            }
            let textMetrics;
            try {
                textMetrics = PIXI.TextMetrics.measureText(text, this._textSpr.style);
            }
            catch (error) {
                console.warn(error);
                return;
            }
            const { height, maxLineWidth } = textMetrics;
            if (this._settings.verticalCentered === true) {
                this._textSpr.y = (h - height) / 2;
            }
            else {
                this._textSpr.y = 0;
            }
            if (this._settings.alignment === 'center') {
                this._textSpr.x = (w - maxLineWidth) / 2;
            }
            else if (this._settings.alignment === 'right') {
                this._textSpr.x = (w - maxLineWidth);
            }
            else {
                this._textSpr.x = 0;
            }
            this._textSpr.x += this._settings.margins.x;
            this._textSpr.y += this._settings.margins.y;
        }
        catch (e) {
            console.warn(e);
        }
    }
}
KNSprite_Text._loadedFonts = [];
//NUI 1.3
//rev 19.06.25
//"type": "textPro"
class KNSprite_TextPro extends KNSprite {
    /**
         * Creates an instance of Sprite_UIText2.
         * @param _settings The parameters for the sprite.
         * @param _userTextStyle The user-defined text style.
         */
    constructor(settings = {}, _userTextStyle = {}) {
        super();
        this._userTextStyle = _userTextStyle;
        this._textProDataBindingsCache = null;
        this._requireTextRedraw = false;
        this._requireAlignment = false;
        this._settings = Object.assign(KNSprite_TextPro.DefaultSettings(), settings);
        this._textsContainer = new KNSprite_Group();
        this._textLines = [];
        this.addChild(this._textsContainer);
        if (KString.any(settings.text)) {
            this.drawText(settings.text);
        }
    }
    /**
     * Gets the current settings of the image sprite.
     * @returns {TextProSpriteSettings} The current settings.
     */
    get settings() {
        return this._settings;
    }
    static DefaultSettings() {
        return {
            "size": { "width": 60, "height": 20 },
            "alignment": "center",
            "font": {
                "face": null,
                "size": 18,
                "italic": false,
                "bold": false,
                "weight": 0
            },
            "margins": { "x": 0, "y": 0 },
            "outline": { "color": null, "width": 2 },
            "textColor": "#FFFFFF",
            "shadow": {
                "color": "#000",
                "opacity": 0,
                "margins": { "x": 1, "y": 1 }
            },
            "text": "",
            "multiline": false,
            "verticalCentered": true,
            "verticalAlignment": "top",
            "verticalSpacing": 4,
            "actualWidth": false,
            "actualHeight": false,
            "trimWidth": false,
            "trimHeight": false,
            "iconPadding": {
                "left": 2,
                "right": 2,
                "top": 0,
                "bottom": 0
            },
            "iconSize": 1,
            "isStaticIconSize": false,
            "isLoadFontFromFile": false
        };
    }
    realWidth() {
        try {
            if (this.isNotHaveBounds())
                return 0;
            if (this.settings.actualWidth == true) {
                return this._textsContainer.realWidth();
            }
            return this.settings.size.width;
        }
        catch (error) {
            console.warn(error);
            return 0;
        }
    }
    realHeight() {
        try {
            if (this.isNotHaveBounds())
                return 0;
            if (this.settings.actualHeight == true) {
                return this._textsContainer.realHeight();
            }
            return this.settings.size.height;
        }
        catch (error) {
            console.warn(error);
            return 0;
        }
    }
    /**
     * Returns an object with data bindings for width, height, size, text, and style settings.
     * @returns {Record<string, any>} The data bindings.
     */
    dataBindings() {
        if (!this._textProDataBindingsCache) {
            this._textProDataBindingsCache = Object.assign(super.dataBindings(), {
                width: (v) => { if (v)
                    this.setSize(v, this.realHeight()); },
                height: (v) => { if (v)
                    this.setSize(this.realWidth(), v); },
                size: (v) => { if (v)
                    this.setSize(v.width, v.height); },
                text: (v) => { this.drawText(v); },
                style: (v) => { if (v)
                    this.setStyle(v, {}); },
                textColor: (v) => { if (v)
                    this.setTextColor(v); },
                fontSize: (v) => { if (KDX.any(v))
                    this.setFontSize(v); },
                iconSize: (v) => { if (KDX.any(v))
                    this.setIconSize(v); },
                verticalSpacing: (v) => { if (KDX.any(v))
                    this.setVerticalSpacing(v); }
            });
        }
        return this._textProDataBindingsCache;
    }
    setSize(width, height) {
        try {
            let _width = this.convertStringSizeValue(width, 'width', this);
            let _height = this.convertStringSizeValue(height, 'height', this);
            this.setStyle({ size: { width: _width, height: _height } }, {});
        }
        catch (error) {
            console.warn(error);
        }
    }
    setTextColor(color) {
        try {
            this.setStyle({ textColor: color }, {});
        }
        catch (error) {
            console.warn(error);
        }
    }
    setIconSize(size) {
        if (typeof size == "string") {
            size = this.convertStringSizeValue(size, 'height', this);
        }
        this.setStyle({ iconSize: size }, {});
    }
    setVerticalSpacing(spacing) {
        if (typeof spacing == "string") {
            spacing = this.convertStringSizeValue(spacing, 'height', this);
        }
        this.setStyle({ verticalSpacing: spacing }, {});
    }
    setFontSize(size) {
        try {
            let font = Object.assign({}, this._settings.font);
            if (typeof size == "string") {
                size = this.convertStringSizeValue(size, 'height', this);
            }
            font.size = size;
            this.setStyle({ font }, {});
        }
        catch (error) {
            console.warn(error);
        }
    }
    setStyle(style, userStyle) {
        try {
            this._settings = Object.assign(this._settings, style);
            this._userTextStyle = Object.assign(this._userTextStyle, userStyle);
            this.drawText(this.settings.text);
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Draws the specified text on the sprite.
     *
     * @param text - The text to be drawn. If the text is not provided or is invalid, an empty string will be used.
     * @throws Will log a warning to the console if an error occurs during the drawing process.
     */
    drawText(text) {
        try {
            if (!KString.any(text)) {
                text = "";
            }
            this._settings.text = text;
            this._requireTextRedraw = true;
            this._requireAlignment = false;
        }
        catch (error) {
            console.warn(error);
        }
    }
    update() {
        super.update();
        if (this._requireTextRedraw) {
            this._drawTextProcess();
            this._requireTextRedraw = false;
        }
        if (this._requireAlignment) {
            this._applyAlignment();
            this._applyMargins();
            this._requireAlignment = false;
        }
    }
    _drawTextProcess() {
        try {
            this._createTextSprites();
            this._applyAlignment();
            this._applyMargins();
            this._requireAlignment = true;
        }
        catch (error) {
            console.warn(error);
        }
    }
    _createTextSprites() {
        try {
            this._clearTextSprites();
            let textConfigs = TextProParser.ParseText(this.settings);
            let elements = TextProElementsBuilder.Build(textConfigs, this.settings, this._userTextStyle);
            if (this.settings.multiline == true || this.settings.trimWidth == true) {
                let lines = this._separateTextToLines(elements);
                for (let line of lines) {
                    this._textLines.push(line);
                    this._textsContainer.addChild(line);
                    this._refreshTextElementsVerticalPosition(line);
                    this._applyLineAligmnent(line);
                }
            }
            else {
                this._textLines.push(elements);
                this._textsContainer.addChild(elements);
                this._refreshTextElementsVerticalPosition(elements);
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    _clearTextSprites() {
        try {
            this._textsContainer.move(0, 0);
            this._textsContainer.removeChildren();
            this._textLines = [];
        }
        catch (error) {
            console.warn(error);
        }
    }
    _separateTextToLines(allTextElements) {
        const lines = [];
        try {
            const maxLineWidth = this.settings.size.width;
            const maxHeight = this.settings.size.height;
            let currentWidth = 0;
            const currentHeight = () => {
                return lines.reduce((sum, line) => sum + line.realHeight(), 0);
            };
            const elements = [];
            for (const child of allTextElements.children) {
                elements.push(child);
            }
            let line = new KNSprite_Group({});
            lines.push(line);
            for (const el of elements) {
                currentWidth += el.realWidth();
                if (currentWidth > maxLineWidth) {
                    currentWidth = 0;
                    if (this.settings.multiline === false)
                        break;
                    const newHeight = currentHeight() + el.realHeight();
                    if (newHeight > maxHeight) {
                        if (this.settings.trimHeight === true)
                            break;
                    }
                    line = new KNSprite_Group({});
                    line.addChild(el);
                    el.setPosition(0, this._textElementVerticalPosition());
                    lines.push(line);
                    line.y += line.realHeight() + this.settings.verticalSpacing;
                }
                else {
                    line.addChild(el);
                    el.setPosition("prevEndX", this._textElementVerticalPosition());
                }
            }
        }
        catch (e) {
            console.warn(e);
        }
        return lines;
    }
    _refreshTextElementsVerticalPosition(elements) {
        try {
            for (let child of elements.children) {
                child.setPosition(child.x, this._textElementVerticalPosition());
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    /**
     * Gets the vertical position for the text element.
     * @returns The vertical position for the text element.
     * @private
     */
    _textElementVerticalPosition() {
        try {
            if (this.settings.verticalCentered) {
                return "center";
            }
        }
        catch (e) {
            console.warn(e);
        }
        return 0;
    }
    _applyLineAligmnent(line) {
        try {
            line.setPosition(this.settings.alignment, line.y);
        }
        catch (error) {
            console.warn(error);
        }
    }
    _applyAlignment() {
        try {
            this._textsContainer.setPosition(this.settings.alignment, this.settings.verticalAlignment);
        }
        catch (error) {
            console.warn(error);
        }
    }
    _applyMargins() {
        try {
            this._textsContainer.x += this.settings.margins.x;
            this._textsContainer.y += this.settings.margins.y;
        }
        catch (error) {
            console.warn(error);
        }
    }
}
class TextProElementsBuilder {
    /**
     * Creates an instance of TextProElementsBuilder.
     * @param configs The configuration for the text elements.
     * @param settings The settings for the TextPro sprite.
     * @param userTextStyle The user-defined text style.
     */
    constructor(configs, settings, userTextStyle) {
        this.configs = configs;
        this.settings = settings;
        this.userTextStyle = userTextStyle;
        this._elements = new KNSprite_Group();
        this._buildElements();
    }
    /**
     * Gets the elements created by the builder.
     * @returns The elements created by the builder.
     */
    getElements() {
        return this._elements;
    }
    /**
     * Builds the elements based on the provided configurations.
     * @param configs The configuration for the text elements.
     * @param settings The settings for the TextPro sprite.
     * @param userTextStyle The user-defined text style.
     * @returns The elements created by the builder.
     */
    static Build(configs, settings, userTextStyle) {
        const builder = new TextProElementsBuilder(configs, settings, userTextStyle);
        return builder.getElements();
    }
    /**
     * Builds the elements based on the configurations.
     * @private
     */
    _buildElements() {
        try {
            for (const config of this.configs) {
                if (config.iconIndex !== undefined && config.iconIndex >= 0) {
                    this._createIconElement(config, this._elements);
                }
                else {
                    this._createTextElement(config, this._elements);
                }
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Creates an icon element based on the configuration.
     * @param config The configuration for the icon element.
     * @param line The line to add the icon element to.
     * @private
     */
    _createIconElement(config, line) {
        try {
            let iconSize;
            if (this.settings.isStaticIconSize) {
                iconSize = this.settings.iconSize;
            }
            else {
                if (config.fontSize && config.fontSize > 0) {
                    iconSize = config.fontSize * this.settings.iconSize;
                }
                else {
                    iconSize = this.settings.font.size * this.settings.iconSize;
                }
            }
            const icon = new KNSprite_Image({
                imageName: config.iconIndex,
                width: iconSize,
                height: iconSize
            });
            const paddingGroup = new KNSprite_Group({
                width: iconSize + this.settings.iconPadding.left + this.settings.iconPadding.right,
                height: iconSize + this.settings.iconPadding.top + this.settings.iconPadding.bottom
            });
            paddingGroup.addChild(icon);
            icon.setPosition("center", "center");
            line.addChild(paddingGroup);
            paddingGroup.setPosition("prevEndX", this._textElementVerticalPosition());
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Creates a text element based on the configuration.
     * @param config The configuration for the text element.
     * @param line The line to add the text element to.
     * @private
     */
    _createTextElement(config, line) {
        try {
            const textSettings = Object.assign({}, this.settings);
            textSettings.text = config.text;
            if (config.fontSize && config.fontSize > 0) {
                textSettings.font.size = config.fontSize;
            }
            if (config.color && KString.any(config.color)) {
                textSettings.textColor = config.color;
            }
            textSettings.alignment = "left";
            textSettings.multiline = false;
            textSettings.verticalCentered = false;
            textSettings.actualWidth = true;
            textSettings.actualHeight = true;
            textSettings.margins = { x: 0, y: 0 };
            const text = new KNSprite_Text(textSettings, this.userTextStyle);
            line.addChild(text);
            text.setPosition("prevEndX", this._textElementVerticalPosition());
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Gets the vertical position for the text element.
     * @returns The vertical position for the text element.
     * @private
     */
    _textElementVerticalPosition() {
        try {
            if (this.settings.verticalCentered) {
                return "center";
            }
        }
        catch (e) {
            console.warn(e);
        }
        return 0;
    }
}
let _pkdTempWindowBaseForConvertEscapeCharacters = null;
class TextProParser {
    /**
     * Converts control characters in the input text.
     * @param inputText The input text to convert.
     * @returns The converted text.
     */
    static ConvertControlCharacters(inputText) {
        try {
            if (KString.any(inputText)) {
                if (!_pkdTempWindowBaseForConvertEscapeCharacters) {
                    if (KDX.isMV()) {
                        //@ts-ignore
                        _pkdTempWindowBaseForConvertEscapeCharacters = new Window_Base(0, 0, 0, 0);
                    }
                    else {
                        _pkdTempWindowBaseForConvertEscapeCharacters = new Window_Base(new Rectangle(0, 0, 0, 0));
                    }
                }
                return _pkdTempWindowBaseForConvertEscapeCharacters.convertEscapeCharacters(inputText);
            }
            else {
                return "";
            }
        }
        catch (e) {
            console.warn(e);
            return "";
        }
    }
    /**
     * Creates an instance of TextProParser.
     * @param settings The settings for the TextPro sprite.
     */
    constructor(settings) {
        this._textsConfigs = [];
        this.settings = settings;
        if (KDX.isMV()) {
            if (!window["__kdSharedTextProTextColorSourceWindow"]) {
                /*@ts-ignore*/
                window["__kdSharedTextProTextColorSourceWindow"] = new Window_Base(0, 0, 0, 0);
            }
        }
        this._parseAllText();
    }
    /**
     * Parses the text based on the provided settings.
     * @param settings The settings for the TextPro sprite.
     * @returns The parsed text configurations.
     */
    static ParseText(settings) {
        const parser = new TextProParser(settings);
        return parser.getConfigs();
    }
    /**
     * Checks if the character is a control separator.
     * @param char The character to check.
     * @returns True if the character is a control separator, otherwise false.
     */
    static isControlSeparator(char) {
        return '\x1b' === char;
    }
    /**
     * Gets the parsed text configurations.
     * @returns The parsed text configurations.
     */
    getConfigs() {
        return this._textsConfigs;
    }
    /**
     * Parses all the text based on the settings.
     * @private
     */
    _parseAllText() {
        try {
            const preparedText = TextProParser.ConvertControlCharacters(this.settings.text);
            const textState = this._makeInitialTextState(preparedText);
            this._processAllText(textState);
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Creates the initial text state.
     * @param text The text to create the state for.
     * @returns The initial text state.
     * @private
     */
    _makeInitialTextState(text) {
        return {
            text: text,
            buffer: "",
            index: 0,
            color: "", // * "" default
            fontSize: -1, // * -1 default
            iconIndex: -1, // * -1 none
        };
    }
    /**
     * Processes all the text based on the text state.
     * @param textState The text state to process.
     * @private
     */
    _processAllText(textState) {
        try {
            while (textState.index < textState.text.length) {
                this._processCharacter(textState);
            }
            this._saveTextConfig(textState);
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Processes a single character in the text state.
     * @param textState The text state to process.
     * @private
     */
    _processCharacter(textState) {
        try {
            const c = textState.text[textState.index++];
            if (c.charCodeAt(0) < 0x20) {
                this._saveTextConfig(textState);
                this._processControlCharacter(textState, c);
            }
            else {
                textState.buffer += c;
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Saves the current text configuration.
     * @param textState The text state to save.
     * @private
     */
    _saveTextConfig(textState) {
        try {
            if (textState.buffer.length > 0 || textState.iconIndex > 0) {
                this._textsConfigs.push({
                    text: textState.buffer,
                    color: textState.color,
                    fontSize: textState.fontSize,
                    iconIndex: textState.iconIndex
                });
                textState.buffer = "";
                textState.iconIndex = -1;
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Processes a control character in the text state.
     * @param textState The text state to process.
     * @param c The control character to process.
     * @private
     */
    _processControlCharacter(textState, c) {
        try {
            if (TextProParser.isControlSeparator(c)) {
                const code = this._obtainEscapeCode(textState);
                this._processEscapeCharacter(code, textState);
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Obtains the escape code from the text state.
     * @param textState The text state to obtain the escape code from.
     * @returns The escape code.
     * @private
     */
    _obtainEscapeCode(textState) {
        try {
            const regExp = /^[$.|^!><{}\\]|^[A-Z]+/i;
            const arr = regExp.exec(textState.text.slice(textState.index));
            if (arr) {
                textState.index += arr[0].length;
                return arr[0].toUpperCase();
            }
            else {
                return "";
            }
        }
        catch (e) {
            console.warn(e);
            return "";
        }
    }
    /**
     * Processes an escape character in the text state.
     * @param code The escape code to process.
     * @param textState The text state to process.
     * @private
     */
    _processEscapeCharacter(code, textState) {
        try {
            let currentFontSize = textState.fontSize;
            switch (code) {
                case "C":
                    const colorIndex = this._obtainEscapeParam(textState);
                    if (colorIndex > 0) {
                        if (KDX.isMV()) {
                            textState.color = window["__kdSharedTextProTextColorSourceWindow"].textColor(colorIndex);
                        }
                        else {
                            textState.color = ColorManager.textColor(colorIndex);
                        }
                    }
                    else {
                        textState.color = "";
                    }
                    break;
                case "I":
                    const iconIndex = this._obtainEscapeParam(textState);
                    if (iconIndex > 0) {
                        textState.iconIndex = iconIndex;
                        // * Icon is a separate sprite, so save the current text as separate
                        this._saveTextConfig(textState);
                    }
                    else {
                        textState.iconIndex = -1;
                    }
                    break;
                case "FS":
                    const fontSize = this._obtainEscapeParam(textState);
                    textState.fontSize = fontSize;
                    break;
                case "{": // * Make font bigger by 1
                    currentFontSize = textState.fontSize;
                    if (currentFontSize === -1) {
                        currentFontSize = this.settings.font.size;
                    }
                    textState.fontSize = currentFontSize + 1;
                    break;
                case "}":
                    currentFontSize = textState.fontSize;
                    if (currentFontSize === -1) {
                        currentFontSize = this.settings.font.size;
                    }
                    textState.fontSize = currentFontSize - 1;
                    break;
                default:
                    console.warn("KNSprite_TextPro: Unknown escape code: " + code);
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    /**
     * Obtains the escape parameter from the text state.
     * @param textState The text state to obtain the escape parameter from.
     * @returns The escape parameter.
     * @private
     */
    _obtainEscapeParam(textState) {
        try {
            const regExp = /^\[\d+\]/;
            const arr = regExp.exec(textState.text.slice(textState.index));
            if (arr) {
                textState.index += arr[0].length;
                return parseInt(arr[0].slice(1));
            }
            else {
                return 0;
            }
        }
        catch (e) {
            console.warn(e);
            return 0;
        }
    }
}


//build: 8 
var KDX;
(function (KDX) {
    /**
     * The version of the KDX Library.
     * @type {string}
     */
    KDX.Version = "0.1";
    /**
     * Checks if the RPG Maker version is MV.
     * @returns {boolean} True if the RPG Maker version is MV, otherwise false.
     */
    /* @ts-ignore */
    KDX.isMV = () => Utils.RPGMAKER_NAME.includes("MV");
    /**
     * Checks if the RPG Maker version is MZ.
     * @returns {boolean} True if the RPG Maker version is MZ, otherwise false.
     */
    KDX.isMZ = () => !KDX.isMV();
    /**
     * Checks if a value is not null and not undefined
     *
     * @param {any} value - The value to check.
     * @returns {boolean} True if the value is not null and not undefined
     */
    KDX.any = (value) => (value === null || value === undefined) ? false : true;
})(KDX || (KDX = {}));
var KArray;
(function (KArray) {
    /**
     * Deletes all occurrences of a specified item from an array.
     *
     * @template T - The type of elements in the array.
     * @param {T[]} array - The array from which to delete items.
     * @param {T} item - The item to delete from the array.
     * @returns {T[]} A new array with all occurrences of the specified item removed.
     */
    function deleteAll(array, item) {
        return array.filter((i) => i !== item);
    }
    KArray.deleteAll = deleteAll;
    /**
     * Returns a random item from an array.
     *
     * @template T - The type of elements in the array.
     * @param {T[]} array - The array from which to select a random item.
     * @returns {T} A random item from the array.
     */
    function randomItem(array) {
        return array[Math.floor(Math.random() * array.length)];
    }
    KArray.randomItem = randomItem;
    /**
     * Shuffles the elements of an array in place.
     *
     * @template T - The type of elements in the array.
     * @param {T[]} array - The array to shuffle.
     * @returns {T[]} The shuffled array.
     */
    function shuffle(array) {
        let currentIndex = array.length;
        let randomIndex;
        while (currentIndex != 0) {
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex--;
            [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
        }
        return array;
    }
    KArray.shuffle = shuffle;
    /**
     * Finds an item in an array by a specified key and value.
     *
     * @template T - The type of elements in the array.
     * @param {T[]} array - The array to search.
     * @param {string} key - The key to match.
     * @param {any} value - The value to match.
     * @returns {T | null} The found item, or null if no item matches.
     */
    function getByKey(array, key, value) {
        try {
            return array.find((i) => i[key] === value);
        }
        catch (error) {
            console.warn(error);
        }
        return null;
    }
    KArray.getByKey = getByKey;
    /**
     * Finds an item in an array by its 'id' property.
     *
     * @template T - The type of elements in the array.
     * @param {T[]} array - The array to search.
     * @param {any} value - The value of the 'id' property to match.
     * @returns {T | null} The found item, or null if no item matches.
     */
    function getById(array, value) {
        return getByKey(array, "id", value);
    }
    KArray.getById = getById;
})(KArray || (KArray = {}));
var KNumber;
(function (KNumber) {
    /**
    * Clamps a number within a specified range.
    *
    * @param {number} value - The value to clamp.
    * @param {number} min - The minimum value.
    * @param {number} max - The maximum value.
    * @returns {number} The clamped value.
    */
    KNumber.clamp = (value, min, max) => {
        return Math.min(Math.max(value, min), max);
    };
    /**
     * Generates a random number between the specified minimum and maximum values (inclusive).
     *
     * @param {number} min - The minimum value of the range.
     * @param {number} max - The maximum value of the range.
     * @returns {number} A random number between the minimum and maximum values.
     */
    KNumber.random = (min, max) => {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    };
    /**
     * Checks if the given number is greater than zero.
     *
     * @param {number} number - The number to be checked.
     * @returns {boolean} `true` if the number is greater than zero, `false` otherwise.
     */
    KNumber.any = (number) => {
        if (number === null || number === undefined) {
            return false;
        }
        return number > 0;
    };
})(KNumber || (KNumber = {}));
var KString;
(function (KString) {
    /**
         * Generates a random string of the specified length.
         * @param {number} length - The length of the generated string.
         * @returns {string} The generated string.
         */
    KString.randomString = (length) => {
        let result = '';
        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        const charactersLength = characters.length;
        for (let i = 0; i < length; i++) {
            result += characters.charAt(Math.floor(Math.random() * charactersLength));
        }
        return result;
    };
    /**
     * Replaces all occurrences of a substring in a string with a specified replacement.
     *
     * @param {string} source - The source string.
     * @param {string} search - The substring to search for.
     * @param {string} replacement - The replacement string.
     * @returns {string} The modified string with all occurrences of the substring replaced.
     */
    KString.replaceAll = (source, search, replacement) => {
        return source.split(search).join(replacement);
    };
    /**
     * Checks if a string is not null, not undefined, and has a length greater than 0 (after trimming).
     *
     * @param {string} str - The string to check.
     * @returns {boolean} True if the string is not null, not undefined, and has a length greater than 0 (after trimming), otherwise false.
     */
    KString.any = (str) => {
        if (str === null || str === undefined) {
            return false;
        }
        // * For compatibility with old verions of KDCore library
        if (typeof str === "boolean") {
            return str == true;
        }
        try {
            if (typeof str == "string") {
                return str.length > 0 || str.trim().length > 0;
            }
            else {
                return true;
            }
        }
        catch (error) {
            console.warn(error);
            return false;
        }
    };
    /**
     * Checks if the provided value is of type string.
     *
     * @param value - The value to check.
     * @returns `true` if the value is a string, otherwise `false`.
     */
    KString.isString = (value) => {
        return typeof value === "string";
    };
})(KString || (KString = {}));
(function () {
    // * RPG Maker MV only
    // * В версии RPG Maker MV не отслеживаются координаты курсора, если мы просто двигаем мышкой
    // * Данный код исправляет эту проблему, чтобы можно было отслеживать координаты курсора, даже если мышь не нажата
    if (!Utils.RPGMAKER_NAME.includes("MV"))
        return;
    //╒═════════════════════════════════════════════════════════════════════════╛
    // ■ TouchInput.ts
    //╒═════════════════════════════════════════════════════════════════════════╛
    //---------------------------------------------------------------------------
    (() => {
        //@[DEFINES]
        const _ = TouchInput;
        //@[ALIAS]
        /*@ts-ignore*/
        const ALIAS___onMouseMove = _._onMouseMove;
        _['_onMouseMove'] = function (event) {
            ALIAS___onMouseMove.call(this, event);
            let x = Graphics.pageToCanvasX(event.pageX);
            let y = Graphics.pageToCanvasY(event.pageY);
            if (Graphics.isInsideCanvas(x, y)) {
                this['_x'] = x;
                this['_y'] = y;
            }
        };
    })();
    // ■ END TouchInput.ts
    //---------------------------------------------------------------------------
})();
var KAudio;
(function (KAudio) {
    /**
     * Plays a sound effect (SE) with the specified parameters.
     *
     * @param name - The name of the sound effect file to play.
     * @param pitch - The pitch of the sound effect. Defaults to 100.
     * @param volume - The volume of the sound effect. Defaults to 100.
     *
     * @remarks
     * If the provided name is empty or invalid, the function will not attempt to play the sound effect.
     */
    function PlaySE(name, pitch = 100, volume = 100) {
        if (!KString.any(name))
            return;
        let audioData = {
            name: name,
            pitch: pitch,
            volume: volume,
            pan: 0,
            pos: 0
        };
        AudioManager.playStaticSe(audioData);
    }
    KAudio.PlaySE = PlaySE;
})(KAudio || (KAudio = {}));
var KGameEvents;
(function (KGameEvents) {
    // * Return whole line that contains the commentCode
    /**
     * Retrieves a specific comment line from a game event based on the provided comment code.
     *
     * @param commentCode - The code to search for within the comment lines.
     * @param event - The game event from which to retrieve the comment line.
     * @returns The comment line containing the specified code, or `null` if not found.
     *
     * @remarks
     * This function searches through the event's page list to find a comment line that includes the specified comment code.
     * It looks for comment codes 108 and 408, which are typically used for comments in RPG Maker events.
     * If the event or its page list is not available, or if no matching comment line is found, the function returns `null`.
     *
     * @throws Will log a warning to the console if an error occurs during the search process.
     */
    function GetCommentLine(commentCode, event) {
        try {
            if (!event)
                return null;
            let page = event.page();
            if (!page)
                return null;
            let list = page.list;
            if (!list)
                return null;
            for (let i = 0; i < list.length; i++) {
                if (!list[i])
                    continue;
                if (list[i].code === 108 || list[i].code === 408) {
                    let line = list[i].parameters[0];
                    if (line && line.includes(commentCode)) {
                        return line;
                    }
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
        return null;
    }
    KGameEvents.GetCommentLine = GetCommentLine;
    /**
     *
     * @param commentCode - The code to search for within the comment lines.
     * @param event - The game event from which to retrieve the comment lines.
     * @returns An array of comment lines containing the specified code, or an empty array if not found.
     */
    function GetCommentLines(commentCode, event) {
        let lines = [];
        try {
            if (!event)
                return lines;
            let page = event.page();
            if (!page)
                return lines;
            let list = page.list;
            if (!list)
                return lines;
            for (let i = 0; i < list.length; i++) {
                if (!list[i])
                    continue;
                if (list[i].code === 108 || list[i].code === 408) {
                    let line = list[i].parameters[0];
                    if (line && line.includes(commentCode)) {
                        lines.push(line);
                    }
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
        return lines;
    }
    KGameEvents.GetCommentLines = GetCommentLines;
    // * For commentCode:value
    /**
     * Retrieves the value associated with a specific comment code from a game event.
     * Pattern commentCode:value
     *
     * @param commentCode - The code of the comment to search for.
     * @param event - The game event object to search within.
     * @returns The value associated with the comment code, or null if not found.
     */
    function GetCommentCodeValue(commentCode, event) {
        try {
            let line = GetCommentLine(commentCode, event);
            if (!line)
                return null;
            let value = line.split(":")[1].trim();
            return value;
        }
        catch (error) {
            console.warn(error);
        }
        return null;
    }
    KGameEvents.GetCommentCodeValue = GetCommentCodeValue;
})(KGameEvents || (KGameEvents = {}));
var KGameItems;
(function (KGameItems) {
    /**
     * Checks if the given object has a meta property with the specified symbol.
     *
     * @param symbol - The symbol to check for in the meta property.
     * @param obj - The object to check for the meta property.
     * @returns `true` if the object has a meta property with the specified symbol, otherwise `false`.
     * @throws Will log a warning to the console if an error occurs during the check.
     */
    function IsHaveMeta(symbol, obj) {
        try {
            return obj && obj.meta && obj.meta.hasOwnProperty(symbol);
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    KGameItems.IsHaveMeta = IsHaveMeta;
    /**
     * Retrieves the metadata associated with a given symbol from an object.
     *
     * @param symbol - The key for the metadata to retrieve.
     * @param obj - The object containing the metadata.
     * @param defaultValue - The value to return if the symbol is not present or an error occurs.
     * @returns The metadata value. If the symbol is not present or an error occurs, returns the default value.
     */
    function GetMeta(symbol, obj, defaultValue = null) {
        try {
            if (!IsHaveMeta(symbol, obj))
                return defaultValue;
            return obj.meta[symbol];
        }
        catch (error) {
            console.warn(error);
        }
        return defaultValue;
    }
    KGameItems.GetMeta = GetMeta;
    /**
     * Retrieves the metadata associated with a given symbol from an object and converts it to an array of strings.
     * Example:
     * <meta:a,b,c> -> ["a", "b", "c"]
     * <meta:a> -> ["a"]
     * @param symbol - The key for the metadata to retrieve.
     * @param obj - The object to check for the meta property.
     * @param defaultValue - The value to return if the symbol is not present or an error occurs.
     * @returns An array of metadata values associated with the symbol. If the symbol is not present or an error occurs, returns the default value.
     */
    function GetMetaValues(symbol, obj, defaultValue = []) {
        try {
            let values = GetMeta(symbol, obj, null);
            if (KString.any(values)) {
                if (values.includes(',')) {
                    // Split values by comma and trim each value
                    let resultValues = values.split(',').map((value) => value.trim());
                    // Filter out empty values
                    resultValues = resultValues.filter((value) => value !== '');
                    return resultValues;
                }
                else {
                    return [values];
                }
            }
        }
        catch (error) {
            console.warn(error);
        }
        return defaultValue;
    }
    KGameItems.GetMetaValues = GetMetaValues;
    /**
     * Retrieves the metadata associated with a given symbol from an object and converts it to an array of numbers.
     * Example:
     * <meta:1,2,3> -> [1, 2, 3]
     * <meta:1> -> [1]
     * @param symbol - The key for the metadata to retrieve.
     * @param obj - The object to check for the meta property.
     * @param defaultValue - The value to return if the symbol is not present or an error occurs.
     * @returns An array of metadata values associated with the symbol. If the symbol is not present or an error occurs, returns the default value.
     * */
    function GetMetaValuesAsNumbers(symbol, obj, defaultValue = []) {
        try {
            let values = GetMetaValues(symbol, obj, []);
            let resultValues = values.map((value) => Number(value.trim()));
            // Filter out NaN values
            resultValues = resultValues.filter((value) => !isNaN(value));
            return resultValues;
        }
        catch (error) {
            console.warn(error);
        }
        return defaultValue;
    }
    KGameItems.GetMetaValuesAsNumbers = GetMetaValuesAsNumbers;
    /**
    * Retrieves the metadata associated with a given symbol from an object when object have many same meta values.
    * Example:
    * <symbol:value1>
    * <symbol:value2>
    * ...
    * Return [value1, value2, ...]
    * @param symbol - The symbol to check for in the meta property.
     * @param obj - The object containing the metadata.
     * @param defaultValue - The value to return if the symbol is not present or an error occurs.
     * @returns  An array of metadata values associated with the symbol. If the symbol is not present or an error occurs, returns an empty array.
     */
    function GetSameMetaValues(symbol, obj, defaultValue = []) {
        try {
            if (!IsHaveMeta(symbol, obj))
                return defaultValue;
            let lines = obj.note.split(/[\r\n]+/).filter(line => line.includes(symbol));
            // Remove symbol from lines
            // Remove < and > from lines
            lines = lines.map(line => line.replace(/<|>/g, '').replace(symbol + ":", '').trim());
            return lines;
        }
        catch (error) {
            console.warn(error);
        }
        return defaultValue;
    }
    KGameItems.GetSameMetaValues = GetSameMetaValues;
    /**
     * Retrieves the metadata associated with the given symbol from the specified object
     * and converts it to a number.
     *
     * @param symbol - The key for the metadata to retrieve.
     * @param obj - The object from which to retrieve the metadata.
     * @param defaultValue - The value to return if the symbol is not present or an error occurs.
     * @returns The metadata value as a number. If the symbol is not present or an error occurs, returns the default value.
     */
    function GetMetaAsNumber(symbol, obj, defaultValue = 0) {
        try {
            return Number(GetMeta(symbol, obj, defaultValue));
        }
        catch (error) {
            console.warn(error);
        }
        return defaultValue;
    }
    KGameItems.GetMetaAsNumber = GetMetaAsNumber;
})(KGameItems || (KGameItems = {}));
var KInput;
(function (KInput) {
    /**
     * Simulates a virtual click on the specified button.
     *
     * @param buttonName - The name of the button to simulate a click on.
     *
     * This function checks if the environment is MV (RPG Maker MV) and if the `Input.virtualClick` method is not already extended.
     * If both conditions are met, it extends the MV Input system to support virtual clicks.
     *
     * @remarks
     * The function uses a TypeScript ignore comment to bypass type checking for the `Input.virtualClick` method.
     */
    function VirtualClick(buttonName) {
        try {
            if (KDX.isMV() && !KDX.any(Input['virtualClick'])) {
                _extendMvInput();
            }
            /* @ts-ignore */
            Input.virtualClick(buttonName);
        }
        catch (error) {
            console.warn(error);
        }
    }
    KInput.VirtualClick = VirtualClick;
    function IsCancel() {
        return Input.isTriggered('cancel') || TouchInput.isCancelled();
    }
    KInput.IsCancel = IsCancel;
    function _extendMvInput() {
        //╒═════════════════════════════════════════════════════════════════════════╛
        // ■ Input.ts
        //╒═════════════════════════════════════════════════════════════════════════╛
        //---------------------------------------------------------------------------
        (() => {
            //@[DEFINES]
            const _ = Input;
            _['virtualClick'] = function (buttonName) {
                this._virtualButton = buttonName;
            };
            //@[ALIAS]
            const ALIAS__clear = _.clear;
            _.clear = function () {
                ALIAS__clear.call(this);
                this._virtualButton = null;
            };
            //@[ALIAS]
            const ALIAS__update = _.update;
            _.update = function () {
                ALIAS__update.call(this);
                try {
                    if (KString.any(this._virtualButton)) {
                        this._latestButton = this._virtualButton;
                        this._pressedTime = 0;
                        this._virtualButton = null;
                    }
                }
                catch (error) {
                    console.warn(error);
                }
            };
        })();
        // ■ END Input.ts
        //---------------------------------------------------------------------------
    }
    function _extend() {
        // * If Input is extended by KDCore or KDX
        if (KDX.any(Input['KeyMapperPKD']))
            return;
        try {
            let KeyMapperPKD = {};
            //Numbers
            for (let i = 48; i <= 57; i++) {
                KeyMapperPKD[i] = String.fromCharCode(i);
            }
            //Letters Upper
            for (let i = 65; i <= 90; i++) {
                KeyMapperPKD[i] = String.fromCharCode(i).toLowerCase();
            }
            //Letters Lower
            for (let i = 97; i <= 122; i++) {
                KeyMapperPKD[i] = String.fromCharCode(i).toLowerCase();
            }
            Input['KeyMapperPKD'] = KeyMapperPKD;
        }
        catch (error) {
            console.warn(error);
        }
    }
    function _onKeyDown(event) {
        try {
            _extend();
            /* @ts-ignore */
            let symbol = Input.KeyMapperPKD[event.keyCode];
            if (symbol) {
                /* @ts-ignore */
                Input._currentState[symbol] = true;
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    KInput._onKeyDown = _onKeyDown;
    function _onKeyUp(event) {
        try {
            _extend();
            /* @ts-ignore */
            let symbol = Input.KeyMapperPKD[event.keyCode];
            if (symbol) {
                /* @ts-ignore */
                Input._currentState[symbol] = false;
            }
        }
        catch (error) {
            console.warn(error);
        }
    }
    KInput._onKeyUp = _onKeyUp;
})(KInput || (KInput = {}));
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Input.ts
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(() => {
    //@[DEFINES]
    const _ = Input;
    //@[ALIAS]
    /* @ts-ignore */
    const ALIAS___onKeyDown = _._onKeyDown;
    /* @ts-ignore */
    _._onKeyDown = function (event) {
        let t = this;
        ALIAS___onKeyDown.call(this, event);
        try {
            if (Input.keyMapper[event.keyCode]) {
                return;
            }
            KInput._onKeyDown(event);
        }
        catch (error) {
            console.warn(error);
        }
    };
    //@[ALIAS]
    /* @ts-ignore */
    const ALIAS___onKeyUp = _._onKeyUp;
    /* @ts-ignore */
    _._onKeyUp = function (event) {
        let t = this;
        ALIAS___onKeyUp.call(this, event);
        try {
            if (Input.keyMapper[event.keyCode]) {
                return;
            }
            KInput._onKeyUp(event);
        }
        catch (error) {
            console.warn(error);
        }
    };
})();
// ■ END Input.ts
//---------------------------------------------------------------------------
var KPoint;
(function (KPoint) {
    /**
     * Clones a given Point object.
     *
     * @param {IPoint} p - The Point object to be cloned.
     * @returns {IPoint} A new Point object with the same x and y coordinates as the input.
     */
    function Clone(p) {
        return new PIXI.Point(p.x, p.y);
    }
    KPoint.Clone = Clone;
    /**
     * Checks if two Point objects have the same coordinates.
     *
     * @param {IPoint} p1 - The first Point object.
     * @param {IPoint} p2 - The second Point object.
     * @returns {boolean} True if both points have the same coordinates, false otherwise.
     */
    function IsSame(p1, p2) {
        return p1.x == p2.x && p1.y == p2.y;
    }
    KPoint.IsSame = IsSame;
    /**
     * Converts a Point object to a string representation.
     *
     * @param {IPoint} p - The Point object to be converted.
     * @returns {string} A string representation of the Point object.
     */
    function ToPrint(p) {
        return `(${p.x}, ${p.y})`;
    }
    KPoint.ToPrint = ToPrint;
    /**
     * Converts a Point object from screen coordinates to map coordinates.
     *
     * @param {IPoint} p - The Point object in screen coordinates.
     * @returns {IPoint} A new Point object in map coordinates.
     */
    function ConvertFromScreenToMap(p) {
        return new PIXI.Point($gameMap.canvasToMapX(p.x), $gameMap.canvasToMapY(p.y));
    }
    KPoint.ConvertFromScreenToMap = ConvertFromScreenToMap;
    /**
     * Converts a Point object from map coordinates to screen coordinates.
     *
     * @param {IPoint} p - The Point object in map coordinates.
     * @returns {IPoint} A new Point object in screen coordinates.
     */
    function ConvertFromMapToScreen(p) {
        let x = $gameMap.adjustX(p.x);
        let tw = $gameMap.tileWidth();
        x = Math.round(x * tw + tw / 2);
        let y = $gameMap.adjustY(p.y);
        let th = $gameMap.tileHeight();
        y = Math.round(y * th + th);
        return new PIXI.Point(x, y);
    }
    KPoint.ConvertFromMapToScreen = ConvertFromMapToScreen;
    /**
     * Rounds the coordinates of a Point object to the nearest integer.
     *
     * @param {IPoint} p - The Point object to be rounded.
     * @returns {IPoint} A new Point object with rounded coordinates.
     */
    function Round(p) {
        return new PIXI.Point(Math.round(p.x), Math.round(p.y));
    }
    KPoint.Round = Round;
    /**
     * Calculates the distance between two Point objects.
     *
     * @param {IPoint} p1 - The first Point object.
     * @param {IPoint} p2 - The second Point object.
     * @returns {number} The distance between the two points.
     */
    function Distance(p1, p2) {
        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
    }
    KPoint.Distance = Distance;
    /**
     * Checks if a Point object is inside a given rectangle.
     *
     * @param {IPoint} p - The Point object to check.
     * @param {PIXI.Rectangle} rect - The rectangle to check against.
     * @returns {boolean} True if the point is inside the rectangle, false otherwise.
     */
    function IsInsideRect(p, rect) {
        return rect.contains(p.x, p.y);
    }
    KPoint.IsInsideRect = IsInsideRect;
    /**
     * Checks if a Point object is inside a given circle.
     *
     * @param {IPoint} p - The Point object to check.
     * @param {IPoint} center - The center of the circle.
     * @param {number} radius - The radius of the circle.
     * @returns {boolean} True if the point is inside the circle, false otherwise.
     */
    function IsInsideCircle(p, center, radius) {
        return Distance(p, center) <= radius;
    }
    KPoint.IsInsideCircle = IsInsideCircle;
})(KPoint || (KPoint = {}));
var KUtils;
(function (KUtils) {
    /**
     * Calls a specified callback function after a given delay.
     *
     * @param callback - The function to be called after the delay.
     * @param delay - The delay in milliseconds before the callback is executed.
     * @returns The ID of the timeout, which can be used to cancel the timeout with clearTimeout.
     *
     * @throws Will log a warning to the console if the callback throws an error.
     */
    function CallWithDelay(callback, delay) {
        if (!callback)
            return;
        return setTimeout(() => {
            try {
                callback();
            }
            catch (error) {
                console.warn(error);
            }
        }, delay);
    }
    KUtils.CallWithDelay = CallWithDelay;
    function IsMapScene() {
        return SceneManager._scene instanceof Scene_Map;
    }
    KUtils.IsMapScene = IsMapScene;
    function IsBattleScene() {
        return SceneManager._scene instanceof Scene_Battle;
    }
    KUtils.IsBattleScene = IsBattleScene;
    function StartCEIfValid(commonEventId) {
        try {
            if (commonEventId > 0 && $dataCommonEvents[commonEventId]) {
                $gameTemp.reserveCommonEvent(commonEventId);
                return true;
            }
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    KUtils.StartCEIfValid = StartCEIfValid;
    function IsValidSelfSwitch(selfSwitch) {
        try {
            return ['A', 'B', 'C', 'D'].indexOf(selfSwitch) !== -1;
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    KUtils.IsValidSelfSwitch = IsValidSelfSwitch;
    function IsChanceIsPassed(chance) {
        try {
            if (chance > 1) {
                chance = chance / 100.0;
            }
            if (chance < 0) {
                chance = 0;
            }
            if (chance > 1) {
                chance = 1;
            }
            return Math.random() < chance;
        }
        catch (error) {
            console.warn(error);
        }
        return false;
    }
    KUtils.IsChanceIsPassed = IsChanceIsPassed;
})(KUtils || (KUtils = {}));
var KDX;
(function (KDX) {
    /**
 * A class that can smoothly change a parameter.
 * Works in a chainable method style.
 *
 * Example:
 * ```typescript
 * const changer = new Changer(someSprite);
 * changer.change('opacity').from(255)
 *        .to(0).step(5).speed(1).delay(30).repeat(4).reverse()
 *        .start().done(() => console.log('done'));
 * changer.update();
 * ```
 */
    class Changer {
        constructor(obj) {
            this.obj = obj;
            this._field = null;
            this._speed = 1;
            this._step = 1;
            this._from = 0;
            this._to = 0;
            this._thread = null;
            this._orienation = true;
            this._delay = 0;
            this._changer = null;
            this._isRepeat = false;
            this._onDoneMethod = null;
            this._isPrepared = false;
            this._isBeenStarted = false;
            this._repeatCount = null;
            this._isReverse = false;
            this._delayThread = null;
        }
        static Opacity(sprite, from, to, step, onDone = null, delay = 0) {
            const changer = new Changer(sprite);
            changer.change('opacity').from(from).to(to).step(step);
            if (delay > 0)
                changer.delay(delay);
            if (onDone)
                changer.done(onDone);
            changer.start();
            return changer;
        }
        static MoveX(obj, from, to, step, onDone = null, delay = 0) {
            const changer = new Changer(obj);
            changer.change('x').from(from).to(to).step(step);
            if (delay > 0)
                changer.delay(delay);
            if (onDone)
                changer.done(onDone);
            changer.start();
            return changer;
        }
        static MoveY(obj, from, to, step, onDone = null, delay = 0) {
            const changer = new Changer(obj);
            changer.change('y').from(from).to(to).step(step);
            if (delay > 0)
                changer.delay(delay);
            if (onDone)
                changer.done(onDone);
            changer.start();
            return changer;
        }
        static Appear(sprite, step, onDone = null, delay = 0) {
            const changer = new Changer(sprite);
            changer.change('opacity').from(sprite.opacity).to(255).step(step);
            if (delay > 0)
                changer.delay(delay);
            if (onDone)
                changer.done(onDone);
            changer.start();
            return changer;
        }
        static Disappear(sprite, step, onDone = null, delay = 0) {
            const changer = new Changer(sprite);
            changer.change('opacity').from(sprite.opacity).to(0).step(step);
            if (delay > 0)
                changer.delay(delay);
            if (onDone)
                changer.done(onDone);
            changer.start();
            return changer;
        }
        /**
         * Starts the changer.
         */
        start() {
            if (!this._field || this._from === this._to)
                return this;
            if (this._delay > 0) {
                this._delayThread = new KDX.TimedUpdate(this._delay, this._startThread.bind(this));
                this._delayThread.once();
            }
            else {
                this._startThread();
            }
            return this;
        }
        /**
         * Checks if the changer has started.
         */
        isStarted() {
            return !!this._thread || !!this._delayThread;
        }
        /**
         * Sets the starting value.
         */
        from(value) {
            this._from = value;
            return this;
        }
        /**
         * Sets the target value.
         */
        to(value) {
            this._to = value;
            return this;
        }
        /**
         * Sets the step value for each update.
         */
        step(value) {
            this._step = value;
            return this;
        }
        /**
         * Sets the speed (frames per update).
         */
        speed(value) {
            this._speed = value;
            return this;
        }
        /**
         * Sets the field to be changed.
         */
        change(field) {
            this._field = field;
            return this;
        }
        /**
         * Repeats the changer. If no count is specified or <= 0, it repeats indefinitely.
         */
        repeat(count = 0) {
            this._repeatCount = count <= 0 ? null : count;
            this._isRepeat = true;
            this._changer = null;
            return this;
        }
        /**
         * Reverses the `from` and `to` values after each repeat (works only with repeat >= 2).
         */
        reverse() {
            this._isReverse = true;
            return this;
        }
        /**
         * Checks if the changer has completed.
         */
        isDone() {
            if (!this._isPrepared)
                return false;
            if (!this._orienation) {
                return this.value() <= this._to;
            }
            else {
                return this.value() >= this._to;
            }
        }
        /**
         * Gets the current value of the field being changed.
         */
        value() {
            return this.obj[this._field];
        }
        /**
         * Stops the changer.
         */
        stop() {
            this._thread = null;
            this._delayThread = null;
            if (!this._changer)
                this._callDoneMethod();
        }
        /**
         * Sets a delay before starting the changer.
         */
        delay(value) {
            this._delay = value;
            return this;
        }
        /**
         * Chains another changer to execute after this one.
         * Not compatible with repeat.
         */
        then(changer) {
            this._isRepeat = false;
            this._changer = changer;
            return this;
        }
        /**
         * Sets a method to be executed when the changer is done.
         */
        done(method) {
            this._onDoneMethod = method;
            return this;
        }
        /**
         * Manually performs a single step of the changer.
         */
        makeStep() {
            if (!this.isStarted())
                this._prepare();
            this._makeStep();
            return this;
        }
        /**
         * Updates the changer. Should be called every frame.
         */
        update() {
            var _a;
            if (this.isStarted()) {
                if (this._delay > 0)
                    (_a = this._delayThread) === null || _a === void 0 ? void 0 : _a.update();
                if (this._thread)
                    this._updateMainThread();
            }
            else if (this._isBeenStarted) {
                if (this._changer)
                    this._updateChainedChanger();
            }
        }
        // Private methods
        _prepare() {
            if (!this._field)
                return;
            this._orienation = this._from < this._to;
            if (!this._orienation)
                this._step *= -1;
            this.obj[this._field] = this._from;
            this._isPrepared = true;
        }
        _makeStep() {
            if (this.isDone())
                return;
            let value = this.value();
            value += this._step;
            this.obj[this._field] = value;
        }
        _startThread() {
            this._prepare();
            if (this.isDone())
                return;
            this._thread = new KDX.TimedUpdate(this._speed, this._makeStep.bind(this));
            this._isBeenStarted = true;
        }
        _updateChainedChanger() {
            if (this._changer.isStarted()) {
                this._changer.update();
                if (this._changer.isDone()) {
                    this._callDoneMethod();
                    this._changer.stop();
                    this._changer = null;
                }
            }
            else {
                this._changer.start();
            }
        }
        _restart() {
            if (!this._isCanRepeatMore())
                return;
            if (!this._repeatCount)
                this._callDoneMethod();
            if (this._isReverse)
                this._swapFromTo();
            this._prepare();
            this.start();
        }
        _swapFromTo() {
            const temp = this._from;
            this._from = this._to;
            this._to = temp;
            this._step *= -1;
        }
        _callDoneMethod() {
            if (this._onDoneMethod)
                this._onDoneMethod();
        }
        _isCanRepeatMore() {
            if (!this._repeatCount)
                return true;
            this._repeatCount--;
            if (this._repeatCount <= 0) {
                this.stop();
                return false;
            }
            return true;
        }
        _updateMainThread() {
            this._thread.update();
            if (this.isDone()) {
                if (this._isRepeat) {
                    this._restart();
                }
                else {
                    if (this._changer)
                        this._updateChainedChanger();
                    this.stop();
                }
            }
        }
    }
    KDX.Changer = Changer;
})(KDX || (KDX = {}));
var KDX;
(function (KDX) {
    /**
     * Handles input mode switching between mouse and keyboard.
     * Tracks mouse activity and triggers a callback when the input mode changes.
     */
    class MouseKeyboardInputHandler {
        constructor() {
            /**
             * Stores the last known mouse position.
             * Initialized to an invalid position (-1, -1).
             */
            this._lastMousePosition = { x: -1, y: -1 };
            /**
             * Indicates whether the mouse is currently active.
             */
            this._isMouseActive = false;
            /**
             * Callback function triggered when the input mode changes.
             */
            this._onInputModeChanged = null;
        }
        /**
         * Sets the callback function to be executed when the input mode changes.
         * @param callback - The function to call when the input mode changes.
         */
        set onInputModeChanged(callback) {
            this._onInputModeChanged = callback;
        }
        /**
         * Checks if the mouse is currently active.
         * @returns `true` if the mouse is active, otherwise `false`.
         */
        isMouseActive() {
            return this._isMouseActive;
        }
        /**
         * Handles keyboard key input.
         * If the mouse was previously active, it deactivates the mouse and triggers the input mode change callback.
         */
        onKeyboardKey() {
            if (this._isMouseActive) {
                this._isMouseActive = false; // Reset mouse activity flag when a key is pressed
                if (this._onInputModeChanged) {
                    this._onInputModeChanged();
                }
            }
        }
        /**
         * Updates the input handler.
         * Checks if the mouse position has changed and activates the mouse if necessary.
         * Triggers the input mode change callback when the mouse becomes active.
         */
        update() {
            if (TouchInput.x !== this._lastMousePosition.x || TouchInput.y !== this._lastMousePosition.y) {
                if (!this._isMouseActive) {
                    this._isMouseActive = true;
                    if (this._onInputModeChanged) {
                        this._onInputModeChanged();
                    }
                }
                this._lastMousePosition = { x: TouchInput.x, y: TouchInput.y };
            }
        }
    }
    KDX.MouseKeyboardInputHandler = MouseKeyboardInputHandler;
})(KDX || (KDX = {}));
var KDX;
(function (KDX) {
    class ParamLoader {
        /**
         * Creates an instance of ParamLoader.
         * @param _pluginName The name of the plugin.
         */
        constructor(_pluginName) {
            this._pluginName = _pluginName;
            this._paramsRaw = this.getPluginParametersByRoot(this._pluginName);
            this._params = KDX.ParamParser.ParseParameters(this._paramsRaw, this._pluginName);
        }
        /**
         * Gets the plugin parameters by the root name.
         * @param rootName The root name of the plugin.
         * @returns The plugin parameters if found, otherwise calls PluginManager.parameters.
         */
        getPluginParametersByRoot(rootName) {
            /* @ts-ignore */
            let allParametersRaw = PluginManager._parameters;
            for (const property in allParametersRaw) {
                if (allParametersRaw.hasOwnProperty(property)) {
                    const pluginParameters = allParametersRaw[property];
                    if (pluginParameters.hasOwnProperty(rootName)) {
                        return pluginParameters;
                    }
                }
            }
            return PluginManager.parameters(rootName);
        }
        /**
         * Checks if the parameters are loaded.
         * @returns True if the parameters are loaded, otherwise false.
         */
        isLoaded() {
            return !!this._paramsRaw && this._paramsRaw.hasOwnProperty(this._pluginName);
        }
        /**
         * Checks if a parameter exists.
         * @param paramName The name of the parameter.
         * @returns True if the parameter exists, otherwise false.
         */
        isHasParameter(paramName) {
            return this._params.hasOwnProperty(paramName);
        }
        /**
         * Gets the value of a parameter.
         * @param paramName The name of the parameter.
         * @param def The default value if the parameter is not found.
         * @returns The value of the parameter or the default value.
         */
        getParam(paramName, def) {
            if (this.isHasParameter(paramName)) {
                const value = this._params[paramName];
                if (value != null)
                    return value;
            }
            return def;
        }
    }
    KDX.ParamLoader = ParamLoader;
})(KDX || (KDX = {}));
var KDX;
(function (KDX) {
    let ParamParser;
    (function (ParamParser) {
        let _ppNameToParseNext = "";
        let _pluginName = "";
        /**
         * Parses the parameters from the plugin.
         * @param paramSet The raw parameter set.
         * @returns The parsed parameters.
         */
        function ParseParameters(paramSet, _pluginNameForInfo) {
            _pluginName = _pluginNameForInfo;
            const params = {};
            for (const key in paramSet) {
                if (paramSet.hasOwnProperty(key)) {
                    _ppNameToParseNext = key;
                    const clearKey = parseKey(key);
                    const typeKey = parseKeyType(key);
                    params[clearKey] = parseParamItem(typeKey, paramSet[key]);
                }
            }
            return params;
        }
        ParamParser.ParseParameters = ParseParameters;
        /**
         * Parses the key to remove the type.
         * @param keyRaw The raw key.
         * @returns The parsed key.
         */
        function parseKey(keyRaw) {
            return keyRaw.split(":")[0];
        }
        /**
         * Parses the key to get the type.
         * @param keyRaw The raw key.
         * @returns The type of the key.
         */
        function parseKeyType(keyRaw) {
            return keyRaw.split(":")[1];
        }
        /**
         * Writes a detailed error message to the console.
         */
        function writeDetailedError() {
            try {
                if (!KString.any(_ppNameToParseNext))
                    return;
                console.warn(`Please, check Plugin Parameter ${_ppNameToParseNext} in plugin ${_pluginName}`);
            }
            catch (e) {
                console.warn(e);
            }
        }
        /**
         * Parses a parameter item based on its type.
         * @param type The type of the parameter.
         * @param item The parameter item.
         * @returns The parsed parameter item.
         */
        function parseParamItem(type, item) {
            if (!type)
                return item;
            try {
                switch (type) {
                    case "int":
                    case "i":
                        return Number(item);
                    case "intA":
                        return parseArray(item, "int");
                    case "bool":
                    case "b":
                    case "e":
                        return eval(item);
                    case "struct":
                    case "s":
                        return parseStruct(item);
                    case "structA":
                        return parseStructArray(item);
                    case "str":
                        return item;
                    case "strA":
                        return parseArray(item, "str");
                    case "note":
                        return parseNote(item);
                    case "json":
                    case "j":
                        return parseJson(item);
                    case "jA":
                        return parseArray(item, "json");
                    default:
                        return item;
                }
            }
            catch (e) {
                console.warn(e);
                writeDetailedError();
                return item;
            }
        }
        /**
         * Parses an array of items.
         * @param items The items to parse.
         * @param type The type of the items.
         * @returns The parsed array.
         */
        function parseArray(items, type) {
            try {
                const elements = [];
                const parsed = JsonEx.parse(items);
                for (const p of parsed) {
                    try {
                        elements.push(parseParamItem(type, p));
                    }
                    catch (e) {
                        console.warn(e);
                    }
                }
                return elements;
            }
            catch (e) {
                console.warn(e);
                writeDetailedError();
                return [];
            }
        }
        /**
         * Parses a struct item.
         * @param item The item to parse.
         * @returns The parsed struct.
         */
        function parseStruct(item) {
            try {
                if (!item || !KString.any(item))
                    return null;
                const parsed = JsonEx.parse(item);
                return parsed ? ParseParameters(parsed, _pluginName) : null;
            }
            catch (e) {
                console.warn(e);
                writeDetailedError();
                return null;
            }
        }
        /**
         * Parses an array of struct items.
         * @param items The items to parse.
         * @returns The parsed array of structs.
         */
        function parseStructArray(items) {
            try {
                const elements = [];
                const parsed = JsonEx.parse(items);
                for (const p of parsed) {
                    try {
                        elements.push(parseStruct(p));
                    }
                    catch (e) {
                        console.warn(e);
                        writeDetailedError();
                    }
                }
                return elements;
            }
            catch (e) {
                console.warn(e);
                writeDetailedError();
                return [];
            }
        }
        /**
         * Parses a note item.
         * @param item The item to parse.
         * @returns The parsed note.
         */
        function parseNote(item) {
            try {
                const parsed = JsonEx.parse(item);
                return parsed ? parsed : item;
            }
            catch (e) {
                console.warn(e);
                writeDetailedError();
                return item;
            }
        }
        /**
         * Parses a JSON item.
         * @param item The item to parse.
         * @returns The parsed JSON.
         */
        function parseJson(item) {
            try {
                const json = {};
                const parsed = JsonEx.parse(item);
                const elements = parsed.split('\n');
                for (const element of elements) {
                    const cx = `{${element}}`;
                    try {
                        const item = JsonEx.parse(cx);
                        for (const key in item) {
                            if (item.hasOwnProperty(key)) {
                                json[key] = item[key];
                            }
                        }
                    }
                    catch (e) {
                        console.warn(`Parameter ${element} has syntax errors, ignored`);
                    }
                }
                return json;
            }
            catch (e) {
                console.warn(e);
                writeDetailedError();
                return null; // To return default value
            }
        }
    })(ParamParser = KDX.ParamParser || (KDX.ParamParser = {}));
})(KDX || (KDX = {}));
var KDX;
(function (KDX) {
    class TimedUpdate {
        /**
         * Creates an instance of TimedUpdate.
         * @param interval The interval in frames.
         * @param method The method to call on update.
         */
        constructor(interval, method) {
            this.interval = interval;
            this.method = method;
            this._timer = 0;
            this._once = false;
        }
        /**
         * Sets the number of repeats and the callback after completion.
         * @param repeatsLeft The number of repeats left.
         * @param afterCallback The callback to call after completion.
         */
        setAfter(repeatsLeft, afterCallback) {
            this._repeatsLeft = repeatsLeft;
            this._afterCallback = afterCallback;
        }
        /**
         * Updates the timer and calls the method if the interval is reached.
         */
        update() {
            if (this.interval == null)
                return;
            if (this._timer++ >= this.interval) {
                this.call();
                this._timer = 0;
                if (this._repeatsLeft != null) {
                    this._repeatsLeft -= 1;
                    if (this._repeatsLeft <= 0) {
                        if (this._afterCallback)
                            this._afterCallback();
                    }
                }
                if (this._once)
                    this.stop();
            }
        }
        /**
         * Sets the update to be called only once.
         */
        once() {
            this._once = true;
        }
        /**
         * Sets the method to call on update.
         * @param method The method to call on update.
         */
        onUpdate(method) {
            this.method = method;
        }
        /**
         * Stops the update.
         */
        stop() {
            this.interval = null;
        }
        /**
         * Checks if the update is still active.
         * @returns True if the update is active, otherwise false.
         */
        isAlive() {
            return this.interval != null;
        }
        /**
         * Randomizes the interval within a given range.
         * @param min The minimum value to add to the interval.
         * @param max The maximum value to add to the interval.
         */
        applyTimeRange(min, max) {
            if (!this.isAlive())
                return;
            const value = KNumber.random(min, max);
            this.interval += value;
        }
        /**
         * Calls the method.
         */
        call() {
            try {
                if (this.method)
                    this.method();
            }
            catch (e) {
                console.warn(e);
            }
        }
    }
    KDX.TimedUpdate = TimedUpdate;
})(KDX || (KDX = {}));


/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/pixi-filters@5.3.0/dist/browser/pixi-filters.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
/*!
 * pixi-filters - v5.3.0
 * Compiled Thu, 15 Feb 2024 16:39:05 UTC
 *
 * pixi-filters is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var __filters=function(e,t,r,n){"use strict";class i extends t.Filter{constructor(e){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform float gamma;\nuniform float contrast;\nuniform float saturation;\nuniform float brightness;\nuniform float red;\nuniform float green;\nuniform float blue;\nuniform float alpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (c.a > 0.0) {\n        c.rgb /= c.a;\n\n        vec3 rgb = pow(c.rgb, vec3(1. / gamma));\n        rgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb)), rgb, saturation), contrast);\n        rgb.r *= red;\n        rgb.g *= green;\n        rgb.b *= blue;\n        c.rgb = rgb * brightness;\n\n        c.rgb *= c.a;\n    }\n\n    gl_FragColor = c * alpha;\n}\n"),this.gamma=1,this.saturation=1,this.contrast=1,this.brightness=1,this.red=1,this.green=1,this.blue=1,this.alpha=1,Object.assign(this,e)}apply(e,t,r,n){this.uniforms.gamma=Math.max(this.gamma,1e-4),this.uniforms.saturation=this.saturation,this.uniforms.contrast=this.contrast,this.uniforms.brightness=this.brightness,this.uniforms.red=this.red,this.uniforms.green=this.green,this.uniforms.blue=this.blue,this.uniforms.alpha=this.alpha,e.applyFilter(this,t,r,n)}}class o extends t.Filter{constructor(e=4,r=3,n=!1){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}",n?"\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec2 uOffset;\nuniform vec4 filterClamp;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample top right pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample bottom right pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Sample bottom left pixel\n    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y), filterClamp.xy, filterClamp.zw));\n\n    // Average\n    color *= 0.25;\n\n    gl_FragColor = color;\n}\n":"\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec2 uOffset;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample top right pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample bottom right pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Sample bottom left pixel\n    color += texture2D(uSampler, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Average\n    color *= 0.25;\n\n    gl_FragColor = color;\n}"),this._kernels=[],this._blur=4,this._quality=3,this.uniforms.uOffset=new Float32Array(2),this._pixelSize=new t.Point,this.pixelSize=1,this._clamp=n,Array.isArray(e)?this.kernels=e:(this._blur=e,this.quality=r)}apply(e,t,r,n){const i=this._pixelSize.x/t._frame.width,o=this._pixelSize.y/t._frame.height;let s;if(1===this._quality||0===this._blur)s=this._kernels[0]+.5,this.uniforms.uOffset[0]=s*i,this.uniforms.uOffset[1]=s*o,e.applyFilter(this,t,r,n);else{const a=e.getFilterTexture();let l,u=t,c=a;const f=this._quality-1;for(let t=0;t<f;t++)s=this._kernels[t]+.5,this.uniforms.uOffset[0]=s*i,this.uniforms.uOffset[1]=s*o,e.applyFilter(this,u,c,1),l=u,u=c,c=l;s=this._kernels[f]+.5,this.uniforms.uOffset[0]=s*i,this.uniforms.uOffset[1]=s*o,e.applyFilter(this,u,r,n),e.returnFilterTexture(a)}}_updatePadding(){this.padding=Math.ceil(this._kernels.reduce(((e,t)=>e+t+.5),0))}_generateKernels(){const e=this._blur,t=this._quality,r=[e];if(e>0){let n=e;const i=e/t;for(let e=1;e<t;e++)n-=i,r.push(n)}this._kernels=r,this._updatePadding()}get kernels(){return this._kernels}set kernels(e){Array.isArray(e)&&e.length>0?(this._kernels=e,this._quality=e.length,this._blur=Math.max(...e)):(this._kernels=[0],this._quality=1)}get clamp(){return this._clamp}set pixelSize(e){"number"==typeof e?(this._pixelSize.x=e,this._pixelSize.y=e):Array.isArray(e)?(this._pixelSize.x=e[0],this._pixelSize.y=e[1]):e instanceof t.Point?(this._pixelSize.x=e.x,this._pixelSize.y=e.y):(this._pixelSize.x=1,this._pixelSize.y=1)}get pixelSize(){return this._pixelSize}get quality(){return this._quality}set quality(e){this._quality=Math.max(1,Math.round(e)),this._generateKernels()}get blur(){return this._blur}set blur(e){this._blur=e,this._generateKernels()}}var s="attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";class a extends t.Filter{constructor(e=.5){super(s,"\nuniform sampler2D uSampler;\nvarying vec2 vTextureCoord;\n\nuniform float threshold;\n\nvoid main() {\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    // A simple & fast algorithm for getting brightness.\n    // It's inaccuracy , but good enought for this feature.\n    float _max = max(max(color.r, color.g), color.b);\n    float _min = min(min(color.r, color.g), color.b);\n    float brightness = (_max + _min) * 0.5;\n\n    if(brightness > threshold) {\n        gl_FragColor = color;\n    } else {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}\n"),this.threshold=e}get threshold(){return this.uniforms.threshold}set threshold(e){this.uniforms.threshold=e}}const l=class extends t.Filter{constructor(e){super(s,"uniform sampler2D uSampler;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D bloomTexture;\nuniform float bloomScale;\nuniform float brightness;\n\nvoid main() {\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    color.rgb *= brightness;\n    vec4 bloomColor = vec4(texture2D(bloomTexture, vTextureCoord).rgb, 0.0);\n    bloomColor.rgb *= bloomScale;\n    gl_FragColor = color + bloomColor;\n}\n"),this.bloomScale=1,this.brightness=1,this._resolution=t.settings.FILTER_RESOLUTION,"number"==typeof e&&(e={threshold:e});const r=Object.assign(l.defaults,e);this.bloomScale=r.bloomScale,this.brightness=r.brightness;const{kernels:n,blur:i,quality:u,pixelSize:c,resolution:f}=r;this._extractFilter=new a(r.threshold),this._extractFilter.resolution=f,this._blurFilter=n?new o(n):new o(i,u),this.pixelSize=c,this.resolution=f}apply(e,t,r,n,i){const o=e.getFilterTexture();this._extractFilter.apply(e,t,o,1,i);const s=e.getFilterTexture();this._blurFilter.apply(e,o,s,1),this.uniforms.bloomScale=this.bloomScale,this.uniforms.brightness=this.brightness,this.uniforms.bloomTexture=s,e.applyFilter(this,t,r,n),e.returnFilterTexture(s),e.returnFilterTexture(o)}get resolution(){return this._resolution}set resolution(e){this._resolution=e,this._extractFilter&&(this._extractFilter.resolution=e),this._blurFilter&&(this._blurFilter.resolution=e)}get threshold(){return this._extractFilter.threshold}set threshold(e){this._extractFilter.threshold=e}get kernels(){return this._blurFilter.kernels}set kernels(e){this._blurFilter.kernels=e}get blur(){return this._blurFilter.blur}set blur(e){this._blurFilter.blur=e}get quality(){return this._blurFilter.quality}set quality(e){this._blurFilter.quality=e}get pixelSize(){return this._blurFilter.pixelSize}set pixelSize(e){this._blurFilter.pixelSize=e}};let u=l;u.defaults={threshold:.5,bloomScale:1,brightness:1,kernels:null,blur:8,quality:4,pixelSize:1,resolution:t.settings.FILTER_RESOLUTION};class c extends t.Filter{constructor(e=8){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\n\nuniform vec4 filterArea;\nuniform float pixelSize;\nuniform sampler2D uSampler;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= filterArea.xy;\n    coord += filterArea.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= filterArea.zw;\n    coord /= filterArea.xy;\n\n    return coord;\n}\n\nvec2 pixelate(vec2 coord, vec2 size)\n{\n    return floor(coord / size) * size;\n}\n\nvec2 getMod(vec2 coord, vec2 size)\n{\n    return mod(coord, size) / size;\n}\n\nfloat character(float n, vec2 p)\n{\n    p = floor(p*vec2(4.0, 4.0) + 2.5);\n\n    if (clamp(p.x, 0.0, 4.0) == p.x)\n    {\n        if (clamp(p.y, 0.0, 4.0) == p.y)\n        {\n            if (int(mod(n/exp2(p.x + 5.0*p.y), 2.0)) == 1) return 1.0;\n        }\n    }\n    return 0.0;\n}\n\nvoid main()\n{\n    vec2 coord = mapCoord(vTextureCoord);\n\n    // get the grid position\n    vec2 pixCoord = pixelate(coord, vec2(pixelSize));\n    pixCoord = unmapCoord(pixCoord);\n\n    // sample the color at grid position\n    vec4 color = texture2D(uSampler, pixCoord);\n\n    // brightness of the color as it's perceived by the human eye\n    float gray = 0.3 * color.r + 0.59 * color.g + 0.11 * color.b;\n\n    // determine the character to use\n    float n =  65536.0;             // .\n    if (gray > 0.2) n = 65600.0;    // :\n    if (gray > 0.3) n = 332772.0;   // *\n    if (gray > 0.4) n = 15255086.0; // o\n    if (gray > 0.5) n = 23385164.0; // &\n    if (gray > 0.6) n = 15252014.0; // 8\n    if (gray > 0.7) n = 13199452.0; // @\n    if (gray > 0.8) n = 11512810.0; // #\n\n    // get the mod..\n    vec2 modd = getMod(coord, vec2(pixelSize));\n\n    gl_FragColor = color * character( n, vec2(-1.0) + modd * 2.0);\n\n}\n"),this.size=e}get size(){return this.uniforms.pixelSize}set size(e){this.uniforms.pixelSize=e}}class f extends t.Filter{constructor(e){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","precision mediump float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform float transformX;\nuniform float transformY;\nuniform vec3 lightColor;\nuniform float lightAlpha;\nuniform vec3 shadowColor;\nuniform float shadowAlpha;\n\nvoid main(void) {\n    vec2 transform = vec2(1.0 / filterArea) * vec2(transformX, transformY);\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float light = texture2D(uSampler, vTextureCoord - transform).a;\n    float shadow = texture2D(uSampler, vTextureCoord + transform).a;\n\n    color.rgb = mix(color.rgb, lightColor, clamp((color.a - light) * lightAlpha, 0.0, 1.0));\n    color.rgb = mix(color.rgb, shadowColor, clamp((color.a - shadow) * shadowAlpha, 0.0, 1.0));\n    gl_FragColor = vec4(color.rgb * color.a, color.a);\n}\n"),this._thickness=2,this._angle=0,this.uniforms.lightColor=new Float32Array(3),this.uniforms.shadowColor=new Float32Array(3),Object.assign(this,{rotation:45,thickness:2,lightColor:16777215,lightAlpha:.7,shadowColor:0,shadowAlpha:.7},e),this.padding=1}_updateTransform(){this.uniforms.transformX=this._thickness*Math.cos(this._angle),this.uniforms.transformY=this._thickness*Math.sin(this._angle)}get rotation(){return this._angle/t.DEG_TO_RAD}set rotation(e){this._angle=e*t.DEG_TO_RAD,this._updateTransform()}get thickness(){return this._thickness}set thickness(e){this._thickness=e,this._updateTransform()}get lightColor(){return t.utils.rgb2hex(this.uniforms.lightColor)}set lightColor(e){t.utils.hex2rgb(e,this.uniforms.lightColor)}get lightAlpha(){return this.uniforms.lightAlpha}set lightAlpha(e){this.uniforms.lightAlpha=e}get shadowColor(){return t.utils.rgb2hex(this.uniforms.shadowColor)}set shadowColor(e){t.utils.hex2rgb(e,this.uniforms.shadowColor)}get shadowAlpha(){return this.uniforms.shadowAlpha}set shadowAlpha(e){this.uniforms.shadowAlpha=e}}class d extends t.Filter{constructor(e=2,i=4,o=t.settings.FILTER_RESOLUTION,s=5){let a,l;super(),"number"==typeof e?(a=e,l=e):e instanceof t.Point?(a=e.x,l=e.y):Array.isArray(e)&&(a=e[0],l=e[1]),this.blurXFilter=new n.BlurFilterPass(!0,a,i,o,s),this.blurYFilter=new n.BlurFilterPass(!1,l,i,o,s),this.blurYFilter.blendMode=t.BLEND_MODES.SCREEN,this.defaultFilter=new r.AlphaFilter}apply(e,t,r,n){const i=e.getFilterTexture();this.defaultFilter.apply(e,t,r,n),this.blurXFilter.apply(e,t,i,1),this.blurYFilter.apply(e,i,r,0),e.returnFilterTexture(i)}get blur(){return this.blurXFilter.blur}set blur(e){this.blurXFilter.blur=this.blurYFilter.blur=e}get blurX(){return this.blurXFilter.blur}set blurX(e){this.blurXFilter.blur=e}get blurY(){return this.blurYFilter.blur}set blurY(e){this.blurYFilter.blur=e}}const h=class extends t.Filter{constructor(e){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","uniform float radius;\nuniform float strength;\nuniform vec2 center;\nuniform sampler2D uSampler;\nvarying vec2 vTextureCoord;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform vec2 dimensions;\n\nvoid main()\n{\n    vec2 coord = vTextureCoord * filterArea.xy;\n    coord -= center * dimensions.xy;\n    float distance = length(coord);\n    if (distance < radius) {\n        float percent = distance / radius;\n        if (strength > 0.0) {\n            coord *= mix(1.0, smoothstep(0.0, radius / distance, percent), strength * 0.75);\n        } else {\n            coord *= mix(1.0, pow(percent, 1.0 + strength * 0.75) * radius / distance, 1.0 - percent);\n        }\n    }\n    coord += center * dimensions.xy;\n    coord /= filterArea.xy;\n    vec2 clampedCoord = clamp(coord, filterClamp.xy, filterClamp.zw);\n    vec4 color = texture2D(uSampler, clampedCoord);\n    if (coord != clampedCoord) {\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\n    }\n\n    gl_FragColor = color;\n}\n"),this.uniforms.dimensions=new Float32Array(2),Object.assign(this,h.defaults,e)}apply(e,t,r,n){const{width:i,height:o}=t.filterFrame;this.uniforms.dimensions[0]=i,this.uniforms.dimensions[1]=o,e.applyFilter(this,t,r,n)}get radius(){return this.uniforms.radius}set radius(e){this.uniforms.radius=e}get strength(){return this.uniforms.strength}set strength(e){this.uniforms.strength=e}get center(){return this.uniforms.center}set center(e){this.uniforms.center=e}};let m=h;m.defaults={center:[.5,.5],radius:100,strength:1};var g,v;(v=v||{}).stringify=(g={"visit_linear-gradient":function(e){return g.visit_gradient(e)},"visit_repeating-linear-gradient":function(e){return g.visit_gradient(e)},"visit_radial-gradient":function(e){return g.visit_gradient(e)},"visit_repeating-radial-gradient":function(e){return g.visit_gradient(e)},visit_gradient:function(e){var t=g.visit(e.orientation);return t&&(t+=", "),e.type+"("+t+g.visit(e.colorStops)+")"},visit_shape:function(e){var t=e.value,r=g.visit(e.at),n=g.visit(e.style);return n&&(t+=" "+n),r&&(t+=" at "+r),t},"visit_default-radial":function(e){var t="",r=g.visit(e.at);return r&&(t+=r),t},"visit_extent-keyword":function(e){var t=e.value,r=g.visit(e.at);return r&&(t+=" at "+r),t},"visit_position-keyword":function(e){return e.value},visit_position:function(e){return g.visit(e.value.x)+" "+g.visit(e.value.y)},"visit_%":function(e){return e.value+"%"},visit_em:function(e){return e.value+"em"},visit_px:function(e){return e.value+"px"},visit_literal:function(e){return g.visit_color(e.value,e)},visit_hex:function(e){return g.visit_color("#"+e.value,e)},visit_rgb:function(e){return g.visit_color("rgb("+e.value.join(", ")+")",e)},visit_rgba:function(e){return g.visit_color("rgba("+e.value.join(", ")+")",e)},visit_color:function(e,t){var r=e,n=g.visit(t.length);return n&&(r+=" "+n),r},visit_angular:function(e){return e.value+"deg"},visit_directional:function(e){return"to "+e.value},visit_array:function(e){var t="",r=e.length;return e.forEach((function(e,n){t+=g.visit(e),n<r-1&&(t+=", ")})),t},visit:function(e){if(!e)return"";if(e instanceof Array)return g.visit_array(e,"");if(e.type){var t=g["visit_"+e.type];if(t)return t(e);throw Error("Missing visitor visit_"+e.type)}throw Error("Invalid node.")}},function(e){return g.visit(e)}),(v=v||{}).parse=function(){var e={linearGradient:/^(\-(webkit|o|ms|moz)\-)?(linear\-gradient)/i,repeatingLinearGradient:/^(\-(webkit|o|ms|moz)\-)?(repeating\-linear\-gradient)/i,radialGradient:/^(\-(webkit|o|ms|moz)\-)?(radial\-gradient)/i,repeatingRadialGradient:/^(\-(webkit|o|ms|moz)\-)?(repeating\-radial\-gradient)/i,sideOrCorner:/^to (left (top|bottom)|right (top|bottom)|left|right|top|bottom)/i,extentKeywords:/^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,positionKeywords:/^(left|center|right|top|bottom)/i,pixelValue:/^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,percentageValue:/^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,emValue:/^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,angleValue:/^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,startCall:/^\(/,endCall:/^\)/,comma:/^,/,hexColor:/^\#([0-9a-fA-F]+)/,literalColor:/^([a-zA-Z]+)/,rgbColor:/^rgb/i,rgbaColor:/^rgba/i,number:/^(([0-9]*\.[0-9]+)|([0-9]+\.?))/},t="";function r(e){var r=new Error(t+": "+e);throw r.source=t,r}function n(){var e=h(i);return t.length>0&&r("Invalid input not EOF"),e}function i(){return o("linear-gradient",e.linearGradient,a)||o("repeating-linear-gradient",e.repeatingLinearGradient,a)||o("radial-gradient",e.radialGradient,l)||o("repeating-radial-gradient",e.repeatingRadialGradient,l)}function o(t,n,i){return s(n,(function(n){var o=i();return o&&(y(e.comma)||r("Missing comma before color stops")),{type:t,orientation:o,colorStops:h(m)}}))}function s(t,n){var i=y(t);if(i){y(e.startCall)||r("Missing (");var o=n(i);return y(e.endCall)||r("Missing )"),o}}function a(){return x("directional",e.sideOrCorner,1)||x("angular",e.angleValue,1)}function l(){var r,n,i=u();return i&&((r=[]).push(i),n=t,y(e.comma)&&((i=u())?r.push(i):t=n)),r}function u(){var e=function(){var e=x("shape",/^(circle)/i,0);return e&&(e.style=p()||c()),e}()||function(){var e=x("shape",/^(ellipse)/i,0);return e&&(e.style=v()||c()),e}();if(e)e.at=f();else{var t=c();if(t){e=t;var r=f();r&&(e.at=r)}else{var n=d();n&&(e={type:"default-radial",at:n})}}return e}function c(){return x("extent-keyword",e.extentKeywords,1)}function f(){if(x("position",/^at/,0)){var e=d();return e||r("Missing positioning value"),e}}function d(){var e={x:v(),y:v()};if(e.x||e.y)return{type:"position",value:e}}function h(t){var n=t(),i=[];if(n)for(i.push(n);y(e.comma);)(n=t())?i.push(n):r("One extra comma");return i}function m(){var t=x("hex",e.hexColor,1)||s(e.rgbaColor,(function(){return{type:"rgba",value:h(g)}}))||s(e.rgbColor,(function(){return{type:"rgb",value:h(g)}}))||x("literal",e.literalColor,0);return t||r("Expected color definition"),t.length=v(),t}function g(){return y(e.number)[1]}function v(){return x("%",e.percentageValue,1)||x("position-keyword",e.positionKeywords,1)||p()}function p(){return x("px",e.pixelValue,1)||x("em",e.emValue,1)}function x(e,t,r){var n=y(t);if(n)return{type:e,value:n[r]}}function y(e){var r,n;return(n=/^[\n\r\t\s]+/.exec(t))&&C(n[0].length),(r=e.exec(t))&&C(r[0].length),r}function C(e){t=t.substr(e)}return function(e){return t=e.toString(),n()}}();var p=v.parse;v.stringify;var x={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},y={red:0,orange:60,yellow:120,green:180,blue:240,purple:300};var C={name:"rgb",min:[0,0,0],max:[255,255,255],channel:["red","green","blue"],alias:["RGB"]},_={name:"hsl",min:[0,0,0],max:[360,100,100],channel:["hue","saturation","lightness"],alias:["HSL"],rgb:function(e){var t,r,n,i,o,s=e[0]/360,a=e[1]/100,l=e[2]/100;if(0===a)return[o=255*l,o,o];t=2*l-(r=l<.5?l*(1+a):l+a-l*a),i=[0,0,0];for(var u=0;u<3;u++)(n=s+1/3*-(u-1))<0?n++:n>1&&n--,o=6*n<1?t+6*(r-t)*n:2*n<1?r:3*n<2?t+(r-t)*(2/3-n)*6:t,i[u]=255*o;return i}};function b(e){Array.isArray(e)&&e.raw&&(e=String.raw(...arguments));var t,r=function(e){var t,r,n=[],i=1;if("string"==typeof e)if(x[e])n=x[e].slice(),r="rgb";else if("transparent"===e)i=0,r="rgb",n=[0,0,0];else if(/^#[A-Fa-f0-9]+$/.test(e)){var o=e.slice(1);i=1,(l=o.length)<=4?(n=[parseInt(o[0]+o[0],16),parseInt(o[1]+o[1],16),parseInt(o[2]+o[2],16)],4===l&&(i=parseInt(o[3]+o[3],16)/255)):(n=[parseInt(o[0]+o[1],16),parseInt(o[2]+o[3],16),parseInt(o[4]+o[5],16)],8===l&&(i=parseInt(o[6]+o[7],16)/255)),n[0]||(n[0]=0),n[1]||(n[1]=0),n[2]||(n[2]=0),r="rgb"}else if(t=/^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(e)){var s=t[1],a="rgb"===s;r=o=s.replace(/a$/,"");var l="cmyk"===o?4:"gray"===o?1:3;n=t[2].trim().split(/\s*[,\/]\s*|\s+/).map((function(e,t){if(/%$/.test(e))return t===l?parseFloat(e)/100:"rgb"===o?255*parseFloat(e)/100:parseFloat(e);if("h"===o[t]){if(/deg$/.test(e))return parseFloat(e);if(void 0!==y[e])return y[e]}return parseFloat(e)})),s===o&&n.push(1),i=a||void 0===n[l]?1:n[l],n=n.slice(0,l)}else e.length>10&&/[0-9](?:\s|\/)/.test(e)&&(n=e.match(/([0-9]+)/g).map((function(e){return parseFloat(e)})),r=e.match(/([a-z])/gi).join("").toLowerCase());else isNaN(e)?Array.isArray(e)||e.length?(n=[e[0],e[1],e[2]],r="rgb",i=4===e.length?e[3]:1):e instanceof Object&&(null!=e.r||null!=e.red||null!=e.R?(r="rgb",n=[e.r||e.red||e.R||0,e.g||e.green||e.G||0,e.b||e.blue||e.B||0]):(r="hsl",n=[e.h||e.hue||e.H||0,e.s||e.saturation||e.S||0,e.l||e.lightness||e.L||e.b||e.brightness]),i=e.a||e.alpha||e.opacity||1,null!=e.opacity&&(i/=100)):(r="rgb",n=[e>>>16,(65280&e)>>>8,255&e]);return{space:r,values:n,alpha:i}}(e);if(!r.space)return[];const n="h"===r.space[0]?_.min:C.min,i="h"===r.space[0]?_.max:C.max;return(t=Array(3))[0]=Math.min(Math.max(r.values[0],n[0]),i[0]),t[1]=Math.min(Math.max(r.values[1],n[1]),i[1]),t[2]=Math.min(Math.max(r.values[2],n[2]),i[2]),"h"===r.space[0]&&(t=_.rgb(t)),t.push(Math.min(Math.max(r.alpha,0),1)),t}function S(e){switch(typeof e){case"string":return function(e){const t=b(e);if(!t)throw new Error(`Unable to parse color "${e}" as RGBA.`);return[t[0]/255,t[1]/255,t[2]/255,t[3]]}(e);case"number":return t.utils.hex2rgb(e);default:return e}}function T(e){const t=p(function(e){let t=e.replace(/\s{2,}/gu," ");return t=t.replace(/;/g,""),t=t.replace(/ ,/g,","),t=t.replace(/\( /g,"("),t=t.replace(/ \)/g,")"),t.trim()}(e));if(0===t.length)throw new Error("Invalid CSS gradient.");if(1!==t.length)throw new Error("Unsupported CSS gradient (multiple gradients is not supported).");const r=t[0],n=function(e){const t={"linear-gradient":0,"radial-gradient":1};if(!(e in t))throw new Error(`Unsupported gradient type "${e}"`);return t[e]}(r.type),i=function(e){const t=function(e){const t=[];for(let r=0;r<e.length;r++){const n=e[r];let i=-1;"literal"===n.type&&n.length&&"type"in n.length&&"%"===n.length.type&&"value"in n.length&&(i=parseFloat(n.length.value)/100),t.push(i)}const r=e=>{for(let r=e;r<t.length;r++)if(-1!==t[r])return{indexDelta:r-e,offset:t[r]};return{indexDelta:t.length-1-e,offset:1}};let n=0;for(let e=0;e<t.length;e++){const i=t[e];if(-1!==i)n=i;else if(0===e)t[e]=0;else if(e+1===t.length)t[e]=1;else{const i=r(e),o=(i.offset-n)/(1+i.indexDelta);for(let r=0;r<=i.indexDelta;r++)t[e+r]=n+(r+1)*o;e+=i.indexDelta,n=t[e]}}return t.map(A)}(e),r=[];for(let n=0;n<e.length;n++){const i=F(e[n]);r.push({offset:t[n],color:i.slice(0,3),alpha:i[3]})}return r}(r.colorStops),o=function(e){if(void 0===e)return 0;if("type"in e&&"value"in e)switch(e.type){case"angular":return parseFloat(e.value);case"directional":return function(e){const t={left:270,top:0,bottom:180,right:90,"left top":315,"top left":315,"left bottom":225,"bottom left":225,"right top":45,"top right":45,"right bottom":135,"bottom right":135};if(!(e in t))throw new Error(`Unsupported directional value "${e}"`);return t[e]}(e.value)}return 0}(r.orientation);return{type:n,stops:i,angle:o}}function F(e){return S(function(e){switch(e.type){case"hex":return`#${e.value}`;case"literal":return e.value;default:return`${e.type}(${e.value.join(",")})`}}(e))}function A(e){return e.toString().length>6?parseFloat(e.toString().substring(0,6)):e}C.hsl=function(e){var t,r,n=e[0]/255,i=e[1]/255,o=e[2]/255,s=Math.min(n,i,o),a=Math.max(n,i,o),l=a-s;return a===s?t=0:n===a?t=(i-o)/l:i===a?t=2+(o-n)/l:o===a&&(t=4+(n-i)/l),(t=Math.min(60*t,360))<0&&(t+=360),r=(s+a)/2,[t,100*(a===s?0:r<=.5?l/(a+s):l/(2-a-s)),100*r]};var z=Object.defineProperty,w=Object.defineProperties,P=Object.getOwnPropertyDescriptors,M=Object.getOwnPropertySymbols,D=Object.prototype.hasOwnProperty,k=Object.prototype.propertyIsEnumerable,O=(e,t,r)=>t in e?z(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,R=(e,t)=>{for(var r in t||(t={}))D.call(t,r)&&O(e,r,t[r]);if(M)for(var r of M(t))k.call(t,r)&&O(e,r,t[r]);return e};const E=class extends t.Filter{constructor(e){var t,r;let n;if(n=e&&"css"in e?((e,t)=>w(e,P(t)))(R({},T(e.css||"")),{alpha:null!=(t=e.alpha)?t:E.defaults.alpha,maxColors:null!=(r=e.maxColors)?r:E.defaults.maxColors}):R(R({},E.defaults),e),!n.stops||n.stops.length<2)throw new Error("ColorGradientFilter requires at least 2 color stops.");super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n    vFilterCoord = vTextureCoord * inputSize.xy / outputFrame.zw;\n}\n","const float PI = 3.1415926538;\nconst float PI_2 = PI*2.;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\nuniform sampler2D uSampler;\n\nconst int TYPE_LINEAR = 0;\nconst int TYPE_RADIAL = 1;\nconst int TYPE_CONIC = 2;\nconst int MAX_STOPS = 32;\n\nuniform int uNumStops;\nuniform float uAlphas[3*MAX_STOPS];\nuniform vec3 uColors[MAX_STOPS];\nuniform float uOffsets[MAX_STOPS];\nuniform int uType;\nuniform float uAngle;\nuniform float uAlpha;\nuniform int uMaxColors;\nuniform bool uReplace;\n\nstruct ColorStop {\n    float offset;\n    vec3 color;\n    float alpha;\n};\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle), -sin(angle),\n    sin(angle), cos(angle));\n}\n\nfloat projectLinearPosition(vec2 pos, float angle){\n    vec2 center = vec2(0.5);\n    vec2 result = pos - center;\n    result = rotate2d(angle) * result;\n    result = result + center;\n    return clamp(result.x, 0., 1.);\n}\n\nfloat projectRadialPosition(vec2 pos) {\n    float r = distance(vFilterCoord, vec2(0.5));\n    return clamp(2.*r, 0., 1.);\n}\n\nfloat projectAnglePosition(vec2 pos, float angle) {\n    vec2 center = pos - vec2(0.5);\n    float polarAngle=atan(-center.y, center.x);\n    return mod(polarAngle + angle, PI_2) / PI_2;\n}\n\nfloat projectPosition(vec2 pos, int type, float angle) {\n    if (type == TYPE_LINEAR) {\n        return projectLinearPosition(pos, angle);\n    } else if (type == TYPE_RADIAL) {\n        return projectRadialPosition(pos);\n    } else if (type == TYPE_CONIC) {\n        return projectAnglePosition(pos, angle);\n    }\n\n    return pos.y;\n}\n\nvoid main(void) {\n    // current/original color\n    vec4 currentColor = texture2D(uSampler, vTextureCoord);\n\n    // skip calculations if gradient alpha is 0\n    if (0.0 == uAlpha) {\n        gl_FragColor = currentColor;\n        return;\n    }\n\n    // project position\n    float y = projectPosition(vFilterCoord, uType, radians(uAngle));\n\n    // check gradient bounds\n    float offsetMin = uOffsets[0];\n    float offsetMax = 0.0;\n\n    for (int i = 0; i < MAX_STOPS; i++) {\n        if (i == uNumStops-1){ // last index\n            offsetMax = uOffsets[i];\n        }\n    }\n\n    if (y  < offsetMin || y > offsetMax) {\n        gl_FragColor = currentColor;\n        return;\n    }\n\n    // limit colors\n    if (uMaxColors > 0) {\n        float stepSize = 1./float(uMaxColors);\n        float stepNumber = float(floor(y/stepSize));\n        y = stepSize * (stepNumber + 0.5);// offset by 0.5 to use color from middle of segment\n    }\n\n    // find color stops\n    ColorStop from;\n    ColorStop to;\n\n    for (int i = 0; i < MAX_STOPS; i++) {\n        if (y >= uOffsets[i]) {\n            from = ColorStop(uOffsets[i], uColors[i], uAlphas[i]);\n            to = ColorStop(uOffsets[i+1], uColors[i+1], uAlphas[i+1]);\n        }\n\n        if (i == uNumStops-1){ // last index\n            break;\n        }\n    }\n\n    // mix colors from stops\n    vec4 colorFrom = vec4(from.color * from.alpha, from.alpha);\n    vec4 colorTo = vec4(to.color * to.alpha, to.alpha);\n\n    float segmentHeight = to.offset - from.offset;\n    float relativePos = y - from.offset;// position from 0 to [segmentHeight]\n    float relativePercent = relativePos / segmentHeight;// position in percent between [from.offset] and [to.offset].\n\n    float gradientAlpha = uAlpha * currentColor.a;\n    vec4 gradientColor = mix(colorFrom, colorTo, relativePercent) * gradientAlpha;\n\n    if (uReplace == false) {\n        // mix resulting color with current color\n        gl_FragColor = gradientColor + currentColor*(1.-gradientColor.a);\n    } else {\n        // replace with gradient color\n        gl_FragColor = gradientColor;\n    }\n}\n"),this._stops=[],this.autoFit=!1,Object.assign(this,n)}get stops(){return this._stops}set stops(e){const t=function(e){return[...e].sort(((e,t)=>e.offset-t.offset))}(e),r=new Float32Array(3*t.length);for(let e=0;e<t.length;e++){const n=S(t[e].color),i=3*e;r[i+0]=n[0],r[i+1]=n[1],r[i+2]=n[2]}this.uniforms.uColors=r,this.uniforms.uOffsets=t.map((e=>e.offset)),this.uniforms.uAlphas=t.map((e=>e.alpha)),this.uniforms.uNumStops=t.length,this._stops=t}set type(e){this.uniforms.uType=e}get type(){return this.uniforms.uType}set angle(e){this.uniforms.uAngle=e-90}get angle(){return this.uniforms.uAngle+90}set alpha(e){this.uniforms.uAlpha=e}get alpha(){return this.uniforms.uAlpha}set maxColors(e){this.uniforms.uMaxColors=e}get maxColors(){return this.uniforms.uMaxColors}set replace(e){this.uniforms.uReplace=e}get replace(){return this.uniforms.uReplace}};let j=E;j.LINEAR=0,j.RADIAL=1,j.CONIC=2,j.defaults={type:E.LINEAR,stops:[{offset:0,color:16711680,alpha:1},{offset:1,color:255,alpha:1}],alpha:1,angle:90,maxColors:0,replace:!1};class I extends t.Filter{constructor(e,t=!1,r=1){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform sampler2D colorMap;\nuniform float _mix;\nuniform float _size;\nuniform float _sliceSize;\nuniform float _slicePixelSize;\nuniform float _sliceInnerSize;\nvoid main() {\n    vec4 color = texture2D(uSampler, vTextureCoord.xy);\n\n    vec4 adjusted;\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n        float innerWidth = _size - 1.0;\n        float zSlice0 = min(floor(color.b * innerWidth), innerWidth);\n        float zSlice1 = min(zSlice0 + 1.0, innerWidth);\n        float xOffset = _slicePixelSize * 0.5 + color.r * _sliceInnerSize;\n        float s0 = xOffset + (zSlice0 * _sliceSize);\n        float s1 = xOffset + (zSlice1 * _sliceSize);\n        float yOffset = _sliceSize * 0.5 + color.g * (1.0 - _sliceSize);\n        vec4 slice0Color = texture2D(colorMap, vec2(s0,yOffset));\n        vec4 slice1Color = texture2D(colorMap, vec2(s1,yOffset));\n        float zOffset = fract(color.b * innerWidth);\n        adjusted = mix(slice0Color, slice1Color, zOffset);\n\n        color.rgb *= color.a;\n    }\n    gl_FragColor = vec4(mix(color, adjusted, _mix).rgb, color.a);\n\n}"),this.mix=1,this._size=0,this._sliceSize=0,this._slicePixelSize=0,this._sliceInnerSize=0,this._nearest=!1,this._scaleMode=null,this._colorMap=null,this._scaleMode=null,this.nearest=t,this.mix=r,this.colorMap=e}apply(e,t,r,n){this.uniforms._mix=this.mix,e.applyFilter(this,t,r,n)}get colorSize(){return this._size}get colorMap(){return this._colorMap}set colorMap(e){!e||(e instanceof t.Texture||(e=t.Texture.from(e)),null!=e&&e.baseTexture&&(e.baseTexture.scaleMode=this._scaleMode,e.baseTexture.mipmap=t.MIPMAP_MODES.OFF,this._size=e.height,this._sliceSize=1/this._size,this._slicePixelSize=this._sliceSize/this._size,this._sliceInnerSize=this._slicePixelSize*(this._size-1),this.uniforms._size=this._size,this.uniforms._sliceSize=this._sliceSize,this.uniforms._slicePixelSize=this._slicePixelSize,this.uniforms._sliceInnerSize=this._sliceInnerSize,this.uniforms.colorMap=e),this._colorMap=e)}get nearest(){return this._nearest}set nearest(e){this._nearest=e,this._scaleMode=e?t.SCALE_MODES.NEAREST:t.SCALE_MODES.LINEAR;const r=this._colorMap;r&&r.baseTexture&&(r.baseTexture._glTextures={},r.baseTexture.scaleMode=this._scaleMode,r.baseTexture.mipmap=t.MIPMAP_MODES.OFF,r._updateID++,r.baseTexture.emit("update",r.baseTexture))}updateColorMap(){const e=this._colorMap;e&&e.baseTexture&&(e._updateID++,e.baseTexture.emit("update",e.baseTexture),this.colorMap=e)}destroy(e=!1){this._colorMap&&this._colorMap.destroy(e),super.destroy()}}class L extends t.Filter{constructor(e=0,t=1){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec3 color;\nuniform float alpha;\n\nvoid main(void) {\n    vec4 currentColor = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = vec4(mix(currentColor.rgb, color.rgb, currentColor.a * alpha), currentColor.a);\n}\n"),this._color=0,this._alpha=1,this.uniforms.color=new Float32Array(3),this.color=e,this.alpha=t}set color(e){const r=this.uniforms.color;"number"==typeof e?(t.utils.hex2rgb(e,r),this._color=e):(r[0]=e[0],r[1]=e[1],r[2]=e[2],this._color=t.utils.rgb2hex(r))}get color(){return this._color}set alpha(e){this.uniforms.alpha=e,this._alpha=e}get alpha(){return this._alpha}}class V extends t.Filter{constructor(e=16711680,t=0,r=.4){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec3 originalColor;\nuniform vec3 newColor;\nuniform float epsilon;\nvoid main(void) {\n    vec4 currentColor = texture2D(uSampler, vTextureCoord);\n    vec3 colorDiff = originalColor - (currentColor.rgb / max(currentColor.a, 0.0000000001));\n    float colorDistance = length(colorDiff);\n    float doReplace = step(colorDistance, epsilon);\n    gl_FragColor = vec4(mix(currentColor.rgb, (newColor + colorDiff) * currentColor.a, doReplace), currentColor.a);\n}\n"),this._originalColor=16711680,this._newColor=0,this.uniforms.originalColor=new Float32Array(3),this.uniforms.newColor=new Float32Array(3),this.originalColor=e,this.newColor=t,this.epsilon=r}set originalColor(e){const r=this.uniforms.originalColor;"number"==typeof e?(t.utils.hex2rgb(e,r),this._originalColor=e):(r[0]=e[0],r[1]=e[1],r[2]=e[2],this._originalColor=t.utils.rgb2hex(r))}get originalColor(){return this._originalColor}set newColor(e){const r=this.uniforms.newColor;"number"==typeof e?(t.utils.hex2rgb(e,r),this._newColor=e):(r[0]=e[0],r[1]=e[1],r[2]=e[2],this._newColor=t.utils.rgb2hex(r))}get newColor(){return this._newColor}set epsilon(e){this.uniforms.epsilon=e}get epsilon(){return this.uniforms.epsilon}}class N extends t.Filter{constructor(e,t=200,r=200){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","precision mediump float;\n\nvarying mediump vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec2 texelSize;\nuniform float matrix[9];\n\nvoid main(void)\n{\n   vec4 c11 = texture2D(uSampler, vTextureCoord - texelSize); // top left\n   vec4 c12 = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y - texelSize.y)); // top center\n   vec4 c13 = texture2D(uSampler, vec2(vTextureCoord.x + texelSize.x, vTextureCoord.y - texelSize.y)); // top right\n\n   vec4 c21 = texture2D(uSampler, vec2(vTextureCoord.x - texelSize.x, vTextureCoord.y)); // mid left\n   vec4 c22 = texture2D(uSampler, vTextureCoord); // mid center\n   vec4 c23 = texture2D(uSampler, vec2(vTextureCoord.x + texelSize.x, vTextureCoord.y)); // mid right\n\n   vec4 c31 = texture2D(uSampler, vec2(vTextureCoord.x - texelSize.x, vTextureCoord.y + texelSize.y)); // bottom left\n   vec4 c32 = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y + texelSize.y)); // bottom center\n   vec4 c33 = texture2D(uSampler, vTextureCoord + texelSize); // bottom right\n\n   gl_FragColor =\n       c11 * matrix[0] + c12 * matrix[1] + c13 * matrix[2] +\n       c21 * matrix[3] + c22 * matrix[4] + c23 * matrix[5] +\n       c31 * matrix[6] + c32 * matrix[7] + c33 * matrix[8];\n\n   gl_FragColor.a = c22.a;\n}\n"),this.uniforms.texelSize=new Float32Array(2),this.uniforms.matrix=new Float32Array(9),void 0!==e&&(this.matrix=e),this.width=t,this.height=r}get matrix(){return this.uniforms.matrix}set matrix(e){e.forEach(((e,t)=>{this.uniforms.matrix[t]=e}))}get width(){return 1/this.uniforms.texelSize[0]}set width(e){this.uniforms.texelSize[0]=1/e}get height(){return 1/this.uniforms.texelSize[1]}set height(e){this.uniforms.texelSize[1]=1/e}}class G extends t.Filter{constructor(){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    float lum = length(texture2D(uSampler, vTextureCoord.xy).rgb);\n\n    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n\n    if (lum < 1.00)\n    {\n        if (mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.75)\n    {\n        if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.50)\n    {\n        if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n\n    if (lum < 0.3)\n    {\n        if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0)\n        {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    }\n}\n")}}const B=class extends t.Filter{constructor(e){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec2 dimensions;\n\nconst float SQRT_2 = 1.414213;\n\nconst float light = 1.0;\n\nuniform float curvature;\nuniform float lineWidth;\nuniform float lineContrast;\nuniform bool verticalLine;\nuniform float noise;\nuniform float noiseSize;\n\nuniform float vignetting;\nuniform float vignettingAlpha;\nuniform float vignettingBlur;\n\nuniform float seed;\nuniform float time;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main(void)\n{\n    vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\n    vec2 dir = vec2(vTextureCoord.xy * filterArea.xy / dimensions - vec2(0.5, 0.5));\n    \n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n    vec3 rgb = gl_FragColor.rgb;\n\n    if (noise > 0.0 && noiseSize > 0.0)\n    {\n        pixelCoord.x = floor(pixelCoord.x / noiseSize);\n        pixelCoord.y = floor(pixelCoord.y / noiseSize);\n        float _noise = rand(pixelCoord * noiseSize * seed) - 0.5;\n        rgb += _noise * noise;\n    }\n\n    if (lineWidth > 0.0)\n    {\n        float _c = curvature > 0. ? curvature : 1.;\n        float k = curvature > 0. ?(length(dir * dir) * 0.25 * _c * _c + 0.935 * _c) : 1.;\n        vec2 uv = dir * k;\n\n        float v = (verticalLine ? uv.x * dimensions.x : uv.y * dimensions.y) * min(1.0, 2.0 / lineWidth ) / _c;\n        float j = 1. + cos(v * 1.2 - time) * 0.5 * lineContrast;\n        rgb *= j;\n        float segment = verticalLine ? mod((dir.x + .5) * dimensions.x, 4.) : mod((dir.y + .5) * dimensions.y, 4.);\n        rgb *= 0.99 + ceil(segment) * 0.015;\n    }\n\n    if (vignetting > 0.0)\n    {\n        float outter = SQRT_2 - vignetting * SQRT_2;\n        float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + vignettingBlur * SQRT_2), 0.0, 1.0);\n        rgb *= darker + (1.0 - darker) * (1.0 - vignettingAlpha);\n    }\n\n    gl_FragColor.rgb = rgb;\n}\n"),this.time=0,this.seed=0,this.uniforms.dimensions=new Float32Array(2),Object.assign(this,B.defaults,e)}apply(e,t,r,n){const{width:i,height:o}=t.filterFrame;this.uniforms.dimensions[0]=i,this.uniforms.dimensions[1]=o,this.uniforms.seed=this.seed,this.uniforms.time=this.time,e.applyFilter(this,t,r,n)}set curvature(e){this.uniforms.curvature=e}get curvature(){return this.uniforms.curvature}set lineWidth(e){this.uniforms.lineWidth=e}get lineWidth(){return this.uniforms.lineWidth}set lineContrast(e){this.uniforms.lineContrast=e}get lineContrast(){return this.uniforms.lineContrast}set verticalLine(e){this.uniforms.verticalLine=e}get verticalLine(){return this.uniforms.verticalLine}set noise(e){this.uniforms.noise=e}get noise(){return this.uniforms.noise}set noiseSize(e){this.uniforms.noiseSize=e}get noiseSize(){return this.uniforms.noiseSize}set vignetting(e){this.uniforms.vignetting=e}get vignetting(){return this.uniforms.vignetting}set vignettingAlpha(e){this.uniforms.vignettingAlpha=e}get vignettingAlpha(){return this.uniforms.vignettingAlpha}set vignettingBlur(e){this.uniforms.vignettingBlur=e}get vignettingBlur(){return this.uniforms.vignettingBlur}};let X=B;X.defaults={curvature:1,lineWidth:1,lineContrast:.25,verticalLine:!1,noise:0,noiseSize:1,seed:0,vignetting:.3,vignettingAlpha:1,vignettingBlur:.3,time:0};class q extends t.Filter{constructor(e=1,t=5,r=!0){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","precision mediump float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform vec4 filterArea;\nuniform sampler2D uSampler;\n\nuniform float angle;\nuniform float scale;\nuniform bool grayscale;\n\nfloat pattern()\n{\n   float s = sin(angle), c = cos(angle);\n   vec2 tex = vTextureCoord * filterArea.xy;\n   vec2 point = vec2(\n       c * tex.x - s * tex.y,\n       s * tex.x + c * tex.y\n   ) * scale;\n   return (sin(point.x) * sin(point.y)) * 4.0;\n}\n\nvoid main()\n{\n   vec4 color = texture2D(uSampler, vTextureCoord);\n   vec3 colorRGB = vec3(color);\n\n   if (grayscale)\n   {\n       colorRGB = vec3(color.r + color.g + color.b) / 3.0;\n   }\n\n   gl_FragColor = vec4(colorRGB * 10.0 - 5.0 + pattern(), color.a);\n}\n"),this.scale=e,this.angle=t,this.grayscale=r}get scale(){return this.uniforms.scale}set scale(e){this.uniforms.scale=e}get angle(){return this.uniforms.angle}set angle(e){this.uniforms.angle=e}get grayscale(){return this.uniforms.grayscale}set grayscale(e){this.uniforms.grayscale=e}}var K=Object.defineProperty,W=Object.getOwnPropertySymbols,Y=Object.prototype.hasOwnProperty,$=Object.prototype.propertyIsEnumerable,Z=(e,t,r)=>t in e?K(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,U=(e,t)=>{for(var r in t||(t={}))Y.call(t,r)&&Z(e,r,t[r]);if(W)for(var r of W(t))$.call(t,r)&&Z(e,r,t[r]);return e};const H=class extends t.Filter{constructor(e){super(),this.angle=45,this._distance=5,this._resolution=t.settings.FILTER_RESOLUTION;const r=e?U(U({},H.defaults),e):H.defaults,{kernels:n,blur:i,quality:s,pixelSize:a,resolution:l}=r;this._offset=new t.ObservablePoint(this._updatePadding,this),this._tintFilter=new t.Filter("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float alpha;\nuniform vec3 color;\n\nuniform vec2 shift;\nuniform vec4 inputSize;\n\nvoid main(void){\n    vec4 sample = texture2D(uSampler, vTextureCoord - shift * inputSize.zw);\n\n    // Premultiply alpha\n    sample.rgb = color.rgb * sample.a;\n\n    // alpha user alpha\n    sample *= alpha;\n\n    gl_FragColor = sample;\n}"),this._tintFilter.uniforms.color=new Float32Array(4),this._tintFilter.uniforms.shift=this._offset,this._tintFilter.resolution=l,this._blurFilter=n?new o(n):new o(i,s),this.pixelSize=a,this.resolution=l;const{shadowOnly:u,rotation:c,distance:f,offset:d,alpha:h,color:m}=r;this.shadowOnly=u,void 0!==c&&void 0!==f?(this.rotation=c,this.distance=f):this.offset=d,this.alpha=h,this.color=m}apply(e,t,r,n){const i=e.getFilterTexture();this._tintFilter.apply(e,t,i,1),this._blurFilter.apply(e,i,r,n),!0!==this.shadowOnly&&e.applyFilter(this,t,r,0),e.returnFilterTexture(i)}_updatePadding(){const e=Math.max(Math.abs(this._offset.x),Math.abs(this._offset.y));this.padding=e+2*this.blur}_updateShift(){this._tintFilter.uniforms.shift.set(this.distance*Math.cos(this.angle),this.distance*Math.sin(this.angle))}set offset(e){this._offset.copyFrom(e),this._updatePadding()}get offset(){return this._offset}get resolution(){return this._resolution}set resolution(e){this._resolution=e,this._tintFilter&&(this._tintFilter.resolution=e),this._blurFilter&&(this._blurFilter.resolution=e)}get distance(){return this._distance}set distance(e){t.utils.deprecation("5.3.0","DropShadowFilter distance is deprecated, use offset"),this._distance=e,this._updatePadding(),this._updateShift()}get rotation(){return this.angle/t.DEG_TO_RAD}set rotation(e){t.utils.deprecation("5.3.0","DropShadowFilter rotation is deprecated, use offset"),this.angle=e*t.DEG_TO_RAD,this._updateShift()}get alpha(){return this._tintFilter.uniforms.alpha}set alpha(e){this._tintFilter.uniforms.alpha=e}get color(){return t.utils.rgb2hex(this._tintFilter.uniforms.color)}set color(e){t.utils.hex2rgb(e,this._tintFilter.uniforms.color)}get kernels(){return this._blurFilter.kernels}set kernels(e){this._blurFilter.kernels=e}get blur(){return this._blurFilter.blur}set blur(e){this._blurFilter.blur=e,this._updatePadding()}get quality(){return this._blurFilter.quality}set quality(e){this._blurFilter.quality=e}get pixelSize(){return this._blurFilter.pixelSize}set pixelSize(e){this._blurFilter.pixelSize=e}};let Q=H;Q.defaults={offset:{x:4,y:4},color:0,alpha:.5,shadowOnly:!1,kernels:null,blur:2,quality:3,pixelSize:1,resolution:t.settings.FILTER_RESOLUTION};class J extends t.Filter{constructor(e=5){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float strength;\nuniform vec4 filterArea;\n\n\nvoid main(void)\n{\n\tvec2 onePixel = vec2(1.0 / filterArea);\n\n\tvec4 color;\n\n\tcolor.rgb = vec3(0.5);\n\n\tcolor -= texture2D(uSampler, vTextureCoord - onePixel) * strength;\n\tcolor += texture2D(uSampler, vTextureCoord + onePixel) * strength;\n\n\tcolor.rgb = vec3((color.r + color.g + color.b) / 3.0);\n\n\tfloat alpha = texture2D(uSampler, vTextureCoord).a;\n\n\tgl_FragColor = vec4(color.rgb * alpha, alpha);\n}\n"),this.strength=e}get strength(){return this.uniforms.strength}set strength(e){this.uniforms.strength=e}}const ee=class extends t.Filter{constructor(e){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","// precision highp float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform vec2 dimensions;\nuniform float aspect;\n\nuniform sampler2D displacementMap;\nuniform float offset;\nuniform float sinDir;\nuniform float cosDir;\nuniform int fillMode;\n\nuniform float seed;\nuniform vec2 red;\nuniform vec2 green;\nuniform vec2 blue;\n\nconst int TRANSPARENT = 0;\nconst int ORIGINAL = 1;\nconst int LOOP = 2;\nconst int CLAMP = 3;\nconst int MIRROR = 4;\n\nvoid main(void)\n{\n    vec2 coord = (vTextureCoord * filterArea.xy) / dimensions;\n\n    if (coord.x > 1.0 || coord.y > 1.0) {\n        return;\n    }\n\n    float cx = coord.x - 0.5;\n    float cy = (coord.y - 0.5) * aspect;\n    float ny = (-sinDir * cx + cosDir * cy) / aspect + 0.5;\n\n    // displacementMap: repeat\n    // ny = ny > 1.0 ? ny - 1.0 : (ny < 0.0 ? 1.0 + ny : ny);\n\n    // displacementMap: mirror\n    ny = ny > 1.0 ? 2.0 - ny : (ny < 0.0 ? -ny : ny);\n\n    vec4 dc = texture2D(displacementMap, vec2(0.5, ny));\n\n    float displacement = (dc.r - dc.g) * (offset / filterArea.x);\n\n    coord = vTextureCoord + vec2(cosDir * displacement, sinDir * displacement * aspect);\n\n    if (fillMode == CLAMP) {\n        coord = clamp(coord, filterClamp.xy, filterClamp.zw);\n    } else {\n        if( coord.x > filterClamp.z ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.x -= filterClamp.z;\n            } else if (fillMode == MIRROR) {\n                coord.x = filterClamp.z * 2.0 - coord.x;\n            }\n        } else if( coord.x < filterClamp.x ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.x += filterClamp.z;\n            } else if (fillMode == MIRROR) {\n                coord.x *= -filterClamp.z;\n            }\n        }\n\n        if( coord.y > filterClamp.w ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.y -= filterClamp.w;\n            } else if (fillMode == MIRROR) {\n                coord.y = filterClamp.w * 2.0 - coord.y;\n            }\n        } else if( coord.y < filterClamp.y ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.y += filterClamp.w;\n            } else if (fillMode == MIRROR) {\n                coord.y *= -filterClamp.w;\n            }\n        }\n    }\n\n    gl_FragColor.r = texture2D(uSampler, coord + red * (1.0 - seed * 0.4) / filterArea.xy).r;\n    gl_FragColor.g = texture2D(uSampler, coord + green * (1.0 - seed * 0.3) / filterArea.xy).g;\n    gl_FragColor.b = texture2D(uSampler, coord + blue * (1.0 - seed * 0.2) / filterArea.xy).b;\n    gl_FragColor.a = texture2D(uSampler, coord).a;\n}\n"),this.offset=100,this.fillMode=ee.TRANSPARENT,this.average=!1,this.seed=0,this.minSize=8,this.sampleSize=512,this._slices=0,this._offsets=new Float32Array(1),this._sizes=new Float32Array(1),this._direction=-1,this.uniforms.dimensions=new Float32Array(2),this._canvas=document.createElement("canvas"),this._canvas.width=4,this._canvas.height=this.sampleSize,this.texture=t.Texture.from(this._canvas,{scaleMode:t.SCALE_MODES.NEAREST}),Object.assign(this,ee.defaults,e)}apply(e,t,r,n){const{width:i,height:o}=t.filterFrame;this.uniforms.dimensions[0]=i,this.uniforms.dimensions[1]=o,this.uniforms.aspect=o/i,this.uniforms.seed=this.seed,this.uniforms.offset=this.offset,this.uniforms.fillMode=this.fillMode,e.applyFilter(this,t,r,n)}_randomizeSizes(){const e=this._sizes,t=this._slices-1,r=this.sampleSize,n=Math.min(this.minSize/r,.9/this._slices);if(this.average){const r=this._slices;let i=1;for(let o=0;o<t;o++){const t=i/(r-o),s=Math.max(t*(1-.6*Math.random()),n);e[o]=s,i-=s}e[t]=i}else{let r=1;const i=Math.sqrt(1/this._slices);for(let o=0;o<t;o++){const t=Math.max(i*r*Math.random(),n);e[o]=t,r-=t}e[t]=r}this.shuffle()}shuffle(){const e=this._sizes;for(let t=this._slices-1;t>0;t--){const r=Math.random()*t>>0,n=e[t];e[t]=e[r],e[r]=n}}_randomizeOffsets(){for(let e=0;e<this._slices;e++)this._offsets[e]=Math.random()*(Math.random()<.5?-1:1)}refresh(){this._randomizeSizes(),this._randomizeOffsets(),this.redraw()}redraw(){const e=this.sampleSize,t=this.texture,r=this._canvas.getContext("2d");r.clearRect(0,0,8,e);let n,i=0;for(let t=0;t<this._slices;t++){n=Math.floor(256*this._offsets[t]);const o=this._sizes[t]*e,s=n>0?n:0,a=n<0?-n:0;r.fillStyle=`rgba(${s}, ${a}, 0, 1)`,r.fillRect(0,i>>0,e,o+1>>0),i+=o}t.baseTexture.update(),this.uniforms.displacementMap=t}set sizes(e){const t=Math.min(this._slices,e.length);for(let r=0;r<t;r++)this._sizes[r]=e[r]}get sizes(){return this._sizes}set offsets(e){const t=Math.min(this._slices,e.length);for(let r=0;r<t;r++)this._offsets[r]=e[r]}get offsets(){return this._offsets}get slices(){return this._slices}set slices(e){this._slices!==e&&(this._slices=e,this.uniforms.slices=e,this._sizes=this.uniforms.slicesWidth=new Float32Array(e),this._offsets=this.uniforms.slicesOffset=new Float32Array(e),this.refresh())}get direction(){return this._direction}set direction(e){if(this._direction===e)return;this._direction=e;const r=e*t.DEG_TO_RAD;this.uniforms.sinDir=Math.sin(r),this.uniforms.cosDir=Math.cos(r)}get red(){return this.uniforms.red}set red(e){this.uniforms.red=e}get green(){return this.uniforms.green}set green(e){this.uniforms.green=e}get blue(){return this.uniforms.blue}set blue(e){this.uniforms.blue=e}destroy(){var e;null==(e=this.texture)||e.destroy(!0),this.texture=this._canvas=this.red=this.green=this.blue=this._sizes=this._offsets=null}};let te=ee;te.defaults={slices:5,offset:100,direction:0,fillMode:0,average:!1,seed:0,red:[0,0],green:[0,0],blue:[0,0],minSize:8,sampleSize:512},te.TRANSPARENT=0,te.ORIGINAL=1,te.LOOP=2,te.CLAMP=3,te.MIRROR=4;var re="varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nuniform float outerStrength;\nuniform float innerStrength;\n\nuniform vec4 glowColor;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform bool knockout;\nuniform float alpha;\n\nconst float PI = 3.14159265358979323846264;\n\nconst float DIST = __DIST__;\nconst float ANGLE_STEP_SIZE = min(__ANGLE_STEP_SIZE__, PI * 2.0);\nconst float ANGLE_STEP_NUM = ceil(PI * 2.0 / ANGLE_STEP_SIZE);\n\nconst float MAX_TOTAL_ALPHA = ANGLE_STEP_NUM * DIST * (DIST + 1.0) / 2.0;\n\nvoid main(void) {\n    vec2 px = vec2(1.0 / filterArea.x, 1.0 / filterArea.y);\n\n    float totalAlpha = 0.0;\n\n    vec2 direction;\n    vec2 displaced;\n    vec4 curColor;\n\n    for (float angle = 0.0; angle < PI * 2.0; angle += ANGLE_STEP_SIZE) {\n       direction = vec2(cos(angle), sin(angle)) * px;\n\n       for (float curDistance = 0.0; curDistance < DIST; curDistance++) {\n           displaced = clamp(vTextureCoord + direction * \n                   (curDistance + 1.0), filterClamp.xy, filterClamp.zw);\n\n           curColor = texture2D(uSampler, displaced);\n\n           totalAlpha += (DIST - curDistance) * curColor.a;\n       }\n    }\n    \n    curColor = texture2D(uSampler, vTextureCoord);\n\n    float alphaRatio = (totalAlpha / MAX_TOTAL_ALPHA);\n\n    float innerGlowAlpha = (1.0 - alphaRatio) * innerStrength * curColor.a;\n    float innerGlowStrength = min(1.0, innerGlowAlpha);\n    \n    vec4 innerColor = mix(curColor, glowColor, innerGlowStrength);\n\n    float outerGlowAlpha = alphaRatio * outerStrength * (1. - curColor.a);\n    float outerGlowStrength = min(1.0 - innerColor.a, outerGlowAlpha);\n\n    if (knockout) {\n      float resultAlpha = (outerGlowAlpha + innerGlowAlpha) * alpha;\n      gl_FragColor = vec4(glowColor.rgb * resultAlpha, resultAlpha);\n    }\n    else {\n      vec4 outerGlowColor = outerGlowStrength * glowColor.rgba * alpha;\n      gl_FragColor = innerColor + outerGlowColor;\n    }\n}\n";const ne=class extends t.Filter{constructor(e){const t=Object.assign({},ne.defaults,e),{outerStrength:r,innerStrength:n,color:i,knockout:o,quality:s,alpha:a}=t,l=Math.round(t.distance);super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}",re.replace(/__ANGLE_STEP_SIZE__/gi,`${(1/s/l).toFixed(7)}`).replace(/__DIST__/gi,`${l.toFixed(0)}.0`)),this.uniforms.glowColor=new Float32Array([0,0,0,1]),this.uniforms.alpha=1,Object.assign(this,{color:i,outerStrength:r,innerStrength:n,padding:l,knockout:o,alpha:a})}get color(){return t.utils.rgb2hex(this.uniforms.glowColor)}set color(e){t.utils.hex2rgb(e,this.uniforms.glowColor)}get outerStrength(){return this.uniforms.outerStrength}set outerStrength(e){this.uniforms.outerStrength=e}get innerStrength(){return this.uniforms.innerStrength}set innerStrength(e){this.uniforms.innerStrength=e}get knockout(){return this.uniforms.knockout}set knockout(e){this.uniforms.knockout=e}get alpha(){return this.uniforms.alpha}set alpha(e){this.uniforms.alpha=e}};let ie=ne;ie.defaults={distance:10,outerStrength:4,innerStrength:0,color:16777215,quality:.1,knockout:!1,alpha:1};var oe="varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec2 dimensions;\n\nuniform vec2 light;\nuniform bool parallel;\nuniform float aspect;\n\nuniform float gain;\nuniform float lacunarity;\nuniform float time;\nuniform float alpha;\n\n${perlin}\n\nvoid main(void) {\n    vec2 coord = vTextureCoord * filterArea.xy / dimensions.xy;\n\n    float d;\n\n    if (parallel) {\n        float _cos = light.x;\n        float _sin = light.y;\n        d = (_cos * coord.x) + (_sin * coord.y * aspect);\n    } else {\n        float dx = coord.x - light.x / dimensions.x;\n        float dy = (coord.y - light.y / dimensions.y) * aspect;\n        float dis = sqrt(dx * dx + dy * dy) + 0.00001;\n        d = dy / dis;\n    }\n\n    vec3 dir = vec3(d, d, 0.0);\n\n    float noise = turb(dir + vec3(time, 0.0, 62.1 + time) * 0.05, vec3(480.0, 320.0, 480.0), lacunarity, gain);\n    noise = mix(noise, 0.0, 0.3);\n    //fade vertically.\n    vec4 mist = vec4(noise, noise, noise, 1.0) * (1.0 - coord.y);\n    mist.a = 1.0;\n    // apply user alpha\n    mist *= alpha;\n\n    gl_FragColor = texture2D(uSampler, vTextureCoord) + mist;\n\n}\n";const se=class extends t.Filter{constructor(e){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}",oe.replace("${perlin}","vec3 mod289(vec3 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289(vec4 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 permute(vec4 x)\n{\n    return mod289(((x * 34.0) + 1.0) * x);\n}\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\nvec3 fade(vec3 t)\n{\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n{\n    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n    vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\n    vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\n    vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\n    vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\n    vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\n    vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\n    vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\n    vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}\nfloat turb(vec3 P, vec3 rep, float lacunarity, float gain)\n{\n    float sum = 0.0;\n    float sc = 1.0;\n    float totalgain = 1.0;\n    for (float i = 0.0; i < 6.0; i++)\n    {\n        sum += totalgain * pnoise(P * sc, rep);\n        sc *= lacunarity;\n        totalgain *= gain;\n    }\n    return abs(sum);\n}\n")),this.parallel=!0,this.time=0,this._angle=0,this.uniforms.dimensions=new Float32Array(2);const r=Object.assign(se.defaults,e);this._angleLight=new t.Point,this.angle=r.angle,this.gain=r.gain,this.lacunarity=r.lacunarity,this.alpha=r.alpha,this.parallel=r.parallel,this.center=r.center,this.time=r.time}apply(e,t,r,n){const{width:i,height:o}=t.filterFrame;this.uniforms.light=this.parallel?this._angleLight:this.center,this.uniforms.parallel=this.parallel,this.uniforms.dimensions[0]=i,this.uniforms.dimensions[1]=o,this.uniforms.aspect=o/i,this.uniforms.time=this.time,this.uniforms.alpha=this.alpha,e.applyFilter(this,t,r,n)}get angle(){return this._angle}set angle(e){this._angle=e;const r=e*t.DEG_TO_RAD;this._angleLight.x=Math.cos(r),this._angleLight.y=Math.sin(r)}get gain(){return this.uniforms.gain}set gain(e){this.uniforms.gain=e}get lacunarity(){return this.uniforms.lacunarity}set lacunarity(e){this.uniforms.lacunarity=e}get alpha(){return this.uniforms.alpha}set alpha(e){this.uniforms.alpha=e}};let ae=se;ae.defaults={angle:30,gain:.5,lacunarity:2.5,time:0,parallel:!0,center:[0,0],alpha:1};class le extends t.Filter{constructor(){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","precision mediump float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\n// https://en.wikipedia.org/wiki/Luma_(video)\nconst vec3 weight = vec3(0.299, 0.587, 0.114);\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = vec4(\n        vec3(color.r * weight.r + color.g * weight.g  + color.b * weight.b),\n        color.a\n    );\n}\n")}}const ue=class extends t.Filter{constructor(e){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","precision mediump float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float uHue;\nuniform float uAlpha;\nuniform bool uColorize;\nuniform float uSaturation;\nuniform float uLightness;\n\n// https://en.wikipedia.org/wiki/Luma_(video)\nconst vec3 weight = vec3(0.299, 0.587, 0.114);\n\nfloat getWeightedAverage(vec3 rgb) {\n    return rgb.r * weight.r + rgb.g * weight.g + rgb.b * weight.b;\n}\n\n// https://gist.github.com/mairod/a75e7b44f68110e1576d77419d608786?permalink_comment_id=3195243#gistcomment-3195243\nconst vec3 k = vec3(0.57735, 0.57735, 0.57735);\n\nvec3 hueShift(vec3 color, float angle) {\n    float cosAngle = cos(angle);\n    return vec3(\n    color * cosAngle +\n    cross(k, color) * sin(angle) +\n    k * dot(k, color) * (1.0 - cosAngle)\n    );\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    vec4 result = color;\n\n    // colorize\n    if (uColorize) {\n        result.rgb = vec3(getWeightedAverage(result.rgb), 0., 0.);\n    }\n\n    // hue\n    result.rgb = hueShift(result.rgb, uHue);\n\n    // saturation\n    // https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/huesaturation.js\n    float average = (result.r + result.g + result.b) / 3.0;\n\n    if (uSaturation > 0.) {\n        result.rgb += (average - result.rgb) * (1. - 1. / (1.001 - uSaturation));\n    } else {\n        result.rgb -= (average - result.rgb) * uSaturation;\n    }\n\n    // lightness\n    result.rgb = mix(result.rgb, vec3(ceil(uLightness)) * color.a, abs(uLightness));\n\n    // alpha\n    gl_FragColor = mix(color, result, uAlpha);\n}\n"),this._hue=0;const t=Object.assign({},ue.defaults,e);Object.assign(this,t)}get hue(){return this._hue}set hue(e){this._hue=e,this.uniforms.uHue=this._hue*(Math.PI/180)}get alpha(){return this.uniforms.uAlpha}set alpha(e){this.uniforms.uAlpha=e}get colorize(){return this.uniforms.uColorize}set colorize(e){this.uniforms.uColorize=e}get lightness(){return this.uniforms.uLightness}set lightness(e){this.uniforms.uLightness=e}get saturation(){return this.uniforms.uSaturation}set saturation(e){this.uniforms.uSaturation=e}};let ce=ue;ce.defaults={hue:0,saturation:0,lightness:0,colorize:!1,alpha:1};class fe extends t.Filter{constructor(e=[0,0],r=5,n=0){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform vec2 uVelocity;\nuniform int uKernelSize;\nuniform float uOffset;\n\nconst int MAX_KERNEL_SIZE = 2048;\n\n// Notice:\n// the perfect way:\n//    int kernelSize = min(uKernelSize, MAX_KERNELSIZE);\n// BUT in real use-case , uKernelSize < MAX_KERNELSIZE almost always.\n// So use uKernelSize directly.\n\nvoid main(void)\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    if (uKernelSize == 0)\n    {\n        gl_FragColor = color;\n        return;\n    }\n\n    vec2 velocity = uVelocity / filterArea.xy;\n    float offset = -uOffset / length(uVelocity) - 0.5;\n    int k = uKernelSize - 1;\n\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\n        if (i == k) {\n            break;\n        }\n        vec2 bias = velocity * (float(i) / float(k) + offset);\n        color += texture2D(uSampler, vTextureCoord + bias);\n    }\n    gl_FragColor = color / float(uKernelSize);\n}\n"),this.kernelSize=5,this.uniforms.uVelocity=new Float32Array(2),this._velocity=new t.ObservablePoint(this.velocityChanged,this),this.setVelocity(e),this.kernelSize=r,this.offset=n}apply(e,t,r,n){const{x:i,y:o}=this.velocity;this.uniforms.uKernelSize=0!==i||0!==o?this.kernelSize:0,e.applyFilter(this,t,r,n)}set velocity(e){this.setVelocity(e)}get velocity(){return this._velocity}setVelocity(e){if(Array.isArray(e)){const[t,r]=e;this._velocity.set(t,r)}else this._velocity.copyFrom(e)}velocityChanged(){this.uniforms.uVelocity[0]=this._velocity.x,this.uniforms.uVelocity[1]=this._velocity.y,this.padding=1+(Math.max(Math.abs(this._velocity.x),Math.abs(this._velocity.y))>>0)}set offset(e){this.uniforms.uOffset=e}get offset(){return this.uniforms.uOffset}}var de="varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform float epsilon;\n\nconst int MAX_COLORS = %maxColors%;\n\nuniform vec3 originalColors[MAX_COLORS];\nuniform vec3 targetColors[MAX_COLORS];\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n\n    float alpha = gl_FragColor.a;\n    if (alpha < 0.0001)\n    {\n      return;\n    }\n\n    vec3 color = gl_FragColor.rgb / alpha;\n\n    for(int i = 0; i < MAX_COLORS; i++)\n    {\n      vec3 origColor = originalColors[i];\n      if (origColor.r < 0.0)\n      {\n        break;\n      }\n      vec3 colorDiff = origColor - color;\n      if (length(colorDiff) < epsilon)\n      {\n        vec3 targetColor = targetColors[i];\n        gl_FragColor = vec4((targetColor + colorDiff) * alpha, alpha);\n        return;\n      }\n    }\n}\n";class he extends t.Filter{constructor(e,t=.05,r=e.length){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}",de.replace(/%maxColors%/g,r.toFixed(0))),this._replacements=[],this._maxColors=0,this.epsilon=t,this._maxColors=r,this.uniforms.originalColors=new Float32Array(3*r),this.uniforms.targetColors=new Float32Array(3*r),this.replacements=e}set replacements(e){const r=this.uniforms.originalColors,n=this.uniforms.targetColors,i=e.length;if(i>this._maxColors)throw new Error(`Length of replacements (${i}) exceeds the maximum colors length (${this._maxColors})`);r[3*i]=-1;for(let o=0;o<i;o++){const i=e[o];let s=i[0];"number"==typeof s?s=t.utils.hex2rgb(s):i[0]=t.utils.rgb2hex(s),r[3*o]=s[0],r[3*o+1]=s[1],r[3*o+2]=s[2];let a=i[1];"number"==typeof a?a=t.utils.hex2rgb(a):i[1]=t.utils.rgb2hex(a),n[3*o]=a[0],n[3*o+1]=a[1],n[3*o+2]=a[2]}this._replacements=e}get replacements(){return this._replacements}refresh(){this.replacements=this._replacements}get maxColors(){return this._maxColors}set epsilon(e){this.uniforms.epsilon=e}get epsilon(){return this.uniforms.epsilon}}const me=class extends t.Filter{constructor(e,t=0){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec2 dimensions;\n\nuniform float sepia;\nuniform float noise;\nuniform float noiseSize;\nuniform float scratch;\nuniform float scratchDensity;\nuniform float scratchWidth;\nuniform float vignetting;\nuniform float vignettingAlpha;\nuniform float vignettingBlur;\nuniform float seed;\n\nconst float SQRT_2 = 1.414213;\nconst vec3 SEPIA_RGB = vec3(112.0 / 255.0, 66.0 / 255.0, 20.0 / 255.0);\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 Overlay(vec3 src, vec3 dst)\n{\n    // if (dst <= 0.5) then: 2 * src * dst\n    // if (dst > 0.5) then: 1 - 2 * (1 - dst) * (1 - src)\n    return vec3((dst.x <= 0.5) ? (2.0 * src.x * dst.x) : (1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)),\n                (dst.y <= 0.5) ? (2.0 * src.y * dst.y) : (1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)),\n                (dst.z <= 0.5) ? (2.0 * src.z * dst.z) : (1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)));\n}\n\n\nvoid main()\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord);\n    vec3 color = gl_FragColor.rgb;\n\n    if (sepia > 0.0)\n    {\n        float gray = (color.x + color.y + color.z) / 3.0;\n        vec3 grayscale = vec3(gray);\n\n        color = Overlay(SEPIA_RGB, grayscale);\n\n        color = grayscale + sepia * (color - grayscale);\n    }\n\n    vec2 coord = vTextureCoord * filterArea.xy / dimensions.xy;\n\n    if (vignetting > 0.0)\n    {\n        float outter = SQRT_2 - vignetting * SQRT_2;\n        vec2 dir = vec2(vec2(0.5, 0.5) - coord);\n        dir.y *= dimensions.y / dimensions.x;\n        float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + vignettingBlur * SQRT_2), 0.0, 1.0);\n        color.rgb *= darker + (1.0 - darker) * (1.0 - vignettingAlpha);\n    }\n\n    if (scratchDensity > seed && scratch != 0.0)\n    {\n        float phase = seed * 256.0;\n        float s = mod(floor(phase), 2.0);\n        float dist = 1.0 / scratchDensity;\n        float d = distance(coord, vec2(seed * dist, abs(s - seed * dist)));\n        if (d < seed * 0.6 + 0.4)\n        {\n            highp float period = scratchDensity * 10.0;\n\n            float xx = coord.x * period + phase;\n            float aa = abs(mod(xx, 0.5) * 4.0);\n            float bb = mod(floor(xx / 0.5), 2.0);\n            float yy = (1.0 - bb) * aa + bb * (2.0 - aa);\n\n            float kk = 2.0 * period;\n            float dw = scratchWidth / dimensions.x * (0.75 + seed);\n            float dh = dw * kk;\n\n            float tine = (yy - (2.0 - dh));\n\n            if (tine > 0.0) {\n                float _sign = sign(scratch);\n\n                tine = s * tine / period + scratch + 0.1;\n                tine = clamp(tine + 1.0, 0.5 + _sign * 0.5, 1.5 + _sign * 0.5);\n\n                color.rgb *= tine;\n            }\n        }\n    }\n\n    if (noise > 0.0 && noiseSize > 0.0)\n    {\n        vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\n        pixelCoord.x = floor(pixelCoord.x / noiseSize);\n        pixelCoord.y = floor(pixelCoord.y / noiseSize);\n        // vec2 d = pixelCoord * noiseSize * vec2(1024.0 + seed * 512.0, 1024.0 - seed * 512.0);\n        // float _noise = snoise(d) * 0.5;\n        float _noise = rand(pixelCoord * noiseSize * seed) - 0.5;\n        color += _noise * noise;\n    }\n\n    gl_FragColor.rgb = color;\n}\n"),this.seed=0,this.uniforms.dimensions=new Float32Array(2),"number"==typeof e?(this.seed=e,e=void 0):this.seed=t,Object.assign(this,me.defaults,e)}apply(e,t,r,n){var i,o;this.uniforms.dimensions[0]=null==(i=t.filterFrame)?void 0:i.width,this.uniforms.dimensions[1]=null==(o=t.filterFrame)?void 0:o.height,this.uniforms.seed=this.seed,e.applyFilter(this,t,r,n)}set sepia(e){this.uniforms.sepia=e}get sepia(){return this.uniforms.sepia}set noise(e){this.uniforms.noise=e}get noise(){return this.uniforms.noise}set noiseSize(e){this.uniforms.noiseSize=e}get noiseSize(){return this.uniforms.noiseSize}set scratch(e){this.uniforms.scratch=e}get scratch(){return this.uniforms.scratch}set scratchDensity(e){this.uniforms.scratchDensity=e}get scratchDensity(){return this.uniforms.scratchDensity}set scratchWidth(e){this.uniforms.scratchWidth=e}get scratchWidth(){return this.uniforms.scratchWidth}set vignetting(e){this.uniforms.vignetting=e}get vignetting(){return this.uniforms.vignetting}set vignettingAlpha(e){this.uniforms.vignettingAlpha=e}get vignettingAlpha(){return this.uniforms.vignettingAlpha}set vignettingBlur(e){this.uniforms.vignettingBlur=e}get vignettingBlur(){return this.uniforms.vignettingBlur}};let ge=me;ge.defaults={sepia:.3,noise:.3,noiseSize:1,scratch:.5,scratchDensity:.3,scratchWidth:1,vignetting:.3,vignettingAlpha:1,vignettingBlur:.3};var ve="varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterClamp;\n\nuniform float uAlpha;\nuniform vec2 uThickness;\nuniform vec4 uColor;\nuniform bool uKnockout;\n\nconst float DOUBLE_PI = 2. * 3.14159265358979323846264;\nconst float ANGLE_STEP = ${angleStep};\n\nfloat outlineMaxAlphaAtPos(vec2 pos) {\n    if (uThickness.x == 0. || uThickness.y == 0.) {\n        return 0.;\n    }\n\n    vec4 displacedColor;\n    vec2 displacedPos;\n    float maxAlpha = 0.;\n\n    for (float angle = 0.; angle <= DOUBLE_PI; angle += ANGLE_STEP) {\n        displacedPos.x = vTextureCoord.x + uThickness.x * cos(angle);\n        displacedPos.y = vTextureCoord.y + uThickness.y * sin(angle);\n        displacedColor = texture2D(uSampler, clamp(displacedPos, filterClamp.xy, filterClamp.zw));\n        maxAlpha = max(maxAlpha, displacedColor.a);\n    }\n\n    return maxAlpha;\n}\n\nvoid main(void) {\n    vec4 sourceColor = texture2D(uSampler, vTextureCoord);\n    vec4 contentColor = sourceColor * float(!uKnockout);\n    float outlineAlpha = uAlpha * outlineMaxAlphaAtPos(vTextureCoord.xy) * (1.-sourceColor.a);\n    vec4 outlineColor = vec4(vec3(uColor) * outlineAlpha, outlineAlpha);\n    gl_FragColor = contentColor + outlineColor;\n}\n";const pe=class extends t.Filter{constructor(e=1,t=0,r=.1,n=1,i=!1){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}",ve.replace(/\$\{angleStep\}/,pe.getAngleStep(r))),this._thickness=1,this._alpha=1,this._knockout=!1,this.uniforms.uThickness=new Float32Array([0,0]),this.uniforms.uColor=new Float32Array([0,0,0,1]),this.uniforms.uAlpha=n,this.uniforms.uKnockout=i,Object.assign(this,{thickness:e,color:t,quality:r,alpha:n,knockout:i})}static getAngleStep(e){const t=Math.max(e*pe.MAX_SAMPLES,pe.MIN_SAMPLES);return(2*Math.PI/t).toFixed(7)}apply(e,t,r,n){this.uniforms.uThickness[0]=this._thickness/t._frame.width,this.uniforms.uThickness[1]=this._thickness/t._frame.height,this.uniforms.uAlpha=this._alpha,this.uniforms.uKnockout=this._knockout,e.applyFilter(this,t,r,n)}get alpha(){return this._alpha}set alpha(e){this._alpha=e}get color(){return t.utils.rgb2hex(this.uniforms.uColor)}set color(e){t.utils.hex2rgb(e,this.uniforms.uColor)}get knockout(){return this._knockout}set knockout(e){this._knockout=e}get thickness(){return this._thickness}set thickness(e){this._thickness=e,this.padding=e}};let xe=pe;xe.MIN_SAMPLES=1,xe.MAX_SAMPLES=100;class ye extends t.Filter{constructor(e=10){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform vec2 size;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= filterArea.xy;\n    coord += filterArea.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= filterArea.zw;\n    coord /= filterArea.xy;\n\n    return coord;\n}\n\nvec2 pixelate(vec2 coord, vec2 size)\n{\n\treturn floor( coord / size ) * size;\n}\n\nvoid main(void)\n{\n    vec2 coord = mapCoord(vTextureCoord);\n\n    coord = pixelate(coord, size);\n\n    coord = unmapCoord(coord);\n\n    gl_FragColor = texture2D(uSampler, coord);\n}\n"),this.size=e}get size(){return this.uniforms.size}set size(e){"number"==typeof e&&(e=[e,e]),this.uniforms.size=e}}class Ce extends t.Filter{constructor(e=0,t=[0,0],r=5,n=-1){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform float uRadian;\nuniform vec2 uCenter;\nuniform float uRadius;\nuniform int uKernelSize;\n\nconst int MAX_KERNEL_SIZE = 2048;\n\nvoid main(void)\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n\n    if (uKernelSize == 0)\n    {\n        gl_FragColor = color;\n        return;\n    }\n\n    float aspect = filterArea.y / filterArea.x;\n    vec2 center = uCenter.xy / filterArea.xy;\n    float gradient = uRadius / filterArea.x * 0.3;\n    float radius = uRadius / filterArea.x - gradient * 0.5;\n    int k = uKernelSize - 1;\n\n    vec2 coord = vTextureCoord;\n    vec2 dir = vec2(center - coord);\n    float dist = length(vec2(dir.x, dir.y * aspect));\n\n    float radianStep = uRadian;\n    if (radius >= 0.0 && dist > radius) {\n        float delta = dist - radius;\n        float gap = gradient;\n        float scale = 1.0 - abs(delta / gap);\n        if (scale <= 0.0) {\n            gl_FragColor = color;\n            return;\n        }\n        radianStep *= scale;\n    }\n    radianStep /= float(k);\n\n    float s = sin(radianStep);\n    float c = cos(radianStep);\n    mat2 rotationMatrix = mat2(vec2(c, -s), vec2(s, c));\n\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\n        if (i == k) {\n            break;\n        }\n\n        coord -= center;\n        coord.y *= aspect;\n        coord = rotationMatrix * coord;\n        coord.y /= aspect;\n        coord += center;\n\n        vec4 sample = texture2D(uSampler, coord);\n\n        // switch to pre-multiplied alpha to correctly blur transparent images\n        // sample.rgb *= sample.a;\n\n        color += sample;\n    }\n\n    gl_FragColor = color / float(uKernelSize);\n}\n"),this._angle=0,this.angle=e,this.center=t,this.kernelSize=r,this.radius=n}apply(e,t,r,n){this.uniforms.uKernelSize=0!==this._angle?this.kernelSize:0,e.applyFilter(this,t,r,n)}set angle(e){this._angle=e,this.uniforms.uRadian=e*Math.PI/180}get angle(){return this._angle}get center(){return this.uniforms.uCenter}set center(e){this.uniforms.uCenter=e}get radius(){return this.uniforms.uRadius}set radius(e){(e<0||e===1/0)&&(e=-1),this.uniforms.uRadius=e}}const _e=class extends t.Filter{constructor(e){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform vec2 dimensions;\n\nuniform bool mirror;\nuniform float boundary;\nuniform vec2 amplitude;\nuniform vec2 waveLength;\nuniform vec2 alpha;\nuniform float time;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main(void)\n{\n    vec2 pixelCoord = vTextureCoord.xy * filterArea.xy;\n    vec2 coord = pixelCoord / dimensions;\n\n    if (coord.y < boundary) {\n        gl_FragColor = texture2D(uSampler, vTextureCoord);\n        return;\n    }\n\n    float k = (coord.y - boundary) / (1. - boundary + 0.0001);\n    float areaY = boundary * dimensions.y / filterArea.y;\n    float v = areaY + areaY - vTextureCoord.y;\n    float y = mirror ? v : vTextureCoord.y;\n\n    float _amplitude = ((amplitude.y - amplitude.x) * k + amplitude.x ) / filterArea.x;\n    float _waveLength = ((waveLength.y - waveLength.x) * k + waveLength.x) / filterArea.y;\n    float _alpha = (alpha.y - alpha.x) * k + alpha.x;\n\n    float x = vTextureCoord.x + cos(v * 6.28 / _waveLength - time) * _amplitude;\n    x = clamp(x, filterClamp.x, filterClamp.z);\n\n    vec4 color = texture2D(uSampler, vec2(x, y));\n\n    gl_FragColor = color * _alpha;\n}\n"),this.time=0,this.uniforms.amplitude=new Float32Array(2),this.uniforms.waveLength=new Float32Array(2),this.uniforms.alpha=new Float32Array(2),this.uniforms.dimensions=new Float32Array(2),Object.assign(this,_e.defaults,e)}apply(e,t,r,n){var i,o;this.uniforms.dimensions[0]=null==(i=t.filterFrame)?void 0:i.width,this.uniforms.dimensions[1]=null==(o=t.filterFrame)?void 0:o.height,this.uniforms.time=this.time,e.applyFilter(this,t,r,n)}set mirror(e){this.uniforms.mirror=e}get mirror(){return this.uniforms.mirror}set boundary(e){this.uniforms.boundary=e}get boundary(){return this.uniforms.boundary}set amplitude(e){this.uniforms.amplitude[0]=e[0],this.uniforms.amplitude[1]=e[1]}get amplitude(){return this.uniforms.amplitude}set waveLength(e){this.uniforms.waveLength[0]=e[0],this.uniforms.waveLength[1]=e[1]}get waveLength(){return this.uniforms.waveLength}set alpha(e){this.uniforms.alpha[0]=e[0],this.uniforms.alpha[1]=e[1]}get alpha(){return this.uniforms.alpha}};let be=_e;be.defaults={mirror:!0,boundary:.5,amplitude:[0,20],waveLength:[30,100],alpha:[1,1],time:0};class Se extends t.Filter{constructor(e=[-10,0],t=[0,10],r=[0,0]){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","precision mediump float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec2 red;\nuniform vec2 green;\nuniform vec2 blue;\n\nvoid main(void)\n{\n   gl_FragColor.r = texture2D(uSampler, vTextureCoord + red/filterArea.xy).r;\n   gl_FragColor.g = texture2D(uSampler, vTextureCoord + green/filterArea.xy).g;\n   gl_FragColor.b = texture2D(uSampler, vTextureCoord + blue/filterArea.xy).b;\n   gl_FragColor.a = texture2D(uSampler, vTextureCoord).a;\n}\n"),this.red=e,this.green=t,this.blue=r}get red(){return this.uniforms.red}set red(e){this.uniforms.red=e}get green(){return this.uniforms.green}set green(e){this.uniforms.green=e}get blue(){return this.uniforms.blue}set blue(e){this.uniforms.blue=e}}const Te=class extends t.Filter{constructor(e=[0,0],t,r=0){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\n\nuniform vec2 center;\n\nuniform float amplitude;\nuniform float wavelength;\n// uniform float power;\nuniform float brightness;\nuniform float speed;\nuniform float radius;\n\nuniform float time;\n\nconst float PI = 3.14159;\n\nvoid main()\n{\n    float halfWavelength = wavelength * 0.5 / filterArea.x;\n    float maxRadius = radius / filterArea.x;\n    float currentRadius = time * speed / filterArea.x;\n\n    float fade = 1.0;\n\n    if (maxRadius > 0.0) {\n        if (currentRadius > maxRadius) {\n            gl_FragColor = texture2D(uSampler, vTextureCoord);\n            return;\n        }\n        fade = 1.0 - pow(currentRadius / maxRadius, 2.0);\n    }\n\n    vec2 dir = vec2(vTextureCoord - center / filterArea.xy);\n    dir.y *= filterArea.y / filterArea.x;\n    float dist = length(dir);\n\n    if (dist <= 0.0 || dist < currentRadius - halfWavelength || dist > currentRadius + halfWavelength) {\n        gl_FragColor = texture2D(uSampler, vTextureCoord);\n        return;\n    }\n\n    vec2 diffUV = normalize(dir);\n\n    float diff = (dist - currentRadius) / halfWavelength;\n\n    float p = 1.0 - pow(abs(diff), 2.0);\n\n    // float powDiff = diff * pow(p, 2.0) * ( amplitude * fade );\n    float powDiff = 1.25 * sin(diff * PI) * p * ( amplitude * fade );\n\n    vec2 offset = diffUV * powDiff / filterArea.xy;\n\n    // Do clamp :\n    vec2 coord = vTextureCoord + offset;\n    vec2 clampedCoord = clamp(coord, filterClamp.xy, filterClamp.zw);\n    vec4 color = texture2D(uSampler, clampedCoord);\n    if (coord != clampedCoord) {\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\n    }\n\n    // No clamp :\n    // gl_FragColor = texture2D(uSampler, vTextureCoord + offset);\n\n    color.rgb *= 1.0 + (brightness - 1.0) * p * fade;\n\n    gl_FragColor = color;\n}\n"),this.center=e,Object.assign(this,Te.defaults,t),this.time=r}apply(e,t,r,n){this.uniforms.time=this.time,e.applyFilter(this,t,r,n)}get center(){return this.uniforms.center}set center(e){this.uniforms.center=e}get amplitude(){return this.uniforms.amplitude}set amplitude(e){this.uniforms.amplitude=e}get wavelength(){return this.uniforms.wavelength}set wavelength(e){this.uniforms.wavelength=e}get brightness(){return this.uniforms.brightness}set brightness(e){this.uniforms.brightness=e}get speed(){return this.uniforms.speed}set speed(e){this.uniforms.speed=e}get radius(){return this.uniforms.radius}set radius(e){this.uniforms.radius=e}};let Fe=Te;Fe.defaults={amplitude:30,wavelength:160,brightness:1,speed:500,radius:-1};class Ae extends t.Filter{constructor(e,t=0,r=1){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform sampler2D uLightmap;\nuniform vec4 filterArea;\nuniform vec2 dimensions;\nuniform vec4 ambientColor;\nvoid main() {\n    vec4 diffuseColor = texture2D(uSampler, vTextureCoord);\n    vec2 lightCoord = (vTextureCoord * filterArea.xy) / dimensions;\n    vec4 light = texture2D(uLightmap, lightCoord);\n    vec3 ambient = ambientColor.rgb * ambientColor.a;\n    vec3 intensity = ambient + light.rgb;\n    vec3 finalColor = diffuseColor.rgb * intensity;\n    gl_FragColor = vec4(finalColor, diffuseColor.a);\n}\n"),this._color=0,this.uniforms.dimensions=new Float32Array(2),this.uniforms.ambientColor=new Float32Array([0,0,0,r]),this.texture=e,this.color=t}apply(e,t,r,n){var i,o;this.uniforms.dimensions[0]=null==(i=t.filterFrame)?void 0:i.width,this.uniforms.dimensions[1]=null==(o=t.filterFrame)?void 0:o.height,e.applyFilter(this,t,r,n)}get texture(){return this.uniforms.uLightmap}set texture(e){this.uniforms.uLightmap=e}set color(e){const r=this.uniforms.ambientColor;"number"==typeof e?(t.utils.hex2rgb(e,r),this._color=e):(r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=e[3],this._color=t.utils.rgb2hex(r))}get color(){return this._color}get alpha(){return this.uniforms.ambientColor[3]}set alpha(e){this.uniforms.ambientColor[3]=e}}class ze extends t.Filter{constructor(e){var r,n;super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float blur;\nuniform float gradientBlur;\nuniform vec2 start;\nuniform vec2 end;\nuniform vec2 delta;\nuniform vec2 texSize;\n\nfloat random(vec3 scale, float seed)\n{\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n    vec2 normal = normalize(vec2(start.y - end.y, end.x - start.x));\n    float radius = smoothstep(0.0, 1.0, abs(dot(vTextureCoord * texSize - start, normal)) / gradientBlur) * blur;\n\n    for (float t = -30.0; t <= 30.0; t++)\n    {\n        float percent = (t + offset - 0.5) / 30.0;\n        float weight = 1.0 - abs(percent);\n        vec4 sample = texture2D(uSampler, vTextureCoord + delta / texSize * percent * radius);\n        sample.rgb *= sample.a;\n        color += sample * weight;\n        total += weight;\n    }\n\n    color /= total;\n    color.rgb /= color.a + 0.00001;\n\n    gl_FragColor = color;\n}\n"),this.uniforms.blur=e.blur,this.uniforms.gradientBlur=e.gradientBlur,this.uniforms.start=null!=(r=e.start)?r:new t.Point(0,window.innerHeight/2),this.uniforms.end=null!=(n=e.end)?n:new t.Point(600,window.innerHeight/2),this.uniforms.delta=new t.Point(30,30),this.uniforms.texSize=new t.Point(window.innerWidth,window.innerHeight),this.updateDelta()}updateDelta(){this.uniforms.delta.x=0,this.uniforms.delta.y=0}get blur(){return this.uniforms.blur}set blur(e){this.uniforms.blur=e}get gradientBlur(){return this.uniforms.gradientBlur}set gradientBlur(e){this.uniforms.gradientBlur=e}get start(){return this.uniforms.start}set start(e){this.uniforms.start=e,this.updateDelta()}get end(){return this.uniforms.end}set end(e){this.uniforms.end=e,this.updateDelta()}}class we extends ze{updateDelta(){const e=this.uniforms.end.x-this.uniforms.start.x,t=this.uniforms.end.y-this.uniforms.start.y,r=Math.sqrt(e*e+t*t);this.uniforms.delta.x=e/r,this.uniforms.delta.y=t/r}}class Pe extends ze{updateDelta(){const e=this.uniforms.end.x-this.uniforms.start.x,t=this.uniforms.end.y-this.uniforms.start.y,r=Math.sqrt(e*e+t*t);this.uniforms.delta.x=-t/r,this.uniforms.delta.y=e/r}}const Me=class extends t.Filter{constructor(e,r,n,i){super(),"number"==typeof e&&(t.utils.deprecation("5.3.0","TiltShiftFilter constructor arguments is deprecated, use options."),e={blur:e,gradientBlur:r,start:n,end:i}),e=Object.assign({},Me.defaults,e),this.tiltShiftXFilter=new we(e),this.tiltShiftYFilter=new Pe(e)}apply(e,t,r,n){const i=e.getFilterTexture();this.tiltShiftXFilter.apply(e,t,i,1),this.tiltShiftYFilter.apply(e,i,r,n),e.returnFilterTexture(i)}get blur(){return this.tiltShiftXFilter.blur}set blur(e){this.tiltShiftXFilter.blur=this.tiltShiftYFilter.blur=e}get gradientBlur(){return this.tiltShiftXFilter.gradientBlur}set gradientBlur(e){this.tiltShiftXFilter.gradientBlur=this.tiltShiftYFilter.gradientBlur=e}get start(){return this.tiltShiftXFilter.start}set start(e){this.tiltShiftXFilter.start=this.tiltShiftYFilter.start=e}get end(){return this.tiltShiftXFilter.end}set end(e){this.tiltShiftXFilter.end=this.tiltShiftYFilter.end=e}};let De=Me;De.defaults={blur:100,gradientBlur:600,start:void 0,end:void 0};const ke=class extends t.Filter{constructor(e){super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}","varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float radius;\nuniform float angle;\nuniform vec2 offset;\nuniform vec4 filterArea;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= filterArea.xy;\n    coord += filterArea.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= filterArea.zw;\n    coord /= filterArea.xy;\n\n    return coord;\n}\n\nvec2 twist(vec2 coord)\n{\n    coord -= offset;\n\n    float dist = length(coord);\n\n    if (dist < radius)\n    {\n        float ratioDist = (radius - dist) / radius;\n        float angleMod = ratioDist * ratioDist * angle;\n        float s = sin(angleMod);\n        float c = cos(angleMod);\n        coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);\n    }\n\n    coord += offset;\n\n    return coord;\n}\n\nvoid main(void)\n{\n\n    vec2 coord = mapCoord(vTextureCoord);\n\n    coord = twist(coord);\n\n    coord = unmapCoord(coord);\n\n    gl_FragColor = texture2D(uSampler, coord );\n\n}\n"),Object.assign(this,ke.defaults,e)}get offset(){return this.uniforms.offset}set offset(e){this.uniforms.offset=e}get radius(){return this.uniforms.radius}set radius(e){this.uniforms.radius=e}get angle(){return this.uniforms.angle}set angle(e){this.uniforms.angle=e}};let Oe=ke;Oe.defaults={radius:200,angle:4,padding:20,offset:new t.Point};var Re="varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\nuniform vec2 uCenter;\nuniform float uStrength;\nuniform float uInnerRadius;\nuniform float uRadius;\n\nconst float MAX_KERNEL_SIZE = ${maxKernelSize};\n\n// author: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand(vec2 co, float seed) {\n    const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n    highp float dt = dot(co + seed, vec2(a, b)), sn = mod(dt, 3.14159);\n    return fract(sin(sn) * c + seed);\n}\n\nvoid main() {\n\n    float minGradient = uInnerRadius * 0.3;\n    float innerRadius = (uInnerRadius + minGradient * 0.5) / filterArea.x;\n\n    float gradient = uRadius * 0.3;\n    float radius = (uRadius - gradient * 0.5) / filterArea.x;\n\n    float countLimit = MAX_KERNEL_SIZE;\n\n    vec2 dir = vec2(uCenter.xy / filterArea.xy - vTextureCoord);\n    float dist = length(vec2(dir.x, dir.y * filterArea.y / filterArea.x));\n\n    float strength = uStrength;\n\n    float delta = 0.0;\n    float gap;\n    if (dist < innerRadius) {\n        delta = innerRadius - dist;\n        gap = minGradient;\n    } else if (radius >= 0.0 && dist > radius) { // radius < 0 means it's infinity\n        delta = dist - radius;\n        gap = gradient;\n    }\n\n    if (delta > 0.0) {\n        float normalCount = gap / filterArea.x;\n        delta = (normalCount - delta) / normalCount;\n        countLimit *= delta;\n        strength *= delta;\n        if (countLimit < 1.0)\n        {\n            gl_FragColor = texture2D(uSampler, vTextureCoord);\n            return;\n        }\n    }\n\n    // randomize the lookup values to hide the fixed number of samples\n    float offset = rand(vTextureCoord, 0.0);\n\n    float total = 0.0;\n    vec4 color = vec4(0.0);\n\n    dir *= strength;\n\n    for (float t = 0.0; t < MAX_KERNEL_SIZE; t++) {\n        float percent = (t + offset) / MAX_KERNEL_SIZE;\n        float weight = 4.0 * (percent - percent * percent);\n        vec2 p = vTextureCoord + dir * percent;\n        vec4 sample = texture2D(uSampler, p);\n\n        // switch to pre-multiplied alpha to correctly blur transparent images\n        // sample.rgb *= sample.a;\n\n        color += sample * weight;\n        total += weight;\n\n        if (t > countLimit){\n            break;\n        }\n    }\n\n    color /= total;\n    // switch back from pre-multiplied alpha\n    // color.rgb /= color.a + 0.00001;\n\n    gl_FragColor = color;\n}\n",Ee=Object.getOwnPropertySymbols,je=Object.prototype.hasOwnProperty,Ie=Object.prototype.propertyIsEnumerable;const Le=class extends t.Filter{constructor(e){const t=Object.assign(Le.defaults,e),{maxKernelSize:r}=t,n=((e,t)=>{var r={};for(var n in e)je.call(e,n)&&t.indexOf(n)<0&&(r[n]=e[n]);if(null!=e&&Ee)for(var n of Ee(e))t.indexOf(n)<0&&Ie.call(e,n)&&(r[n]=e[n]);return r})(t,["maxKernelSize"]);super("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}",Re.replace("${maxKernelSize}",r.toFixed(1))),Object.assign(this,n)}get center(){return this.uniforms.uCenter}set center(e){this.uniforms.uCenter=e}get strength(){return this.uniforms.uStrength}set strength(e){this.uniforms.uStrength=e}get innerRadius(){return this.uniforms.uInnerRadius}set innerRadius(e){this.uniforms.uInnerRadius=e}get radius(){return this.uniforms.uRadius}set radius(e){(e<0||e===1/0)&&(e=-1),this.uniforms.uRadius=e}};let Ve=Le;return Ve.defaults={strength:.1,center:[0,0],innerRadius:0,radius:-1,maxKernelSize:32},e.AdjustmentFilter=i,e.AdvancedBloomFilter=u,e.AsciiFilter=c,e.BevelFilter=f,e.BloomFilter=d,e.BulgePinchFilter=m,e.CRTFilter=X,e.ColorGradientFilter=j,e.ColorMapFilter=I,e.ColorOverlayFilter=L,e.ColorReplaceFilter=V,e.ConvolutionFilter=N,e.CrossHatchFilter=G,e.DotFilter=q,e.DropShadowFilter=Q,e.EmbossFilter=J,e.GlitchFilter=te,e.GlowFilter=ie,e.GodrayFilter=ae,e.GrayscaleFilter=le,e.HslAdjustmentFilter=ce,e.KawaseBlurFilter=o,e.MotionBlurFilter=fe,e.MultiColorReplaceFilter=he,e.OldFilmFilter=ge,e.OutlineFilter=xe,e.PixelateFilter=ye,e.RGBSplitFilter=Se,e.RadialBlurFilter=Ce,e.ReflectionFilter=be,e.ShockwaveFilter=Fe,e.SimpleLightmapFilter=Ae,e.TiltShiftAxisFilter=ze,e.TiltShiftFilter=De,e.TiltShiftXFilter=we,e.TiltShiftYFilter=Pe,e.TwistFilter=Oe,e.ZoomBlurFilter=Ve,Object.defineProperty(e,"__esModule",{value:!0}),e}({},PIXI,PIXI.filters,PIXI.filters);Object.assign(PIXI.filters,__filters);
//# sourceMappingURL=/sm/a81fbc95f2d06fc9441bd5eab12f497356ae9e2687efa16d4866f79acc7b17b0.map

var Notyf = function () {
    "use strict";
    var n, t, o = function () {
            return (o = Object.assign || function (t) {
                for (var i, e = 1, n = arguments.length; e < n; e++)
                    for (var o in i = arguments[e]) Object.prototype.hasOwnProperty.call(i, o) && (t[o] = i[o]);
                return t
            }).apply(this, arguments)
        },
        s = (i.prototype.on = function (t, i) {
            var e = this.listeners[t] || [];
            this.listeners[t] = e.concat([i])
        }, i.prototype.triggerEvent = function (t, i) {
            var e = this;
            (this.listeners[t] || []).forEach(function (t) {
                return t({
                    target: e,
                    event: i
                })
            })
        }, i);

    function i(t) {
        this.options = t, this.listeners = {}
    }(t = n = n || {})[t.Add = 0] = "Add", t[t.Remove = 1] = "Remove";
    var v, e, a = (r.prototype.push = function (t) {
        this.notifications.push(t), this.updateFn(t, n.Add, this.notifications)
    }, r.prototype.splice = function (t, i) {
        var e = this.notifications.splice(t, i)[0];
        return this.updateFn(e, n.Remove, this.notifications), e
    }, r.prototype.indexOf = function (t) {
        return this.notifications.indexOf(t)
    }, r.prototype.onUpdate = function (t) {
        this.updateFn = t
    }, r);

    function r() {
        this.notifications = []
    }(e = v = v || {}).Dismiss = "dismiss";
    var c = {
            types: [{
                type: "success",
                className: "notyf__toast--success",
                backgroundColor: "#3dc763",
                icon: {
                    className: "notyf__icon--success",
                    tagName: "i"
                }
            }, {
                type: "error",
                className: "notyf__toast--error",
                backgroundColor: "#ed3d3d",
                icon: {
                    className: "notyf__icon--error",
                    tagName: "i"
                }
            }],
            duration: 2e3,
            ripple: !0,
            position: {
                x: "right",
                y: "bottom"
            },
            dismissible: !(e.Click = "click")
        },
        p = (d.prototype.on = function (t, i) {
            var e;
            this.events = o(o({}, this.events), ((e = {})[t] = i, e))
        }, d.prototype.update = function (t, i) {
            i === n.Add ? this.addNotification(t) : i === n.Remove && this.removeNotification(t)
        }, d.prototype.removeNotification = function (t) {
            var i, e, n = this,
                o = this._popRenderedNotification(t);
            o && ((e = o.node).classList.add("notyf__toast--disappear"), e.addEventListener(this.animationEndEventName, i = function (t) {
                t.target === e && (e.removeEventListener(n.animationEndEventName, i), n.container.removeChild(e))
            }))
        }, d.prototype.addNotification = function (t) {
            var i = this._renderNotification(t);
            this.notifications.push({
                notification: t,
                node: i
            }), this._announce(t.options.message || "Notification")
        }, d.prototype._renderNotification = function (t) {
            var i, e = this._buildNotificationCard(t),
                n = t.options.className;
            return n && (i = e.classList).add.apply(i, n.split(" ")), this.container.appendChild(e), e
        }, d.prototype._popRenderedNotification = function (t) {
            for (var i = -1, e = 0; e < this.notifications.length && i < 0; e++) this.notifications[e].notification === t && (i = e);
            if (-1 !== i) return this.notifications.splice(i, 1)[0]
        }, d.prototype.getXPosition = function (t) {
            var i;
            return (null === (i = null == t ? void 0 : t.position) || void 0 === i ? void 0 : i.x) || "right"
        }, d.prototype.getYPosition = function (t) {
            var i;
            return (null === (i = null == t ? void 0 : t.position) || void 0 === i ? void 0 : i.y) || "bottom"
        }, d.prototype.adjustContainerAlignment = function (t) {
            var i = this.X_POSITION_FLEX_MAP[this.getXPosition(t)],
                e = this.Y_POSITION_FLEX_MAP[this.getYPosition(t)],
                n = this.container.style;
            n.setProperty("justify-content", e), n.setProperty("align-items", i)
        }, d.prototype._buildNotificationCard = function (n) {
            var t, o = this,
                i = n.options,
                e = i.icon;
            this.adjustContainerAlignment(i);
            var s = this._createHTLMElement({
                    tagName: "div",
                    className: "notyf__toast"
                }),
                a = this._createHTLMElement({
                    tagName: "div",
                    className: "notyf__ripple"
                }),
                r = this._createHTLMElement({
                    tagName: "div",
                    className: "notyf__wrapper"
                }),
                c = this._createHTLMElement({
                    tagName: "div",
                    className: "notyf__message"
                });
            c.innerHTML = i.message || "";
            var p, d, l, u, f, h = i.background || i.backgroundColor;
            e && "object" == typeof e && (p = this._createHTLMElement({
                tagName: "div",
                className: "notyf__icon"
            }), d = this._createHTLMElement({
                tagName: e.tagName || "i",
                className: e.className,
                text: e.text
            }), (l = null !== (t = e.color) && void 0 !== t ? t : h) && (d.style.color = l), p.appendChild(d), r.appendChild(p)), r.appendChild(c), s.appendChild(r), h && (i.ripple ? (a.style.background = h, s.appendChild(a)) : s.style.background = h), i.dismissible && (u = this._createHTLMElement({
                tagName: "div",
                className: "notyf__dismiss"
            }), f = this._createHTLMElement({
                tagName: "button",
                className: "notyf__dismiss-btn"
            }), u.appendChild(f), r.appendChild(u), s.classList.add("notyf__toast--dismissible"), f.addEventListener("click", function (t) {
                var i, e;
                null !== (e = (i = o.events)[v.Dismiss]) && void 0 !== e && e.call(i, {
                    target: n,
                    event: t
                }), t.stopPropagation()
            })), s.addEventListener("click", function (t) {
                var i, e;
                return null === (e = (i = o.events)[v.Click]) || void 0 === e ? void 0 : e.call(i, {
                    target: n,
                    event: t
                })
            });
            var m = "top" === this.getYPosition(i) ? "upper" : "lower";
            return s.classList.add("notyf__toast--" + m), s
        }, d.prototype._createHTLMElement = function (t) {
            var i = t.tagName,
                e = t.className,
                n = t.text,
                o = document.createElement(i);
            return e && (o.className = e), o.textContent = n || null, o
        }, d.prototype._createA11yContainer = function () {
            var t = this._createHTLMElement({
                tagName: "div",
                className: "notyf-announcer"
            });
            t.setAttribute("aria-atomic", "true"), t.setAttribute("aria-live", "polite"), t.style.border = "0", t.style.clip = "rect(0 0 0 0)", t.style.height = "1px", t.style.margin = "-1px", t.style.overflow = "hidden", t.style.padding = "0", t.style.position = "absolute", t.style.width = "1px", t.style.outline = "0", document.body.appendChild(t), this.a11yContainer = t
        }, d.prototype._announce = function (t) {
            var i = this;
            this.a11yContainer.textContent = "", setTimeout(function () {
                i.a11yContainer.textContent = t
            }, 100)
        }, d.prototype._getAnimationEndEventName = function () {
            var t, i = document.createElement("_fake"),
                e = {
                    MozTransition: "animationend",
                    OTransition: "oAnimationEnd",
                    WebkitTransition: "webkitAnimationEnd",
                    transition: "animationend"
                };
            for (t in e)
                if (void 0 !== i.style[t]) return e[t];
            return "animationend"
        }, d);

    function d() {
        this.notifications = [], this.events = {}, this.X_POSITION_FLEX_MAP = {
            left: "flex-start",
            center: "center",
            right: "flex-end"
        }, this.Y_POSITION_FLEX_MAP = {
            top: "flex-start",
            center: "center",
            bottom: "flex-end"
        };
        var t = document.createDocumentFragment(),
            i = this._createHTLMElement({
                tagName: "div",
                className: "notyf"
            });
        t.appendChild(i), document.body.appendChild(t), this.container = i, this.animationEndEventName = this._getAnimationEndEventName(), this._createA11yContainer()
    }

    function l(t) {
        var n = this;
        this.dismiss = this._removeNotification, this.notifications = new a, this.view = new p;
        var i = this.registerTypes(t);
        this.options = o(o({}, c), t), this.options.types = i, this.notifications.onUpdate(function (t, i) {
            return n.view.update(t, i)
        }), this.view.on(v.Dismiss, function (t) {
            var i = t.target,
                e = t.event;
            n._removeNotification(i), i.triggerEvent(v.Dismiss, e)
        }), this.view.on(v.Click, function (t) {
            var i = t.target,
                e = t.event;
            return i.triggerEvent(v.Click, e)
        })
    }
    return l.prototype.error = function (t) {
        var i = this.normalizeOptions("error", t);
        return this.open(i)
    }, l.prototype.success = function (t) {
        var i = this.normalizeOptions("success", t);
        return this.open(i)
    }, l.prototype.open = function (i) {
        var t = this.options.types.find(function (t) {
                return t.type === i.type
            }) || {},
            e = o(o({}, t), i);
        this.assignProps(["ripple", "position", "dismissible"], e);
        var n = new s(e);
        return this._pushNotification(n), n
    }, l.prototype.dismissAll = function () {
        for (; this.notifications.splice(0, 1););
    }, l.prototype.assignProps = function (t, i) {
        var e = this;
        t.forEach(function (t) {
            i[t] = null == i[t] ? e.options[t] : i[t]
        })
    }, l.prototype._pushNotification = function (t) {
        var i = this;
        this.notifications.push(t);
        var e = void 0 !== t.options.duration ? t.options.duration : this.options.duration;
        e && setTimeout(function () {
            return i._removeNotification(t)
        }, e)
    }, l.prototype._removeNotification = function (t) {
        var i = this.notifications.indexOf(t); - 1 !== i && this.notifications.splice(i, 1)
    }, l.prototype.normalizeOptions = function (t, i) {
        var e = {
            type: t
        };
        return "string" == typeof i ? e.message = i : "object" == typeof i && (e = o(o({}, e), i)), e
    }, l.prototype.registerTypes = function (t) {
        var i = (t && t.types || []).slice();
        return c.types.map(function (e) {
            var n = -1;
            i.forEach(function (t, i) {
                t.type === e.type && (n = i)
            });
            var t = -1 !== n ? i.splice(n, 1)[0] : {};
            return o(o({}, e), t)
        }).concat(i)
    }, l
}();

// Generated by CoffeeScript 2.7.0
// * Данный класс отвечает за HTML элементы пользовательского интерфейса на сценах

//https://github.com/caroso1222/notyf

//TODO: load material icons? make more notifies (info, warning?)

//<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

//$[ENCODE]
window.HUIManager = function() {};

(function() {
  var _;
  //@[DEFINES]
  _ = window.HUIManager;
  _.init = function() {
    this._isMouseHoverHtmlElement = false;
    this._loadCSS();
    this._createRelativeParent();
    this._createLoadSpinner();
    this._createNotify();
    // * Отключаем контекстное меню у новых элементов
    Graphics._disableContextMenu();
  };
  _.isUnderMouse = function() {
    return this._isMouseHoverHtmlElement === true;
  };
  // * Когда происходит смена сцены в игре
  // * (надо убирать лишние элементы, которые не могут переходить на другую сцену)
  _.onGameSceneChanged = function() {
    return this.hideWaitingInfo();
  };
  _.showLoader = function(delay = 200) {
    var e;
    try {
      if (this.isLoaderActive()) {
        return;
      }
      this._loaderThread = setTimeout((function() {
        if (!document.getElementById("anetLoader")) {
          return document.body.appendChild(HUIManager._loader);
        }
      }), delay);
    } catch (error) {
      e = error;
      console.warn(e);
    }
  };
  _.hideLoader = function() {
    var e;
    try {
      if (!this.isLoaderActive()) {
        return;
      }
      clearTimeout(this._loaderThread);
      this._loaderThread = null;
      if (document.getElementById("anetLoader")) {
        document.body.removeChild(this._loader);
      }
    } catch (error) {
      e = error;
      console.log(e);
    }
  };
  _.isLoaderActive = function() {
    return this._loaderThread != null;
  };
  _.showWaitingInfo = function(text, text2, delay = 200) {
    var e;
    try {
      if (this.isWaitingInfoActive()) {
        return;
      }
      this._waitingInfoThread = setTimeout((function() {
        return HUIManager._createWaitPlayersAlert(text, text2);
      }), delay);
    } catch (error) {
      e = error;
      console.warn(e);
    }
  };
  _.hideWaitingInfo = function() {
    var e;
    try {
      if (!this.isWaitingInfoActive()) {
        return;
      }
      clearTimeout(this._waitingInfoThread);
      this._waitingInfoThread = null;
      if (this._waitPlayers != null) {
        document.getElementById("anetCanvasElements").removeChild(this._waitPlayers);
        this._waitPlayers = null;
      }
    } catch (error) {
      e = error;
      console.warn(e);
    }
  };
  _.isWaitingInfoActive = function() {
    return this._waitingInfoThread != null;
  };
  _.notifyError = function(msg) {
    var e;
    try {
      return this._notify.error(msg);
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
  _.notifySucess = function(msg) {
    var e;
    try {
      return this._notify.success(msg);
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
  _.isInputActive = function() {
    return this._input != null;
  };
  _.showInput = function(placeholder, maxlength) {
    if (this._input != null) {
      this.removeInput();
    }
    this._createInputField(placeholder, maxlength);
  };
  _.removeInput = function() {
    var e, root;
    if (this._input == null) {
      return;
    }
    // * Не всегда автоматически выключается, поэтому надо выключить флаг вручную
    HUIManager._isMouseHoverHtmlElement = false;
    try {
      root = document.getElementById("anetCanvasElements");
      this._input.style.display = 'none';
      //root?.removeChild(@_input)
      if (this._input.parentNode != null) {
        this._input.parentNode.removeChild(this._input);
      }
    } catch (error) {
      e = error;
      console.warn(e);
    }
    this._input = null;
  };
  _.focusInput = function() {
    var ref;
    if (this._input == null) {
      return;
    }
    if ((ref = document.getElementById("anetInputName")) != null) {
      ref.focus();
    }
  };
  _.getInputValue = function() {
    var ref;
    if (this._input == null) {
      return "";
    }
    return (ref = document.getElementById("anetInputName")) != null ? ref.value : void 0;
  };
  _.setInputValue = function(value) {
    var ref;
    if (this._input == null) {
      return;
    }
    if ((ref = document.getElementById("anetInputName")) != null) {
      ref.value = value;
    }
  };
  _.updateCanvasHtmlElements = function() {
    if (this._canvasRelativeElements == null) {
      return;
    }
    Graphics._centerElement(this._canvasRelativeElements);
    this._canvasRelativeElements.style.zIndex = 4;
    this._canvasRelativeElements.style.width = Graphics._canvas.style.width;
    this._canvasRelativeElements.style.height = Graphics._canvas.style.height;
  };
  _.appendExternalHtmlElement = function(element) {
    if (this._canvasRelativeElements == null) {
      return;
    }
    this._canvasRelativeElements.appendChild(element);
  };
  // * PRIVATE  ======================================================
  _._loadCSS = function() {
    var head;
    // * Подгружаем CSS стили
    head = document.getElementsByTagName("head")[0];
    // * Fontawesome
    head.insertAdjacentHTML("beforeend", "<link rel=\"stylesheet\" href=\"https://use.fontawesome.com/releases/v5.15.4/css/all.css\" integrity=\"sha384-DyZ88mC6Up2uqS4h/KRgHuoeGwBcD4Ng9SiP4dIRy0EXTlnuz47vAwmeGwVChigm\" crossorigin=\"anonymous\"/>");
    head.insertAdjacentHTML("beforeend", "<link rel=\"stylesheet\" href=\"css/anet.css\" />");
  };
  _._createLoadSpinner = function() {
    this._loader = document.createElement("div");
    this._loader.id = "anetLoader";
    this._loaderThread = null;
  };
  _._createNotify = function() {
    this._notify = new Notyf({
      duration: 1400,
      position: {
        x: 'center',
        y: 'bottom'
      },
      ripple: false
    });
  };
  // * Информация при ожидании других игроков (или другая информация, ожидание сервера)
  _._createWaitPlayersAlert = function(text, extraText) {
    var htmlCode;
    this._waitPlayers = document.createElement("blockquote");
    this._waitPlayers.id = "anetWaitPlayersAlert";
    this._waitPlayers.classList.add("speech-bubble");
    htmlCode = "<p>" + text + "</p>" + "<cite>" + extraText + "</cite>";
    this._waitPlayers.insertAdjacentHTML('beforeend', htmlCode);
    this._canvasRelativeElements.appendChild(this._waitPlayers);
  };
  // * Элемент родитель, который будет изменяться вместе с размерами Canvas
  // * Это позволит сохранять фиксированные позиции HTML элементов не зависимо от размера окна игры
  _._createRelativeParent = function() {
    this._canvasRelativeElements = document.createElement("div");
    this._canvasRelativeElements.id = "anetCanvasElements";
    this._canvasRelativeElements.style.zIndex = 4;
    this.updateCanvasHtmlElements();
    document.body.appendChild(this._canvasRelativeElements);
  };
  _._createInputField = function(placeholder, maxlength) {
    var htmlCode;
    this._input = document.createElement("div");
    this._input.id = "anetInput";
    this._input.addEventListener("mouseenter", function() {
      return HUIManager._isMouseHoverHtmlElement = true;
    });
    this._input.addEventListener("mouseleave", function() {
      return HUIManager._isMouseHoverHtmlElement = false;
    });
    this._input.classList.add("form__group");
    this._input.classList.add("field");
    if (maxlength == null) {
      maxlength = ANET.PP.getTextInputMaxLength();
    }
    htmlCode = "<input type=\"input\" class=\"form__field\" placeholder=\"" + placeholder + "\" autocomplete=\"off\" maxlength=\"" + maxlength + "\" name=\"anetInputName\" id='anetInputName' required /> <label for=\"anetInputName\" class=\"form__label\">" + placeholder + "</label>";
    this._input.insertAdjacentHTML('beforeend', htmlCode);
    this._canvasRelativeElements.appendChild(this._input);
  };
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ Scene_Map.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = Scene_Map.prototype;
})();

(function() {  // ■ END Scene_Map.coffee
  //---------------------------------------------------------------------------

  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ Input.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------

  //TODO: Временно отключил, так как пока нет HUI элементов на карте
  /*if KDX.isMV()
      #@[ALIAS]
      ALIAS__processMapTouch = _.processMapTouch
      _.processMapTouch = ->
          return if HUIManager.isUnderMouse()
          ALIAS__processMapTouch.call(@)
          return
  else
      #@[ALIAS]
      ALIAS__onMapTouch = _.onMapTouch
      _.onMapTouch = ->
          return if HUIManager.isUnderMouse()
          ALIAS__onMapTouch.call(@)
          return */
  var ALIAS___onKeyDown, ALIAS___shouldPreventDefault, _;
  //@[DEFINES]
  _ = Input;
  //@[ALIAS]
  ALIAS___shouldPreventDefault = _._shouldPreventDefault;
  _._shouldPreventDefault = function() {
    // * Чтобы backspace и стрелки работали в поле ввода текста
    if (HUIManager.isInputActive()) {
      return false;
    } else {
      return ALIAS___shouldPreventDefault.call(this);
    }
  };
  
  //@[ALIAS]
  ALIAS___onKeyDown = _._onKeyDown;
  _._onKeyDown = function(event) {
    // * Чтобы игнорировать стандартные кнопки Z, X, space во время ввода
    if (HUIManager.isInputActive()) {
      if (event.keyCode === 90 || event.keyCode === 88 || event.keyCode === 32) {
        this.clear();
        return;
      }
    }
    return ALIAS___onKeyDown.call(this, event);
  };
})();

(function() {  // ■ END Input.coffee
  //---------------------------------------------------------------------------

  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ Graphics.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var ALIAS___updateCanvas, _;
  //@[DEFINES]
  _ = Graphics;
  //@[ALIAS]
  ALIAS___updateCanvas = _._updateCanvas;
  _._updateCanvas = function() {
    ALIAS___updateCanvas.call(this);
    return HUIManager.updateCanvasHtmlElements();
  };
})();

// ■ END Graphics.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
// * Данный класс хранит сетевые методы игры

//$[ENCODE]

//@[GLOBAL]
window.ANGameManager = function() {};

(function() {
  var _;
  //@[DEFINES]
  _ = window.ANGameManager;
  _.isShouldWaitServer = function() {
    return this._waitMode != null;
  };
  // * Инициализация начальных данных (при подключении надо вызывать)
  _.init = function() {
    this.reset();
    this.createMyPlayerData();
    return ANPlayersManager.sendPlayerName();
  };
  // * Когда происходит отключение от сервера
  _.reset = function() {
    // * Флаг что игра только началась и надо установить персонажа когда карта загрузится
    this.networkGameStarted = false;
    this._waitMode = null;
    this.playersData = null;
    ANBattleManager.battleData = null;
  };
  _.createMyPlayerData = function() {
    // * Данные всех игроков в игре
    this.playersData = [];
    // * Сразу добавляем себя
    this.playersData.push(NetPlayerDataWrapper.createLocal());
  };
  _.isInited = function() {
    return this.playersData != null;
  };
  _.myPlayerData = function() {
    return this.getPlayerDataById(ANNetwork.myId());
  };
  _.myActorId = function() {
    return this.myPlayerData().actorId;
  };
  _.myIndex = function() {
    return this.myPlayerData().index;
  };
  _.isMapMaster = function() {
    return this.myPlayerData().isMapMaster === true;
  };
  _.isActorIsBinded = function() {
    return this.myActorId() !== 0;
  };
  // * Дублируется для удобства
  _.isBattleMaster = function() {
    return ANBattleManager.isBattleMaster();
  };
  _.isPlayerDataExists = function(id) {
    var data;
    data = this.playersData.find(function(p) {
      return p.id === id;
    });
    return data != null;
  };
  _.getPlayerDataById = function(id) {
    var data, e;
    if (this.playersData == null) {
      return null;
    }
    try {
      data = this.playersData.find(function(p) {
        return p.id === id;
      });
      if (data != null) {
        return data;
      } else {
        console.warn("Player data for " + id + " not found!");
        this.requestDataClearFor(id);
      }
    } catch (error) {
      e = error;
      console.warn(e);
    }
    return null;
  };
  _.requestDataClearFor = function(netId) {
    var e;
    try {

    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
  _.getPlayerDataByActorId = function(actorId) {
    var data;
    data = this.playersData.find(function(p) {
      return p.actorId === actorId;
    });
    if (data != null) {
      return data;
    } else {
      console.warn("Player data for Actor with ID " + actorId + " not found!");
    }
    return null;
  };
  // * Получить данные об игроке
  //? what && byWhat: actor, actorId, netId, actorName, playerName, playerIndex, info
  _.getPlayerInfo = function(what, byWhat, value) {
    var actorWithName, actors, e, playerData;
    if (what === byWhat) {
      return value;
    }
    if (value == null) {
      return null;
    }
    playerData = null;
    try {
      switch (byWhat) {
        case "actorId":
          playerData = this.getPlayerDataByActorId(value);
          break;
        case "netId":
          playerData = this.getPlayerDataById(value);
          break;
        case "actor":
          playerData = this.getPlayerDataByActorId(value.actorId());
          break;
        case "actorName":
          actors = this.playersData.map(function(d) {
            return $gameActors.actor(d.actorId);
          });
          actorWithName = actors.find(function(a) {
            return a.name() === value;
          });
          if (actorWithName != null) {
            playerData = this.getPlayerDataByActorId(actorWithName.actorId());
          }
          break;
        case "playerName":
          playerData = this.playersData.getByField("name", value);
          break;
        case "playerIndex":
          playerData = this.playersData.getByField("index", value);
          break;
        case "info":
          playerData = value;
          break;
        default:
          console.warn("Unknown field: " + byWhat + ", info not finded");
      }
      if (playerData == null) {
        return null;
      }
      switch (what) {
        case "actorId":
          return playerData.actorId;
        case "netId":
          return playerData.id;
        case "actorName":
          // * Можно рекурсией, через Actor, но для производительности пусть будет так
          actorWithName = $gameActors.actor(playerData.actorId);
          if (actorWithName != null) {
            return actorWithName.name();
          } else {
            return "";
          }
          break;
        case "playerName":
          return playerData.name;
        case "playerIndex":
          return playerData.index;
        case "actor":
          return $gameActors.actor(playerData.actorId); // * info
        default:
          return playerData;
      }
      return null;
    } catch (error) {
      e = error;
      console.warn(e);
      return null;
    }
  };
  _.setupNewNetworkGame = function() {
    this.networkGameStarted = true;
    return $gameParty.setupNetworkGame();
  };
  // * Когда клиент переходит на новую (другую) карту (а не на туже самую)
  _.onNewGameMapSetup = function() {
    // * На всякий случай и тут отключу
    $gameTemp._nLocalActorMode = false;
    this._shouldWaitPlayerOnSameMap = ANNetwork.isSameMapMode();
  };
  // * Когда на клиенте загрузилась карта
  _.onMapLoaded = function() {
    // * Отправляем что мы на карте (загрузились)
    ANMapManager.sendMapLoaded();
    // * Отправляем начальные данные (позиция игрока)
    ANMapManager.sendInitialMapData();
    // * Если загрузка
    if (ANETUtils.isLoadGameRoom()) {
      // * Ждём игроков (Только при параметре)
      if (this._shouldWaitPlayerOnSameMap === true) {
        this.setWait('playersOnMap');
      } else {
        this.bindingActors(); // * Присвоение персонажей
      }
    } else {
      // * Ждём игроков (при параметре и если новая игра (чтобы начать события например))
      if (this._shouldWaitPlayerOnSameMap === true || this.networkGameStarted === true) {
        this.setWait('playersOnMap');
      } else {
        this.onRefreshGameParty();
      }
    }
  };
  _.setWait = function(_waitMode) {
    this._waitMode = _waitMode;
    return HUIManager.showLoader(500);
  };
  _.resetWait = function() {
    this.setWait(null);
    return HUIManager.hideLoader();
  };
  //  * Все ли игроки на данной карте (и сцене)
  _.isAllPlayerOnSameMap = function() {
    //TODO: проверка что на сцене отдельно
    return this.playersData.every(function(p) {
      return p.mapId === $gameMap.mapId();
    });
  };
  // * Другие игроки (кроме этого клиента)
  _.anotherPlayers = function() {
    var myIndex;
    myIndex = this.myIndex();
    return this.playersData.filter(function(p) {
      return p.index !== myIndex;
    });
  };
  // * Все игроки (кроме клиента) на текущей карте (именно на карте, не обязательно на Сцене карты)
  _.anotherPlayersOnMap = function() {
    return this.anotherPlayers().filter(function(p) {
      return NetPlayerDataWrapper.isCharOnMap(p);
    });
  };
  // * Все ли игроки настроили персонажей
  _.isAllPlayersActorsReady = function() {
    return this.playersData.every(function(p) {
      return p.characterReady === true;
    });
  };
  // * Обновить иконку состояния игроков
  _.refreshNetworkStates = function() {
    var char, j, len, p, players, stateId;
    if (!ANET.PP.isShowNetworkIcons()) {
      return;
    }
    // * Используется _, так как метод вызывается в отдельном потоке тоже
    players = this.anotherPlayersOnMap();
    for (j = 0, len = players.length; j < len; j++) {
      p = players[j];
      stateId = NetPlayerDataWrapper.getRequestedNetworkState(p);
      char = NetPlayerDataWrapper.getNetCharacterForPlayer(p);
      if (char != null) {
        char.requestNetworkStateIcon(stateId);
      }
    }
  };
  // * Задаём игрового персонажа
  _.bindingActors = function() {
    console.log("START BINDING ACTORS");
    this.networkGameStarted = false;
    if (ANET.PP.isActorSelectionAllowed() || ANETUtils.isLoadGameRoom()) {
      this.actorBingingFromSelection();
    } else {
      this.staticActorBinging();
    }
  };
  // * Персонаж, выбранный из списка
  _.actorBingingFromSelection = function() {
    var e;
    // * Так как персонаж уже был выбран в лобби, то сразу отправляем готовнотсть
    ANPlayersManager.sendActorReady();
    try {
      this.onPlayerCharacterIsBinded();
    } catch (error) {
      e = error;
      console.warn(e);
    }
  };
  // * Статический режимм присвоения персонажа
  _.staticActorBinging = function() {
    var actorId;
    // * -1, так как myIndex начинается с 1, а массив с 0
    actorId = ANET.PP.actorsForNetwork()[this.myIndex() - 1];
    //  * Пытаемся зарезервировать персонажа
    ANPlayersManager.sendBindActorFromGame(actorId);
  };
  // * Ожидание данных (игроков) от сервера
  _.updateWaiting = function() {
    if (!this.isShouldWaitServer()) {
      return;
    }
    switch (this._waitMode) {
      case 'playersOnMap':
        if (this.isAllPlayerOnSameMap()) {
          this.resetWait();
          this._shouldWaitPlayerOnSameMap = false;
          if (this.networkGameStarted === true) {
            this.bindingActors();
          }
        }
        break;
      case 'playersActors':
        if (this.isAllPlayersActorsReady()) {
          this.resetWait();
          this.startGame();
        }
        break;
    }
  };
  // * Начать игру (когда все уже определились с персонажами)
  // * just wait manul reset
  // * Ждёт когда ожидание будет сброшено вручную
  _.startGame = function() {
    console.log("READY TO START GAME");
    ANMapManager.sendInitialMapData();
  };
  // * Когда игрок покидает игру (disconnect)
  _.anotherPlayerLeaveGame = function(actorId) {
    var ceId;
    LL.log("Player leave game");
    ceId = ANET.PP.getPlayerLeaveGameCommonEventId();
    if (ceId > 0) {
      $gameTemp.reserveCommonEvent(ceId);
    }
  };
  // * После подключения к уже запущенной игре, надо произвести
  // * корректировки данных
  _.applyJoinedDataCorrects = function() {
    var e, ev, j, len, ref, results;
    try {
      // * Убираем любое запущенное событие
      $gameMap._interpreter = new Game_Interpreter();
      // * Чистим золото и вещи
      //TODO: Может опцию сделать?
      $gameParty._gold = 0;
      $gameParty._weapons = {};
      $gameParty._armors = {};
      $gameParty._items = {};
      $gameParty._inBattle = false;
      ref = $gameMap._events;
      // * Отключаем запущенные события
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        ev = ref[j];
        if (ev == null) {
          continue;
        }
        results.push(ev._starting = false);
      }
      return results;
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
  _.onPlayerCharacterIsBinded = function() {
    var d, e, mapId, myActor, params, transferData, x, y;
    if (!ANET.PP.isCustomStartMap()) {
      return;
    }
    try {
      myActor = $gameParty.leader().actor();
      if (KGameItems.IsHaveMeta('nCustomStart', myActor)) {
        transferData = KGameItems.GetMeta('nCustomStart', myActor);
        params = transferData.split(",").map(function(i) {
          return Number(i);
        });
        [mapId, x, y, d] = params;
        if (d == null) {
          d = 2;
        }
        if (x == null) {
          x = 0;
        }
        if (y == null) {
          y = 0;
        }
        if ((mapId != null) && mapId > 0) {
          return $gamePlayer.reserveTransfer(mapId, x, y, d, 0);
        }
      }
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
  
  //? КОМАНДЫ ЗАПРОСЫ (посылаются на сервер)
  // * ===============================================================
  _.sendSceneChanging = function() {
    var sceneType;
    sceneType = this._getCurrentSceneType();
    ANNetwork.send(NetMessage.Game("sceneChange", sceneType));
  };
  _._getCurrentSceneType = function() {
    var sceneType;
    sceneType = "unknown";
    // * Тут не учитывается наследовательность, определяется точный класс через ===
    // * Чтобы на всех сценах, кроме карты была иконка, сделал через unless
    // * Это лучше, чем проверять все все сцены
    if (!SceneManager.isNextScene(Scene_Map)) {
      sceneType = "menu";
    }
    if (SceneManager.isNextScene(Scene_Battle)) {
      sceneType = "battle";
    }
    return sceneType;
  };
  // * Это запрос от мастер клиента на другие клиенты, что надо выполнить сохранение
  _.sendSaveDataRequest = function(savefileId) {
    var data;
    data = {
      uniqueSaveID: $gameTemp.nUniqueSaveID,
      savefileId: savefileId
    };
    ANNetwork.send(NetMessage.Game("saveDataRequest", data));
  };
  // * Это ответ от клиента, что он выполнил сохранение
  _.sendSaveDataCompleteFlag = function() {
    ANNetwork.send(NetMessage.Game("saveDataComplete", this.myActorId()));
  };
  // * Запрос мастера игры (комнаты) на данные игрового мира
  // * (При подключении к уже запущенной игре)
  _.sendStartedRoomGameDataRequest = function(onResponce, onTimeout) {
    ANClientResponceManager.sendResponce(NetMessage.Game("startedRoomGameDataRequest"), onResponce, onTimeout, 5000, "Joining to the game...");
  };
  _.sendStartedRoomDataRespone = function(whoRequestId) {
    var e, gameData;
    try {
      // * Сохраняем данные о текущем мире (игре)
      gameData = DataManager.makeSaveContents();
      if (KDX.isMZ()) {
        // * Тут нельзя редактировать gameData
        return StorageManager.saveObjectForNet(gameData).then(function() {
          // * Отправляем обратно тому кто запросил
          ANNetwork.send(NetMessage.Game("startedRoomGameData", {
            whoRequestId,
            gameData: $gameTemp._startedRoomGameDataResponse
          }));
          return $gameTemp._startedRoomGameDataResponse = null; // * В MV другая реализация сохранения и загрузки данных
        });
      } else {
        gameData = JsonEx.stringify(DataManager.makeSaveContents());
        return ANNetwork.send(NetMessage.Game("startedRoomGameData", {whoRequestId, gameData}));
      }
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
  _.sendJoinedToStartedGame = function() {
    var e;
    try {
      return ANNetwork.send(NetMessage.Game("someoneJoinedToStartedGame"));
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
  // * Когда один игрок применяе предмет (навык) из меню на другого игрока
  _.sendUseItemFromMenuAction = function(action, target) {
    var data, e;
    try {
      data = {
        action,
        target: ANETUtils.packBattlerForNetwork(target)
      };
      return ANNetwork.send(NetMessage.Common("custom_applyItemFromMenu", data));
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
  // * Эти методы отрабатывают тогда, когда игрок (мастер карты) скрывает игру или убирает фокус, чтобы
  // * мастером карты стал другой и логика продолжалась для остальных игроков
  // * Вызываются они из метода nUpdatePlayersActivityState (Scen_Base_N)
  _.sendRefreshActivityWhenInactive = function() {
    var e;
    try {
      if (!$gameTemp.__netBeenDeactivateFromGame) {
        ANNetwork.send(NetMessage.Game("refreshPlayerActivity"));
        $gameTemp.__netBeenDeactivateFromGame = true;
      }
    } catch (error) {
      e = error;
      console.warn(e);
    }
  };
  _.sendRefreshActivityWhenActive = function() {
    var e;
    try {
      if ($gameTemp.__netBeenDeactivateFromGame === true) {
        ANNetwork.send(NetMessage.Game("refreshPlayerActivity"));
        $gameTemp.__netBeenDeactivateFromGame = null;
      }
    } catch (error) {
      e = error;
      console.warn(e);
    }
  };
  _.sendNetworkOption = function(optionName, optionState) {
    var e;
    try {
      return ANNetwork.send(NetMessage.Game("networkOption", {optionName, optionState}));
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
  //? CALLBACKS ОТ ЗАПРОСОВ НА СЕРВЕР
  // * ===============================================================

  //? СОБЫТИЯ (обработка событий от сервера, вызываются из NETClientMethodsManager)
  // * ===============================================================
  _.onNetworkOption = function(optionData) {
    var e, optionName, optionState;
    try {
      //console.log(optionData)
      ({optionName, optionState} = optionData);
      switch (optionName) {
        case "waitTransferMode":
          return typeof $gameSystem !== "undefined" && $gameSystem !== null ? $gameSystem.nRefreshWaitTransferMode(optionState, true) : void 0;
        case 'userDefinedObservers':
          return typeof $gameSystem !== "undefined" && $gameSystem !== null ? $gameSystem._nModifyUserDefinedObserversFromServer(optionState) : void 0;
        default:
          return console.warn('Unknown Network Option ' + optionName);
      }
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
  _.onPlayerName = function(playerId, name) {
    var playerData;
    if (this.isPlayerDataExists()) {
      playerData = this.getPlayerDataById(playerId);
      if (playerData != null) {
        playerData.name = name;
      }
    } else {

    }
  };
  // * Данные об игроках в комнате (подключился, ушёл и т.д.)
  // * Тут архитектурная ошибка или просчёт, суть в том, что когда покидаешь комнату,
  // * приходят данные о игроках команты, а текущего клиента нету, а так как идёт
  // * замена полностью (присваивание), теряются данные текущего игрока
  // * Поэтому проверяется, если данных текущего клиента нету (а это невозможно)
  // * то мы их снова добавляем
  //  * Значит смена имени игрока, с которым мы не в комнате
  // Пока ничего не делаем, так как не видим всех игроков на сервере
  _.onRoomPlayers = function(data) {
    var myPlayerData;
    // * Копия наших данных
    myPlayerData = this.myPlayerData();
    this.playersData = data;
    // * Если наших данных нету (когда покинули комнату бывает такое)
    // * добавляем копию своих данных
    if (!this.getPlayerDataById(ANNetwork.myId())) {
      this.playersData.push(myPlayerData);
    }
  };
  // * Данные (состояния) об игроках (NetPlayer Data новые)
  _.onGamePlayers = function(data) {
    this.onRoomPlayers(data);
    // * Проверить состояние для всех игроков (иконки)
    this.refreshNetworkStates();
    $gameMap.nSafeRefresh();
  };
  // * Когда кто-то из игроков выбрал своего персонажа (готов к игре)
  _.onRefreshGameParty = function() {
    var j, len, plData, ref;
    $gameParty.nClearBeforeRefresh();
    ref = this.playersData;
    for (j = 0, len = ref.length; j < len; j++) {
      plData = ref[j];
      if (NetPlayerDataWrapper.isHaveCharacterInGame(plData)) {
        $gameParty._actors.push(plData.actorId);
      }
    }
    $gameParty.nRefreshSharedMembers();
    $gamePlayer.refresh();
    $gameMap.nSafeRefresh();
    if (ANET.isShowExtOutput()) {
      console.log("REFRESH GAME PARTY");
    }
  };
  _.onLeaveRoom = function() {
    // * Удаляем остальных игроков, оставляем себя
    return this.createMyPlayerData();
  };
  // * Этот метод получают все игроки (и тот кто присоединился)
  _.onPlayerJoinedThisGame = function(joinedPlayerId) { // * EMPTY
    var joinedCE;
    if (ANET.isShowExtOutput()) {
      console.log("JOINED TO GAME " + joinedPlayerId);
    }
    if (joinedPlayerId !== ANNetwork.myId()) {
      return;
    }
    if (ANET.PP.isActorSelectionAllowed()) {
      this.actorBingingFromSelection();
    } else {
      this.staticActorBinging();
    }
    joinedCE = ANET.PP.getJoinedRoomCommonEvent();
    if (joinedCE > 0) {
      $gameTemp.reserveCommonEvent(joinedCE);
    }
  };
})();

//@[EXTEND]
window.NGAME = ANGameManager;


// Generated by CoffeeScript 2.7.0
// * Специальные методы передачи данных для патчей совместимости
ANET.CFIX = function() {};

(function() {
  var _;
  //@[DEFINES]
  _ = ANET.CFIX;
  _.onCustomCommand = function(name, data) {
    var e;
    try {
      if (!name.contains("CFIX")) {
        return;
      }
      return this.processCustomCommand(name, data);
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
  _.send = function(name, data) {
    var e;
    if (!ANNetwork.isConnected()) {
      return;
    }
    // * Внешняя команда была, т.е. не отправляем снова, чтобы не было stackOverflow
    if ($gameTemp._netzCfixLocalOnly === true) {
      $gameTemp._netzCfixLocalOnly = false;
      return;
    }
    try {
      console.log("NETZ CFIX: SEND CUSTOM COMMAND: " + name);
      name = "CFIX_" + name;
      data.myId = ANNetwork.myId();
      nAPI.sendCustomCommand(name, data);
    } catch (error) {
      e = error;
      console.warn(e);
    }
  };
  _.isCommandFromThisClient = function(data) {
    if (data == null) {
      // * true в случае ошибок, чтобы не выполнять комманду
      return true;
    }
    if (data.myId == null) {
      return true;
    }
    return data.myId === ANNetwork.myId();
  };
  _.processCustomCommand = function(name, data) {
    var cmd, e;
    try {
      // * Только другие участники получают команду
      if (this.isCommandFromThisClient(data)) {
        return;
      }
      name = name.replace("CFIX_", "");
      console.log("NETZ CFIX: ON CUSTOM COMMAND: " + name);
      cmd = "on_" + name;
      if (ANET.CFIX[cmd] != null) {
        console.log("...execute...");
        ANET.CFIX[cmd](data);
      }
    } catch (error) {
      e = error;
      console.warn(e);
    }
  };
  _.callLocalOnly = function(method) {
    var e;
    try {
      $gameTemp._netzCfixLocalOnly = true;
      if (method == null) {
        return;
      }
      method();
    } catch (error) {
      e = error;
      console.warn(e);
    }
  };
})();


// Generated by CoffeeScript 2.7.0
//$[ENCODE]

//@[GLOBAL]
window.NetClientMethodsManager = function() {};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ NetClientMethodsManager.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = window.NetClientMethodsManager;
  _.setConnectionToMasterCallback = function(onConnectCallback) {
    this.onConnectCallback = onConnectCallback;
  };
  _.onConnect = function() {
    LL.log("Connected");
    // * Проверка версии сервера и клиента на соответствие
    ANNetwork.callback(NetMessage.Lobby("serverVerCheck", ANET.MinServerRev), function(result) {
      if (!result) {
        LL.warn("Server is outdated, require rev. " + ANET.MinServerRev + " or higher");
        window.alert("Server version is outdated for this Alpha NET Z version " + ANET.Version);
        return ANNetwork.stop();
      }
    });
    if (this.onConnectCallback != null) {
      return this.onConnectCallback(1);
    }
  };
  _.onDisconnect = function() {
    var ref;
    LL.log("Disconnected");
    if (!$gameTemp.__netShouldDisconnectAfterLocalModeScene) {
      if ((ref = SceneManager._scene) != null) {
        ref.onLostConnection();
      }
    }
    HUIManager.notifyError("Disconnected from server");
    return ANNetwork.stop();
  };
  _.onConnectionError = function() {
    LL.warn("Can't connect to server!");
    if (this.onConnectCallback != null) {
      this.onConnectCallback(0);
    }
    return ANNetwork.stop();
  };
  // * Существует ли метод для обработки команды от сервера?
  _.isExistPrcEvent = function(eventHandlerMethodName) {
    return NetClientMethodsManager["event_" + eventHandlerMethodName] != null;
  };
  // * Выполнить команду от сервера
  _.handlePrcEvent = function(eventHandlerMethodName, content) {
    var noLog;
    noLog = true;
    if (ANET.isShowExtOutput()) {
      noLog = ["game_observerData", "map_eventMove", "map_playerMove", "battle_battleMethod", "battle_battleMethodReceived"].contains(eventHandlerMethodName);
      if (!noLog) {
        LL.debug("Handle Event: " + eventHandlerMethodName);
      }
    }
    NetClientMethodsManager["event_" + eventHandlerMethodName](content);
    // * Вызвать метод на сцене, если он существует
    // * Сцена уже сама знает, надо ей обновить (перерисовать) что-то или нет,
    // * определяет по имени метода
    // * С версии 0.7 появились общие комманды, их можно обрабатывать на сцене с учётом имени самой команды
    if (eventHandlerMethodName === "common_forClients" && (content != null) && KString.any(content.cmd)) {
      this.callSceneCallback(eventHandlerMethodName + "_" + content.cmd);
    } else {
      this.callSceneCallback(eventHandlerMethodName);
    }
    if (ANET.isShowExtOutput()) {
      if (!noLog) {
        LL.debug("Event End: " + eventHandlerMethodName);
      }
    }
  };
  _.callSceneCallback = function(eventName) {
    var ref;
    return (ref = SceneManager._scene) != null ? ref.onServerEvent(eventName) : void 0;
  };
  //? ОБРАБОТКА КОМАНД ОТ СЕРВЕРА
  // * =========================================================================

  //TODO: Это возможно и не нужно, так как игрок имя может поменять только перед входом в комнату( созданием)
  _.event_lobby_changePlayerName = function(content) {
    return ANGameManager.onPlayerName(content.who, content.name);
  };
  _.event_lobby_refreshRoomData = function(content) {
    if (SceneManager.isBusyForNetworkData()) {
      return;
    }
    ANGameManager.onRoomPlayers(content.playersData);
    return ANNetwork.onRoomDataFromServer(content.room);
  };
  _.event_lobby_roomClosed = function(content) {
    return ANNetwork.onRoomClosed();
  };
  _.event_lobby_startGame = function() {
    ANGameManager.setupNewNetworkGame();
    return console.log("STARTING GAME");
  };
  _.event_game_playersData = function(content) {
    ANGameManager.onGamePlayers(content);
    if (ANET.isShowExtOutput()) {
      return console.log("GAME PLAYERS DATA REFRESHED");
    }
  };
  _.event_game_refreshParty = function() {
    ANGameManager.onRefreshGameParty();
    if (ANET.isShowExtOutput()) {
      return console.log("REFRESH PARTY");
    }
  };
  _.event_game_observerData = function(content) {
    var e;
    try {
      return ANSyncDataManager.onObserverData(content.id, content.type, content.data);
    } catch (error) {
      e = error;
      return console.warn("event_game_observerData", e);
    }
  };
  _.event_game_variable = function(content) {
    var e;
    try {
      return ANSyncDataManager.onVariableValue(content.id, content.data);
    } catch (error) {
      e = error;
      return console.warn("event_game_variable", e);
    }
  };
  _.event_game_switch = function(content) {
    var e;
    try {
      return ANSyncDataManager.onSwitchValue(content.id, content.data);
    } catch (error) {
      e = error;
      return console.warn("event_game_switch", e);
    }
  };
  _.event_game_saveDataRequest = function(content) {
    var e;
    try {
      $gameTemp.nUniqueSaveID = content.uniqueSaveID;
      // * Сохранение выполненно
      $gameSystem.onBeforeSave();
      DataManager.saveGame(content.savefileId);
      //TODO: Тут желательно ждать положительный результат, но пока сразу отправим флаг
      return ANGameManager.sendSaveDataCompleteFlag();
    } catch (error) {
      e = error;
      return console.warn("event_game_saveDataRequest", e);
    }
  };
  _.event_game_saveDataComplete = function(content) {
    var e, savedActorId;
    try {
      // * Если данный клиент не запускал сохранение, то игнор
      if ($gameTemp.nSaveData == null) {
        return;
      }
      savedActorId = content;
      //console.log(savedActorId)
      return $gameTemp.nSaveData.onAnswer(savedActorId, true);
    } catch (error) {
      e = error;
      return console.warn("event_game_saveDataComplete", e);
    }
  };
  _.event_game_startedRoomGameDataRequest = function(content) {
    var e;
    try {
      // * Эта проверка не обязательная, сервер только матеру отправляет
      if (!ANNetwork.isMasterClient()) {
        return;
      }
      return ANGameManager.sendStartedRoomDataRespone(content);
    } catch (error) {
      e = error;
      return console.warn("event_game_startedRoomGameDataRequest", e);
    }
  };
  _.event_game_startedRoomGameData = function(content) {
    var e, id;
    try {
      // * Тут через ANClientResponceManager
      id = "game_startedRoomGameDataRequest";
      return ANClientResponceManager.onResponceReceived(id, content);
    } catch (error) {
      e = error;
      return console.warn("event_game_startedRoomGameDataRequest", e);
    }
  };
  _.event_game_someoneJoinedToStartedGame = function(content) {
    var e;
    try {
      return ANGameManager.onPlayerJoinedThisGame(content);
    } catch (error) {
      e = error;
      return console.warn("event_game_someoneJoinedToStartedGame", e);
    }
  };
  _.event_game_refreshMasterClient = function(content) {
    var e;
    try {
      if (ANET.PP.isEndGameWhenHostIsLeave()) {
        return SceneManager.goto(Scene_Title);
      } else {
        if (ANNetwork.myId() === content) {
          return ANNetwork._isHost = true;
        }
      }
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
  _.event_map_playerMove = function(content) {
    var e;
    try {
      return ANPlayersManager.onPlayerMove(content.id, content.data);
    } catch (error) {
      e = error;
      return console.warn("event_map_playerMove", e);
    }
  };
  _.event_map_playerLocation = function(content) {
    var e;
    try {
      return ANPlayersManager.onPlayerLocation(content.id, content.data);
    } catch (error) {
      e = error;
      return console.warn("event_map_playerLocation", e);
    }
  };
  _.event_map_eventMove = function(content) {
    var e;
    try {
      return ANMapManager.onEventMove(content.mapId, content.id, content.data);
    } catch (error) {
      e = error;
      return console.warn("event_map_eventMove", e);
    }
  };
  // * Если пришёл этот метод, то надо отправить данные свои на карте, для синхронизации
  _.event_map_initialMapSynchronization = function(content) {
    var e;
    try {
      if ($gameMap.mapId() === content) {
        return ANMapManager.onInitialMapSync();
      }
    } catch (error) {
      e = error;
      return console.warn("event_map_eventMove", e);
    }
  };
  _.event_event_virtualEventCommand = function(content) {
    var e;
    try {
      return ANInterpreterManager.onVirtualCommand(content);
    } catch (error) {
      e = error;
      return console.warn("event_event_virtualEventCommand", e);
    }
  };
  _.event_battle_battleMethod = function(content) {
    var e;
    try {
      return ANBattleManager.onBattleMethod(content.id, content.method, content.data);
    } catch (error) {
      e = error;
      return console.warn("event_battle_battleMethod", e);
    }
  };
  _.event_battle_animation = function(content) {
    var e;
    try {
      return ANBattleManager.onBattleAnimation(content);
    } catch (error) {
      e = error;
      return console.warn("event_battle_animation", e);
    }
  };
  _.event_battle_battleMethodReceived = function(content) {
    var e;
    try {
      return ANBattleManager.onBattleMethodReceived();
    } catch (error) {
      e = error;
      return console.warn("event_battleMethodReceived", e);
    }
  };
  _.event_battle_logMessage = function(content) {
    var e;
    try {
      return ANBattleManager.onLogWindowMessage(content.cmd, content.text);
    } catch (error) {
      e = error;
      return console.warn("event_battle_logMessage", e);
    }
  };
  _.event_battle_input = function(content) {
    var e;
    try {
      return ANBattleManager.onBattleInputState(content.inputState, content.inputActorId);
    } catch (error) {
      e = error;
      return console.warn("event_battle_input", e);
    }
  };
  _.event_battle_inputAction = function(content) {
    var e;
    try {
      return ANBattleManager.onBattleInputAction(content.inputActorId, content.action);
    } catch (error) {
      e = error;
      return console.warn("event_battle_inputAction", e);
    }
  };
  _.event_battle_serverBattleData = function(content) {
    var e;
    try {
      // * Обновляем данные, затем вызывается уже event сцены битвы
      return ANBattleManager.onBattleDataFromServer(content);
    } catch (error) {
      e = error;
      return console.warn("event_battle_serverBattleData", e);
    }
  };
  _.event_battle_executeEncounter = function(content) {
    var e;
    try {
      console.log("ENCOUNTER MAP BATTLE IN");
      return ANBattleManager.onExecuteEncounterBattle(content);
    } catch (error) {
      e = error;
      return console.warn("event_battle_executeEncounter", e);
    }
  };
  _.event_event_registerOnShared = function(content) {
    var e;
    try {
      console.log("SHARED EVENT IN");
      return ANInterpreterManager.onRegisterOnSharedEventRequest(content);
    } catch (error) {
      e = error;
      return console.warn("event_event_registerOnShared", e);
    }
  };
  _.event_event_registerDone = function(content) {
    var e;
    try {
      console.log("SHARED EVENT ANSWER");
      return ANInterpreterManager.onRegisterOnSharedEventResponse(content);
    } catch (error) {
      e = error;
      return console.warn("event_event_registerDone", e);
    }
  };
  _.event_event_sharedCanContinue = function(content) {
    var e;
    try {
      console.log("SHARED EVENT CAN CONTINUE");
      return ANInterpreterManager.onContinueSharedEvent(content);
    } catch (error) {
      e = error;
      return console.warn("event_event_sharedCanContinue", e);
    }
  };
  _.event_event_sharedForceCancel = function(content) {
    var e;
    try {
      console.log("SHARED EVENT FORCE CANCELLED");
      return ANInterpreterManager.onSharedEventForceCancelFromServer(content);
    } catch (error) {
      e = error;
      return console.warn("event_event_sharedForceCancel", e);
    }
  };
  _.event_event_sharedChoice = function(content) {
    var e;
    try {
      console.log("SHARED EVENT CHOICE ACTION");
      return ANInterpreterManager.onSharedEventChoiceActionFromServer(content);
    } catch (error) {
      e = error;
      return console.warn("event_event_sharedForceCancel", e);
    }
  };
  _.event_game_userCommand = function(content) {
    var data, e, name;
    try {
      console.log("CUSTOM COMMAND IN");
      ({name, data} = content);
      return nAPI.onCustomCommand(name, data);
    } catch (error) {
      e = error;
      return console.warn("event_game_userCommand", e);
    }
  };
  _.event_game_customCommandLink = function(content) {
    var commonEventId, e, name;
    try {
      console.log("CUSTOM LINK IN");
      ({name, commonEventId} = content);
      return typeof $gameSystem !== "undefined" && $gameSystem !== null ? $gameSystem.nRegisterCustomCommandCE(name, commonEventId) : void 0;
    } catch (error) {
      e = error;
      return console.warn("event_game_userCommand", e);
    }
  };
  _.event_game_networkOption = function(content) {
    var e;
    try {
      return ANGameManager.onNetworkOption(content);
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
  // * Обработка общих команд, которые имеют внутренний флаг cmd
  // * См. реализацию NetMessage.Common в NetMessages.coffee
  //? ТОЛЬКО НА ДРУГИХ КЛИЕНТАХ, а не на том кто отправил!
  _.event_common_forClients = function(content) {
    var cmd, data, e;
    try {
      ({cmd, data} = content);
      if (cmd.contains("applyItemFromMenu")) {
        return Game_Action.NApplyFromMenuFromNetwork(data);
      } else {
        return console.warn("Unknown common subCommand " + cmd);
      }
    } catch (error) {
      e = error;
      return console.warn("event_common_forClients", e);
    }
  };
  // * Обработка выделенной общей команды для плагина Alpha ABS Z
  _.event_common_absz = function(content) {
    var cmd, data, e;
    try {
      ({cmd, data} = content);
      return NetClientMethodsManager.event_aabz(cmd, data);
    } catch (error) {
      e = error;
      return console.warn("event_common_absz", e);
    }
  };
  //@[FOR OVERRIDE]
  // * Отдельный метод, который должен быть переопределён в плагине AABSZ
  _.event_aabz = function(name, data) { // * for AABS Z plugin implementation
    return console.log("EVENT_AABSZ", name);
  };
})();

// ■ END NetClientMethodsManager.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
// * Данный класс отвечает за синхронизацию и обработку данных в бою

//$[ENCODE]

//@[GLOBAL]
window.ANBattleManager = function() {};

(function() {
  var _;
  //@[DEFINES]
  _ = window.ANBattleManager;
  _.isBattleMaster = function() {
    if (this.battleData != null) {
      return this.battleData.actors[0] === ANGameManager.myActorId();
    } else {
      return $gameParty.inBattle();
    }
  };
  _.isBattleRegistred = function() {
    return this.battleData != null;
  };
  _.isBattleLocal = function() {
    if (this.battleData != null) {
      return this.battleData.isLocal;
    } else {
      return true;
    }
  };
  _.isShouldWaitServer = function() {
    return this._waitMode != null;
  };
  _.battleMembers = function() {
    if (this.isBattleRegistred()) {
      return this.battleData.actors.map(function(a) {
        return $gameActors.actor(a);
      });
    } else {
      return [$gameParty.leader()];
    }
  };
  _.setWait = function(_waitMode) {
    this._waitMode = _waitMode;
    this._waitPool = 0;
    this._waitTimeout = 360;
    return HUIManager.showLoader(1000);
  };
  _.resetWait = function() {
    this.setWait(null);
    return HUIManager.hideLoader();
  };
  _.update = function() {
    if (this.isShouldWaitServer()) {
      if (this._waitTimeout <= 0) {
        LL.debug("TIME OUT");
        this.resetWait();
      } else {
        this._waitTimeout--;
        this.updateWaiting();
      }
    } else {
      if (this._battleMethodsPool.length > 0) {
        this._callBattleMethodOnServer(...this._battleMethodsPool.shift());
      }
      if (HUIManager.isLoaderActive()) {
        HUIManager.hideLoader();
      }
    }
  };
  // * Ожидание данных (игроков) от сервера
  _.updateWaiting = function() {
    if (!this.isShouldWaitServer()) {
      return;
    }
    console.log("WAIT", this._waitPool);
    switch (this._waitMode) {
      case 'battleMethod':
        if (this._waitPool === $gameParty.battleMembers().length) {
          this.resetWait();
        }
    }
  };
  _.updateInputChange = function() {
    if ($gameParty.isOneBattler()) {
      return;
    }
    if (this._lastBattleManagerInputActor !== BattleManager._currentActor) {
      this._lastBattleManagerInputActor = BattleManager._currentActor;
      this.sendInputState();
    } else if (this._lastBattleManagerInputValue !== BattleManager._inputting) {
      this._lastBattleManagerInputValue = BattleManager._inputting;
      this.sendInputState();
    }
  };
  _.registerOnLocalBattle = function() {
    this.battleData = {
      isLocal: true,
      battleId: "local",
      actors: [ANGameManager.myActorId()]
    };
    LL.debug("STARTED LOCAL BATTLE");
  };
  _.onBattleStarted = function() {
    this._battleMethodsPool = [];
    this._lastBattleManagerInputValue = false;
    this._lastBattleManagerInputActor = null;
    this.sendBattleStarted();
  };
  _.onBattleEnd = function() {
    if (!this.isBattleLocal()) {
      this.sendBattleEnded();
    }
    this.battleData = null;
  };
  _.callBattleMethod = function(battler, method, args) {
    // * Если в бою только один игрок, то ничего не отправляем (чтобы не грузить сеть)
    if ($gameParty.isOneBattler()) {
      return;
    }
    if (ANET.PP.isForceBattleSyncMode()) {
      if (this._battleMethodsPool == null) {
        this._battleMethodsPool = [];
      }
      this._battleMethodsPool.push([battler, method, args]);
    } else {
      this._callBattleMethodOnServer(battler, method, args);
    }
  };
  
  // * Отправка метод из очереди (используется в режиме Force Battle Sync)
  _._callBattleMethodOnServer = function(battler, method, args) {
    console.log("CALL BATTLE METHOD");
    // * Обновим данные перед методом битвы
    // * Без этого был баг, что приходил collapse эффект, а hp = 0 уже после
    ANSyncDataManager.sendBattlerObserver(battler);
    // * На всякий случай, чтобы не сбивать основную логику обновления
    battler.netDataObserver._isDataChanged = true;
    this.sendBattleMethod(method, battler.packForNetwork(), args);
    if (ANET.PP.isForceBattleSyncMode()) {
      // * Будем ждать игроков
      this.setWait('battleMethod');
      this._waitPool += 1; // * Мы уже готовы (мастер боя)
    }
  };
  // * Анимация в бою
  _.requestAnimation = function(targets, animationId, mirror = false) {
    var converted, data;
    if ($gameParty.isOneBattler()) {
      return;
    }
    converted = targets.map(function(t) {
      return t.packForNetwork();
    });
    data = {
      animationId: animationId,
      mirror: mirror,
      targets: converted
    };
    this.sendBattleAnimation(data);
  };
  // * Персонаж данного игрока сделал выбор в бою (ввод команды)
  _.battleInputActionDone = function() {
    var action;
    action = BattleManager.inputtingAction();
    // * Логика боя в MV другая, поэтому доп. проверка
    if (KDX.isMV()) {
      if (action == null) {
        return;
      }
    }
    this.sendBattleInputAction(ANGameManager.myActorId(), action);
  };
  // * Регистрация на битву
  _.registerOnBattle = function(battleData) {
    LL.debug("Try register battle: " + battleData.battleId);
    return this.sendRegisterOnBattle(battleData);
  };
  // * Регистрация (вступление в битву) которая уже была начата
  _._registerToExistsSharedBattle = function() {
    LL.debug("Join Shared battle");
    $gameTemp._requestInitialSharedBattleRefresh = true;
  };
  // * Запуск глобальный битвы через Map Encounter
  _.executeMapEncounterBattle = function(troopId) {
    var battleId, e;
    try {
      // * Создаём ID
      battleId = KString.randomString(4);
      // * Регестрируем битву
      BattleManager.nSetNetworkBattle(battleId);
      // * Отправляем на сервер (другим игрокам)
      return this.sendExecuteEncounterBattleRequest({
        battleId,
        mapId: $gameMap.mapId(),
        troopId
      });
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
  //? КОМАНДЫ ЗАПРОСЫ (посылаются на сервер)
  // * ===============================================================

  // * Отправить выбранное игроком (в битве) действие
  _.sendBattleInputAction = function(inputActorId, action) {
    ANNetwork.send(NetMessage.Battle("inputAction", {action, inputActorId}));
  };
  // * Отправить изменение состояния ввода
  _.sendInputState = function() {
    var inputActorId, inputState;
    inputState = BattleManager._inputting;
    if (BattleManager._currentActor != null) {
      inputActorId = BattleManager._currentActor.actorId();
    } else {
      inputActorId = null;
    }
    ANNetwork.send(NetMessage.Battle("input", {inputState, inputActorId}));
  };
  // * Отправить команду WindowLog на сервер
  _.sendWindowLogMessage = function(cmd, text) {
    ANNetwork.send(NetMessage.Battle("logMessage", {cmd, text}));
  };
  _.sendBattleStarted = function() {
    return ANNetwork.send(NetMessage.Battle("started"));
  };
  _.sendBattleEnded = function() {
    return ANNetwork.send(NetMessage.Battle("ended"));
  };
  _.sendBattleMethod = function(methodName, id, args) {
    var data;
    data = {
      method: methodName,
      id: id,
      data: args
    };
    ANNetwork.send(NetMessage.Battle("battleMethod", data), true);
  };
  _.sendBattleAnimation = function(data) {
    ANNetwork.send(NetMessage.Battle("animation", data));
  };
  _.sendBattleMethodReceived = function() {
    ANNetwork.send(NetMessage.Battle("battleMethodReceived"));
  };
  _.sendRegisterOnBattle = function(battleData) {
    ANNetwork.get(NetMessage.Battle("register", battleData), function(result) {
      return ANBattleManager.onBattleRegisterResult(result);
    }, function() {
      // * Снять флаг сетевой битвы (чтобы сцена Start выполнела)
      BattleManager.nSetNetworkBattle(null);
      // * Запускаем локальную битву (чтобы battleData существовал)
      return ANBattleManager.registerOnLocalBattle();
    });
  };
  _.sendExecuteEncounterBattleRequest = function(battleData) {
    return ANNetwork.send(NetMessage.Battle("executeEncounter", battleData));
  };
  //? CALLBACKS ОТ ЗАПРОСОВ НА СЕРВЕР
  // * ===============================================================
  _.onBattleDataFromServer = function(battleData) {
    // * Если этот клиент не участвует в битве, то ничего
    if (!this.isBattleRegistred()) {
      return;
    }
    // * Если я в локальной битве (сам), то меня не касается
    if (this.isBattleLocal()) {
      return;
    }
    // * Данные битвы касаются моей битвы?
    if (this.battleData.battleId === battleData.battleId) {
      $gameTemp._previousNetBattleActors = [...this.battleData.actors];
      this.battleData = battleData;
    }
  };
  _.onBattleRegisterResult = function(result) {
    var _evCallback;
    console.log("REGISTER SUCCESS");
    this.battleData = result;
    // * Эта команда обязательно должны быть ниже этой @battleData = result
    // * После регистрации на сетевую битву, устанавливается Troop
    // * из сервера, чтобы у всех одинаковый был
    // * Чтобы не сбросился callback результата битвы, переносим его
    // * Так как initMembers получается второй раз вызывается
    _evCallback = BattleManager._eventCallback;
    BattleManager.setup(...result.options);
    if (_evCallback != null) {
      BattleManager.setEventCallback(_evCallback);
    }
    console.log(result.options);
    console.info(result);
    if (!this.isBattleMaster()) {
      this._registerToExistsSharedBattle();
    }
  };
  // * С сервера пришла команда проиграть анимацию
  _.onBattleAnimation = function(data) {
    var e, targets;
    try {
      targets = data.targets.map(function(t) {
        return ANETUtils.unpackBattlerFromNetwork(t);
      });
      $gameTemp.requestAnimation(targets, data.animationId, data.mirror);
    } catch (error) {
      e = error;
      console.warn(e);
    }
  };
  // * С сервера пришла команда (метод) боя
  _.onBattleMethod = function(battlerNetData, method, args) {
    var battler, e;
    try {
      //console.log("BATTLE METHOD RECEIVED")
      // * Отправляю мастеру битвы информацию что я получил команду
      if (ANET.PP.isForceBattleSyncMode()) {
        this.sendBattleMethodReceived();
      }
      battler = ANETUtils.unpackBattlerFromNetwork(battlerNetData);
      if (battler[method] != null) {
        //TODO: convert arguments
        battler[method](args);
      }
    } catch (error) {
      e = error;
      console.warn(e);
    }
  };
  // * Игрок принял команду боя
  _.onBattleMethodReceived = function() {
    var e;
    try {
      this._waitPool += 1;
    } catch (error) {
      e = error;
      console.warn(e);
    }
  };
  // * Пришло изменение состояние ввода
  _.onBattleInputState = function(inputState, inputActorId) {
    var e;
    try {
      if (!$gameParty.inBattle()) {
        return;
      }
      BattleManager._inputting = inputState;
      if (inputActorId === ANGameManager.myActorId()) {
        return BattleManager.nSetCurrentClientInput();
      } else {
        // * Если не мой персонаж, то никакого ввода
        return BattleManager.nClearClientInput();
      }
    } catch (error) {
      e = error;
      console.warn(e);
    }
  };
  _.onBattleInputAction = function(inputActorId, action) {
    var e;
    try {
      if (!ANGameManager.isBattleMaster()) {
        return;
      }
      //TODO: Тут есть проблема в MV версии
      //? TypeError: Cannot read property 'setFromNetwork' of null
      // inputtingAction() - нету в MV
      //TODO: Проверка что inputActorId = BattleManager._currentActor.actorId()
      BattleManager.inputtingAction().setFromNetwork(action);
      // * Далее (продолжить бой)
      return BattleManager.selectNextCommand();
    } catch (error) {
      e = error;
      console.warn(e);
    }
  };
  _.onLogWindowMessage = function(cmd, text) {
    var e, ref, ref1;
    try {
      if (!$gameParty.inBattle()) {
        return;
      }
      switch (cmd) {
        case "add":
          if ((ref = BattleManager._logWindow) != null) {
            ref.addText(text);
          }
          break;
        default:
          if ((ref1 = BattleManager._logWindow) != null) {
            ref1.clear();
          }
      }
    } catch (error) {
      e = error;
      console.warn(e);
    }
  };
  _.onExecuteEncounterBattle = function(battleData) {
    var battleId, e, mapId, timeRand, troopId;
    try {
      // * Данный метод приходит ДРУГИМ игрокам, помимо того, кто вызвал битву
      //?Пока просто выходим, если запущено событие
      if ($gameMap.isEventRunning()) {
        return;
      }
      if (KUtils.IsBattleScene()) {
        return;
      }
      if (battleData == null) {
        return;
      }
      ({battleId, mapId, troopId} = battleData);
      // * Нельзя на разных картах!
      if ($gameMap.mapId() !== mapId) {
        return;
      }
      // * Сбрасываем шаги до след. битвы у всех, чтобы не частить
      $gamePlayer.makeEncounterCount();
      // * Чтобы все игрока в одно времяя не начали
      // (чтобы кто-то первый (точно первый) зарегестрировал Shared битву)
      timeRand = Math.random() * 200;
      return setTimeout((function() {
        var e;
        try {
          // * Регестрируемся на Shared битву (как обычно)
          BattleManager.nSetNetworkBattle(battleId);
          // * Настраиваем битву
          BattleManager.setup(troopId, true, false);
          // * Начинаем битву
          return SceneManager.push(Scene_Battle);
        } catch (error) {
          e = error;
          return console.warn(e);
        }
      }), timeRand);
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
})();


// Generated by CoffeeScript 2.7.0
// * Данный класс отвечает за синхронизацию и обработку интерпретера и команд события

//$[ENCODE]

//@[GLOBAL]
window.ANInterpreterManager = function() {};

(function() {
  var _;
  //@[DEFINES]
  _ = window.ANInterpreterManager;
  // * Когда закончелось событие
  _.eventProcessExit = function() {
    if ($gameMessage.isBusy()) {
      $gameMessage.nSetEndCallback(_.eventProcessExit);
    } else {
      if (!$gameMap.isEventRunning()) {
        _.sendEventEnded();
        _.resetSharedEvent();
      }
    }
  };
  // * Дополнительная проверка что статус игрока соответсвует событию (запущено или нет)
  _.checkEventRunning = function() {
    var evId;
    if (NetPlayerDataWrapper.isOnAnyEvent(ANGameManager.myPlayerData())) {
      if (!$gameMap.isEventRunning()) {
        if (!$gameMessage.isBusy()) {
          this.sendEventEnded();
        }
      }
    } else {
      if ($gameMap.isEventRunning()) {
        evId = $gameMap._interpreter.eventId();
        this.sendEventStarted(evId);
      }
    }
  };
  // * Выполнить виртуальную команду (list) вне очереди (не ожидая сцены или другого события)
  // * mapId - ID карты не текущей, а того, от кого пришла команда (нужно для Self.Switch)
  _.startVirtualCommand = function(list, eventId, mapId) {
    var e, key, virtualInter;
    try {
      // * Self.Switch имеет отдельную обработку (так как mapId отличается)
      if (list[0].code === 123 && eventId > 0) {
        key = [mapId, eventId, list[0].parameters[0]];
        $gameSelfSwitches.setValue(key, list[0].parameters[1] === 0); // * Команда может быть только одна (всегда), поэтому else (больше команд нету)
      } else {
        virtualInter = new Game_Interpreter();
        virtualInter.setup(list, eventId);
        virtualInter.executeCommand(); // * force execute
      }
    } catch (error) {
      e = error;
      console.warn(e);
    }
  };
  // * Выполнить комадну виртуально?
  _.isVirtualCommand = function(commandCode) {
    return !ANETSystem.NonVirtualCommandsList.contains(commandCode);
  };
  // * Сброс общего события
  _.resetSharedEvent = function() {
    this._sharedInterpreter = null;
    this._sharedEventMaster = false;
    // * На всякий случай
    this.hideWaitPlayersOnSharedEvent();
  };
  // * Когда игрок запускает общее событие, оно регестрируется этим методом
  // * ссылка на сам interpreter и флаг - является ли игрок мастером - кто первый запустил
  _.setupSharedInterpreter = function(_sharedInterpreter, _sharedEventMaster) {
    this._sharedInterpreter = _sharedInterpreter;
    this._sharedEventMaster = _sharedEventMaster;
    // * Сброс флага необходимости закрытия (для клиентов)
    $gameTemp._shouldForceExitSharedEvent = false;
    // * Нельзя, если уже зарезервированно общее событие от сервера
    if ($gameTemp.isNetworkSharedEventReserved()) {
      return;
    }
    if (this._sharedInterpreter == null) {
      return;
    }
    LL.debug("Shared event registred " + this._sharedInterpreter.eventId());
  };
  // * Является ли данный клиент мастером общего события
  _.isSharedEventMaster = function() {
    return this.isSharedEventIsRunning() && this._sharedEventMaster === true;
  };
  _.isSharedEventIsRunning = function() {
    return (this._sharedInterpreter != null) && $gameMap.isEventRunning();
  };
  // * Отмена ожидания игроков (когда Shared mode == optional)
  _.forceCancelSharedEvent = function() {
    if (!this.isSharedEventMaster()) {
      return;
    }
    LL.debug("Shared event force cancelled");
    console.log("SEND ALL CANCEL EVENT");
    this.sendForceCancelSharedEvent();
    this.hideWaitPlayersOnSharedEvent();
  };
  _.showWaitPlayersOnSharedEvent = function() {
    var text, text2;
    this.hideWaitPlayersOnSharedEvent();
    //TODO: Вынести все строки в параметры
    text = "Waiting players";
    text2 = "";
    if (this.isSharedEventMaster() && this._sharedInterpreter.nIsSharedEventCanBeForceCancelled()) {
      text2 = "Press ESC to cancel";
    }
    if (typeof HUIManager !== "undefined" && HUIManager !== null) {
      HUIManager.showWaitingInfo(text, text2, 1000);
    }
  };
  _.hideWaitPlayersOnSharedEvent = function() {
    return typeof HUIManager !== "undefined" && HUIManager !== null ? HUIManager.hideWaitingInfo() : void 0;
  };
  //? КОМАНДЫ ЗАПРОСЫ (посылаются на сервер)
  // * ===============================================================

  // * Когда игрок запускает какое-либо событие
  _.sendEventStarted = function(eventId) {
    return ANNetwork.send(NetMessage.Event("eventStarted", eventId));
  };
  
  // * Когда игрок "выходит" из запущенного события
  _.sendEventEnded = function() {
    return ANNetwork.send(NetMessage.Event("eventEnded"));
  };
  
  // * Отправка виртуальной команды на сервер
  _.sendEventVirtualCommand = function(command, options, eventId) {
    var data, endCommand, vEvent;
    // * Эта команда всегда в конце
    endCommand = {
      code: 0,
      indent: 0,
      parameters: []
    };
    // * Модель общего события
    vEvent = {
      list: [command, endCommand]
    };
    data = {
      mapId: $gameMap.mapId(),
      eventId: eventId,
      event: vEvent,
      options: options
    };
    ANNetwork.send(NetMessage.Event("virtualEventCommand", data));
  };
  // * Отправка запроса чтобы все начали общее событие
  // * Игрок запустил общее событие и будет теперь ждать всех игроков (на карте)
  _.sendSharedEventRequireRegister = function() {
    var data;
    // * Только мастер может это отправить
    // * Плюс эта проверка гарантирует, что мы запустили событие
    if (!this.isSharedEventMaster()) {
      return;
    }
    data = {
      mapId: $gameMap.mapId(),
      eventId: this._sharedInterpreter.eventId(),
      index: this._sharedInterpreter.nSyncWaitCommandData.index,
      indent: this._sharedInterpreter.nSyncWaitCommandData.indent
    };
    ANNetwork.send(NetMessage.Event("registerOnShared", data));
  };
  // * Отправка ответа, что клиент зарегестрировался на общем событии
  _.sendSharedEventRegisteredDone = function() {
    var data;
    if (this.isSharedEventMaster()) {
      return;
    }
    data = {
      mapId: $gameMap.mapId(),
      eventId: this._sharedInterpreter.eventId(),
      actorId: ANGameManager.myActorId(),
      index: this._sharedInterpreter.nSyncWaitCommandData.index,
      indent: this._sharedInterpreter.nSyncWaitCommandData.indent
    };
    ANNetwork.send(NetMessage.Event("registerDone", data));
  };
  // * Мастер отправляет клиентам, что можно продолжать выполнение
  _.sendSharedEventReadyToContinue = function() {
    var data;
    if (!this.isSharedEventMaster()) {
      return;
    }
    data = {
      mapId: $gameMap.mapId(),
      eventId: this._sharedInterpreter.eventId()
    };
    ANNetwork.send(NetMessage.Event("sharedCanContinue", data));
  };
  // * Когда мастер общего события отменяет общее событие (на стадии ожидания игроков)
  _.sendForceCancelSharedEvent = function() {
    var data;
    if (!this.isSharedEventMaster()) {
      return;
    }
    data = {
      mapId: $gameMap.mapId(),
      eventId: this._sharedInterpreter.eventId()
    };
    ANNetwork.send(NetMessage.Event("sharedForceCancel", data));
  };
  _.sendChoiceSelection = function(index, action) {
    var data;
    if (!this.isSharedEventMaster()) {
      return;
    }
    data = {
      mapId: $gameMap.mapId(),
      eventId: this._sharedInterpreter.eventId(),
      index: index,
      action: action
    };
    ANNetwork.send(NetMessage.Event("sharedChoice", data));
  };
  //? CALLBACKS ОТ ЗАПРОСОВ НА СЕРВЕР
  // * ===============================================================

  // * Просто общее событие ждёт, а некоторые вещи можно сразу выполнять, не зависимо от того игрок находится в событии или нет
  _.onVirtualCommand = function(data) {
    var e, event, list;
    try {
      // * Если только на одой карте, то проверяем номер карты
      if (data.options.scope === "Same map") {
        if ($gameMap.mapId() !== data.mapId) {
          return;
        }
      }
      // * Затем проверяем фильтр (для нас ли эта команда?)
      if (!ANETUtils.isPassEventFilterOptions(data.options)) {
        return;
      }
      event = data.event;
      list = event.list;
      // * В зависимости от опции, запускаем в разных режимах
      switch (data.options.executeMode) {
        case "Virtual":
          _.startVirtualCommand(list, data.eventId, data.mapId);
          break;
        case "Common Event":
          $gameTemp.reserveVirtualCommonEvent(event); //? AUTO
          break;
        default:
          // * Некоторые команды можно выполнять сразу, не ожидая сцены (или другого события)
          if (_.isVirtualCommand(list[0].code)) {
            _.startVirtualCommand(list, data.eventId, data.mapId);
          } else {
            // * Остальные идут как общее событие (приоритетное)
            $gameTemp.reserveVirtualCommonEvent(event);
          }
      }
    } catch (error) {
      e = error;
      console.warn(e);
    }
  };
  // * Когда пришёл запрос с сервера, что надо начать общее событие
  _.onRegisterOnSharedEventRequest = function(data) {
    var e, eventId, indent, index, mapId;
    try {
      ({mapId, eventId, index, indent} = data);
      // * Если карта другая, то пропускаем это сообщение
      if ($gameMap.mapId() !== mapId) {
        return;
      }
      // * Если общее событие уже запущено (не важно какое), игнорируем
      if (_.isSharedEventIsRunning()) {
        return;
      }
      // * Это событие уже начато, т.е. этот клиент опоздал (пришёл с другой карты)
      if (index !== 0) {
        return;
      }
      $gameTemp.reserveNetworkSharedEvent(eventId);
      return;
    } catch (error) {
      e = error;
      console.warn(e);
    }
  };
  // * Когда клиент на необходимой команде общего события
  _.onRegisterOnSharedEventResponse = function(data) {
    var actorId, e, eventId, indent, index, mapId;
    try {
      ({mapId, eventId, actorId, index, indent} = data);
      // * Если карта другая, то пропускаем это сообщение
      if ($gameMap.mapId() !== mapId) {
        return;
      }
      // * Мы не мастер, игнорируем
      if (!_.isSharedEventMaster()) {
        return;
      }
      // * ID событий не совпадают, игнорируем
      if (_._sharedInterpreter.eventId() !== eventId) {
        return;
      }
      // * Регестрируем ответ
      _._sharedInterpreter.nOnSyncedEventCommandResponse(index, indent, actorId);
    } catch (error) {
      e = error;
      console.warn(e);
    }
  };
  // * Когда все игроки "готовы" и можно продолжать выполнение общего события
  _.onContinueSharedEvent = function(data) {
    var e, eventId, mapId;
    try {
      ({mapId, eventId} = data);
      // * Если карта другая, то пропускаем это сообщение
      if ($gameMap.mapId() !== mapId) {
        return;
      }
      // * Если общее событие не запущено, игнорируем
      if (!_.isSharedEventIsRunning()) {
        return;
      }
      // * Мы мастер, игнорируем (выполнение у мастера от пула внутри события)
      if (_.isSharedEventMaster()) {
        return;
      }
      // * ID событий не совпадают, игнорируем
      if (_._sharedInterpreter.eventId() !== eventId) {
        return;
      }
      return _._sharedInterpreter.nAllowContinueSharedEvent();
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
  // * Когда мастер общего события отменил его
  _.onSharedEventForceCancelFromServer = function(data) {
    var e, eventId, mapId;
    try {
      ({mapId, eventId} = data);
      // * Если карта другая, то пропускаем это сообщение
      if ($gameMap.mapId() !== mapId) {
        return;
      }
      // * Мы мастер, игнорируем
      if (_.isSharedEventMaster()) {
        return;
      }
      if (_.isSharedEventIsRunning()) {
        // * ID событий не совпадают, игнорируем
        if (_._sharedInterpreter.eventId() !== eventId) {
          return;
        }
        // * Ставим глобальны флаг (обаботка идёт внутри Game_Event)
        return $gameTemp._shouldForceExitSharedEvent = true;
      } else {
        // * Если событие ещё не было запущено (например этот клиент был в меню)
        // * Надо проверить не стоит ли событие в очереди на запуск
        if ($gameTemp.isNetworkSharedEventReserved()) {
          // * Если ID событий совпадает
          if (eventId === $gameTemp._reservedNetworkSharedEvent) {
            $gameTemp.retrieveNetworkSharedEvent(); // * Забираем без выполнения
          }
        }
      }
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
  // * Когда мастер общего события сменил выбор (или действие выбора) в окне выбора вариантов в сообщении
  _.onSharedEventChoiceActionFromServer = function(data) {
    var action, e, eventId, index, mapId;
    try {
      ({mapId, eventId, action, index} = data);
      // * Если карта другая, то пропускаем это сообщение
      if ($gameMap.mapId() !== mapId) {
        return;
      }
      // * Если клиент не в общем событии, пропускаем
      if (!_.isSharedEventIsRunning()) {
        return;
      }
      // * ID событий не совпадают, игнорируем
      if (_._sharedInterpreter.eventId() !== eventId) {
        return;
      }
      // * Задаём глобальные данные
      $gameTemp.nSelectionActionFromNetwork = {action, index};
      return LL.debug("Shared Choice accepted from server");
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
})();


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ANBattleManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__onLogWindowMessage, _;
  
  // * Эти методы (переопределения) только для RPG Maker MV
  if (KDX.isMZ()) {
    return;
  }
  //@[DEFINES]
  _ = ANBattleManager;
  // * В MV нету _currentActor и _inputting
  //$[OVER]
  _.updateInputChange = function() {
    if ($gameParty.isOneBattler()) {
      return;
    }
    if (this._lastBattleManagerInputActor !== BattleManager._actorIndex) {
      this._lastBattleManagerInputActor = BattleManager._actorIndex;
      this.sendInputState();
    } else if (this._lastBattleManagerInputValue !== BattleManager.isInputting()) {
      this._lastBattleManagerInputValue = BattleManager.isInputting();
      this.sendInputState();
    }
  };
  
  //$[OVER]
  // * Отправить изменение состояния ввода
  _.sendInputState = function() {
    var actor, inputActorId, inputState;
    inputState = BattleManager.isInputting();
    actor = BattleManager.actor();
    if (actor != null) {
      inputActorId = actor.actorId();
    } else {
      inputActorId = null;
    }
    ANNetwork.send(NetMessage.Battle("input", {inputState, inputActorId}));
  };
  //$[OVER]
  // * Пришло изменение состояние ввода
  _.onBattleInputState = function(inputState, inputActorId) {
    var e;
    try {
      if (!$gameParty.inBattle()) {
        return;
      }
      if (inputState === true) {
        BattleManager._phase = 'input';
      } else {
        // * Чтобы скрыть выбор действий
        BattleManager.startTurn();
      }
      if (inputActorId === ANGameManager.myActorId()) {
        BattleManager.nSetCurrentClientInput();
      } else {
        // * Если не мой персонаж, то никакого ввода
        BattleManager.nClearClientInput();
      }
      return $gameTemp._isBattleSceneShouldBeRefreshed = true;
    } catch (error) {
      e = error;
      console.warn(e);
    }
  };
  // * В MV анимация отдельно реализована
  // * Отправить боевую анимацию (из WindowLog) на сервер
  _.sendWindowLogAnimation = function(targets, animationId, mirror) {
    var converted, data;
    converted = targets.map(function(t) {
      return t.packForNetwork();
    });
    data = {
      animationId: animationId,
      mirror: mirror,
      targets: converted
    };
    // * Используем метод из MZ версии
    this.sendBattleAnimation(data);
  };
  //@[ALIAS]
  ALIAS__onLogWindowMessage = _.onLogWindowMessage;
  _.onLogWindowMessage = function() {
    ALIAS__onLogWindowMessage.call(this, ...arguments);
    $gameTemp.requestBattleRefresh();
  };
  // * С сервера пришла команда проиграть анимацию (замена метода из MZ)
  //$[OVER]
  _.onBattleAnimation = function(data) {
    var e, ref, targets;
    try {
      targets = data.targets.map(function(t) {
        return ANETUtils.unpackBattlerFromNetwork(t);
      });
      if ((ref = BattleManager._logWindow) != null) {
        ref.showNormalAnimation(targets, data.animationId, data.mirror);
      }
    } catch (error) {
      e = error;
      console.warn(e);
    }
  };
})();

// ■ END ANBattleManager.coffee
//---------------------------------------------------------------------------


// * Данный оперирует запросами данных и ответами от игрока к игроку
var ANClientResponceManager;
(function (ANClientResponceManager) {
    ANClientResponceManager.currentResponce = null;
    // * Отправить сообщение и ждать результат
    // * Тут результат должен прийти от другого клиента
    //? Этот метод тормозит всю игру
    //%[Главный метод отправки запроса данных]
    /**
     * Send a message and wait for a response
     * The result should come from another client
     * This method pauses the entire game
     * @param msg - The message to send
     * @param onResponce - Callback function when a response is received
     * @param onTimeout - Callback function when a timeout occurs
     * @param timeoutTime - The time to wait before timing out
     * @param infoMessage - An optional info message to display
     */
    function sendResponce(msg, onResponce, onTimeout, timeoutTime, infoMessage) {
        try {
            if (!ANNetwork.isConnected())
                return;
            ANNetwork.setWait();
            // * Show with a delay to avoid flickering if data comes immediately
            if (infoMessage) {
                setTimeout(() => {
                    if (ANClientResponceManager.currentResponce) {
                        //@ts-ignore
                        nAPI.showInfoMessage(infoMessage);
                    }
                }, 400);
            }
            ANClientResponceManager.currentResponce = {
                id: msg.fullName(),
                timeout: setTimeout(() => {
                    _continueGameProcess();
                    onTimeout();
                }, timeoutTime),
                callback: onResponce
            };
            LL.debug(ANClientResponceManager.currentResponce.id);
            ANNetwork.send(msg);
        }
        catch (e) {
            console.warn(e);
        }
    }
    ANClientResponceManager.sendResponce = sendResponce;
    /**
     * This method is called when a response is received from the server
     * (when data comes from another client)
     * @param responceName - The name of the response
     * @param data - The data received
     */
    function onResponceReceived(responceName, data) {
        if (!ANClientResponceManager.currentResponce)
            return;
        const r = ANClientResponceManager.currentResponce;
        // * Need to check that this response is exactly what I am waiting for
        if (r.id === responceName) {
            _continueGameProcess();
            r.callback(data);
        }
    }
    ANClientResponceManager.onResponceReceived = onResponceReceived;
    /**
     * Continue the game logic (hide the message, remove the timeout)
     */
    function _continueGameProcess() {
        if (!ANClientResponceManager.currentResponce)
            return;
        ANNetwork.resetWait();
        //@ts-ignore
        nAPI.hideInfoMessage();
        clearTimeout(ANClientResponceManager.currentResponce.timeout);
        ANClientResponceManager.currentResponce = null;
    }
})(ANClientResponceManager || (ANClientResponceManager = {}));
// Assign the namespace to the global window object
window.ANClientResponceManager = ANClientResponceManager;


var ANETExtenders;
(function (ANETExtenders) {
    let _extenders = [];
    // * Добавить метод расширения
    function extend(method, methodName) {
        LL.log("Add extender: " + methodName);
        _extenders.push(method);
    }
    ANETExtenders.extend = extend;
    // * Загрузить (выполнить) все методы расширения
    function loadExtensions() {
        LL.log("Apply extenders");
        _extenders.forEach((extender) => {
            extender();
        });
        // * Освобождение памяти
        _extenders = [];
    }
    ANETExtenders.loadExtensions = loadExtensions;
})(ANETExtenders || (ANETExtenders = {}));
window['ANETExtenders'] = ANETExtenders;


var ANETSystem;
(function (ANETSystem) {
    // * Все эти команды нельзя запускать через опции (виртуально), но
    // * их теоретически можно вызывать через общее событие у другого игрока
    ANETSystem.ForbiddenVirtualCommandsList = [
        // Message
        101, 102, 103, 104, 105,
        // Flow Control
        111, 112, 113, 115, 118, 119, 108,
        // Party
        129,
        // Movement
        201, 202, 204, 206,
        // Character
        216, 217,
        // Timing
        230,
        // Scene Control
        302, 303, 351, 352,
        // System Settings
        137,
        // Meta
        0, 401, 402, 403, 411, 413, 657
    ];
    // * Список комманд которые запускаются через общее событие, а не виртуально
    ANETSystem.NonVirtualCommandsList = [
        // Flow Control
        117,
        // Scene Control
        301
    ];
    // * Дополнительные полня для синхронизации в битве
    ANETSystem.BattlerObserverFields = [
        "_tpbChargeTime",
        //"_tpbCastTime",
        //"_tpbIdleTime",
        //"_tpbTurnCount",
        //"_tpbTurnEnd",
        //"_speed",
        //"_actionState",
        //"_damagePopup",
        //"_effectType",
        //"_motionType",
        //"_weaponImageId",
        //"_motionRefresh",
        //"_selected",
        "_tpbState"
    ];
    ANETSystem.ActorObserverFields = [
        "_name",
        "_nickname",
        "_classId",
        "_level",
        "_characterName",
        "_characterIndex",
        "_faceName",
        "_faceIndex",
        "_battlerName",
        "_exp",
        "_equips"
    ];
    ANETSystem.EnemyObserverFields = [
        "_enemyId",
        //"_letter",
        //"_plural",
        "_screenX",
        "_screenY"
    ];
    /**
     * Initial loading of components
     */
    function initSystem() {
        LL.log("Init System");
        loadParameters();
        //@ts-ignore
        ANET.loadPluginCommands();
        ANETExtenders.loadExtensions();
        //@ts-ignore
        HUIManager.init();
    }
    ANETSystem.initSystem = initSystem;
    function loadParameters() {
        //@ts-ignore
        ANET.PP = new ANET.ParamsManager();
    }
    ANETSystem.loadParameters = loadParameters;
})(ANETSystem || (ANETSystem = {}));
window['ANETSystem'] = ANETSystem;
// For compatibility
ANET['System'] = ANETSystem;


// * Набор вспомогательных функций для ANET
var ANETUtils;
(function (ANETUtils) {
    function getGameVersion() {
        // @ts-ignore
        if (ANET.PP.isUseCustomGameId()) {
            // @ts-ignore
            return ANET.PP.getCustomGameId();
        }
        else {
            if (KDX.isMZ()) {
                // @ts-ignore
                return $dataSystem.advanced.gameId.toString();
            }
            else {
                return $dataSystem.versionId.toString();
            }
        }
    }
    ANETUtils.getGameVersion = getGameVersion;
    function isGameInActiveState() {
        return window.top.document.hasFocus();
    }
    ANETUtils.isGameInActiveState = isGameInActiveState;
    // * Проверка, что комментарий является NET командой
    function isNetCommentCommand(commentLine) {
        // * Все команды начинаются с буквы заглавной N, затем пробел и команда
        return !!commentLine && /N\s.+/.exec(commentLine) !== null;
    }
    ANETUtils.isNetCommentCommand = isNetCommentCommand;
    function getNetCommentCommand(commentLine) {
        var _a;
        if (!isNetCommentCommand(commentLine))
            return "";
        // * Возвращает первое слово после N
        const command = (_a = /N\s(!*\w+)/.exec(commentLine)) === null || _a === void 0 ? void 0 : _a[1];
        return command ? command : "";
    }
    ANETUtils.getNetCommentCommand = getNetCommentCommand;
    // * Сохраняет Battler в определённый формат для отправки по сети
    function packBattlerForNetwork(battler) {
        if (battler instanceof Game_Actor) {
            return {
                type: "actor",
                id: battler.actorId()
            };
        }
        else {
            return {
                type: "enemy",
                id: battler.index()
            };
        }
    }
    ANETUtils.packBattlerForNetwork = packBattlerForNetwork;
    // * Возвращяет конкретный Battler из данных сети
    function unpackBattlerFromNetwork(data) {
        if (data.type === "actor") {
            return $gameActors.actor(data.id);
        }
        else {
            return $gameTroop.members()[data.id];
        }
    }
    ANETUtils.unpackBattlerFromNetwork = unpackBattlerFromNetwork;
    // * Сохраняем предмет в определённый формат для оптавки по сети (используется в торговле)
    function packItemForNetwork(item) {
        try {
            if (!item)
                return null;
            const id = item.id;
            const typeId = GetItemTypeId(item);
            return { id, typeId };
        }
        catch (e) {
            console.warn(e);
            return null;
        }
    }
    ANETUtils.packItemForNetwork = packItemForNetwork;
    function GetItemTypeId(item) {
        try {
            if (DataManager.isWeapon(item)) {
                return 1;
            }
            else if (DataManager.isArmor(item)) {
                return 2;
            }
        }
        catch (error) {
            console.warn(error);
        }
        return 0;
    }
    ANETUtils.GetItemTypeId = GetItemTypeId;
    function GetItemByTypeId(id, typeId) {
        try {
            switch (typeId) {
                case 0:
                    return $dataItems[id];
                case 1:
                    return $dataWeapons[id];
                case 2:
                    return $dataArmors[id];
                default:
                    return null;
            }
        }
        catch (error) {
            console.warn(error);
            return null;
        }
    }
    ANETUtils.GetItemByTypeId = GetItemByTypeId;
    // * Shortcuts: p1 - player 1, a1 - actor 1
    function getNetworkCharByShortcut(shortcut) {
        try {
            if (!shortcut)
                return null;
            const typeSymbol = shortcut[0];
            const byWhat = typeSymbol === 'a' ? 'actorId' : typeSymbol === 'p' ? 'playerIndex' : null;
            if (!byWhat)
                return null;
            const itemIndex = parseInt(shortcut.substr(1));
            if (isNaN(itemIndex))
                return null;
            //@ts-ignore
            return nAPI.getPlayerCharacter(byWhat, itemIndex);
        }
        catch (e) {
            console.warn(e);
            return null;
        }
    }
    ANETUtils.getNetworkCharByShortcut = getNetworkCharByShortcut;
    // * Возвращяет конкретный Item из данных сети
    function unpackItemFromNetwork(data) {
        try {
            if (!data)
                return null;
            const { id, typeId } = data;
            return GetItemByTypeId(id, typeId);
        }
        catch (e) {
            console.warn(e);
            return null;
        }
    }
    ANETUtils.unpackItemFromNetwork = unpackItemFromNetwork;
    function getBattlerSprite(battler) {
        if (!KUtils.IsBattleScene())
            return null;
        try {
            //@ts-ignore
            const container = SceneManager._scene._spriteset;
            const sprites = container._enemySprites.concat(container._actorSprites);
            const sprite = sprites.find((spr) => spr && spr._battler === battler);
            return sprite;
        }
        catch (e) {
            console.warn(e);
            return null;
        }
    }
    ANETUtils.getBattlerSprite = getBattlerSprite;
    function isMyActorInValidListToStart(list, isInclude) {
        try {
            const parsedList = JSON.parse(list).map((i) => parseInt(i));
            //@ts-ignore
            return parsedList.includes(ANGameManager.myActorId()) === isInclude;
        }
        catch (e) {
            console.warn(e);
            return false;
        }
    }
    ANETUtils.isMyActorInValidListToStart = isMyActorInValidListToStart;
    function isPassEventFilterOptions(options) {
        try {
            switch (options.whoSelector) {
                case "All":
                    return true;
                case "Master":
                    //@ts-ignore
                    return ANNetwork.isMasterClient();
                case "Master Except":
                    //@ts-ignore
                    return !ANNetwork.isMasterClient();
                case "Actor List":
                    return isMyActorInValidListToStart(options.actorList, true);
                case "Actor List Except":
                    return isMyActorInValidListToStart(options.actorList, false);
                case "Me Except":
                    // * Если команда пришла с сервера, то явно эта проверка не касается этого клиента
                    // * В опциях запуска события - не используется
                    return true;
                default:
                    return false;
            }
        }
        catch (e) {
            console.warn(e);
            return false;
        }
    }
    ANETUtils.isPassEventFilterOptions = isPassEventFilterOptions;
    // * Событие запущенно каким-либо игроком?
    function isEventStartedByAny(eventId) {
        try {
            //@ts-ignore
            return ANGameManager.anotherPlayersOnMap().some((p) => NetPlayerDataWrapper.isOnEvent(p, eventId));
        }
        catch (e) {
            console.warn(e);
            return true;
        }
    }
    ANETUtils.isEventStartedByAny = isEventStartedByAny;
    // * Собрать опции для команды события по параметрам из комменатрия (аналог опций из команды плагина)
    // * Список должен быть строкой! [1, 2, 3]
    function buildEventCommandOptions(selector, list, scope, mode) {
        return {
            actorList: list,
            executeMode: mode,
            scope: scope,
            whoSelector: selector
        };
    }
    ANETUtils.buildEventCommandOptions = buildEventCommandOptions;
    // * Конвертировать из команды комменатрия в параметр команды плагина
    function convertEventCommandScopeAndMode(commentLine) {
        const scope = commentLine.includes("world") ? "All world" : "Same map";
        let mode = "Auto";
        if (commentLine.includes("virtual")) {
            mode = "Virtual";
        }
        else if (commentLine.includes("common")) {
            mode = "Common Event";
        }
        return { scope, mode };
    }
    ANETUtils.convertEventCommandScopeAndMode = convertEventCommandScopeAndMode;
    // * Изъять список персонажей из комментария
    // * Формат выходной [1, 2, 3....]
    function extractActorsListFromComment(commentLine) {
        const regex = /forActors\s+([\d,\s*]*)/gm;
        const resultList = regex.exec(commentLine);
        if (!resultList || !resultList[1])
            return "[]";
        return "[" + resultList[1] + "]";
    }
    ANETUtils.extractActorsListFromComment = extractActorsListFromComment;
    function parseEventStartOptionsFromCommentLine(commentLine) {
        try {
            const nStartOptions = {
                lockMode: "false",
                sharedMode: "No",
                whoSelector: "All",
                actorList: "[]"
            };
            if (commentLine.includes("lock"))
                nStartOptions.lockMode = "true";
            if (commentLine.includes("shared")) {
                nStartOptions.sharedMode = "Strict";
                // * Только если есть флаг sharedMode
                if (commentLine.includes("optional"))
                    nStartOptions.sharedMode = "Optional";
            }
            if (commentLine.includes("master")) {
                nStartOptions.whoSelector = commentLine.includes("!") ? "Master Except" : "Master";
            }
            else if (commentLine.includes("forActors")) {
                nStartOptions.whoSelector = commentLine.includes("!") ? "Actor List Except" : "Actor List";
                nStartOptions.actorList = extractActorsListFromComment(commentLine);
            }
            return nStartOptions;
        }
        catch (e) {
            console.warn(e);
            return null;
        }
    }
    ANETUtils.parseEventStartOptionsFromCommentLine = parseEventStartOptionsFromCommentLine;
    function generateSaveUniqueId() {
        const versionId = getGameVersion();
        const savefileId = versionId + "@" + KString.randomString(12);
        // * Вероятность крайне крайне мала, но нельзя чтобы были повторы
        // @ts-ignore
        if (DataManager.nIsHaveNetworkSaveWithId(savefileId)) {
            return generateSaveUniqueId();
        }
        else {
            return savefileId;
        }
    }
    ANETUtils.generateSaveUniqueId = generateSaveUniqueId;
    // * Текущая комната - это загрузка сохранённой игры?
    function isLoadGameRoom() {
        // @ts-ignore
        if (!ANNetwork.isConnected() || !ANNetwork.room)
            return false;
        // @ts-ignore
        return NetRoomDataWrapper.isLoadGameRoom(ANNetwork.room);
    }
    ANETUtils.isLoadGameRoom = isLoadGameRoom;
    // * Текущая комната - уже запущенная игра?
    function isStartedRoom() {
        // @ts-ignore
        if (!ANNetwork.isConnected() || !ANNetwork.room)
            return false;
        // @ts-ignore
        return NetRoomDataWrapper.isStartedGameRoom(ANNetwork.room);
    }
    ANETUtils.isStartedRoom = isStartedRoom;
    function getActorFaceForNetwork(actor) {
        try {
            if (actor && actor.meta && actor.meta.faceForNetwork) {
                return actor.meta.faceForNetwork;
            }
            else {
                return "faceNoActor";
            }
        }
        catch (e) {
            console.warn(e);
            return "faceNoActor";
        }
    }
    ANETUtils.getActorFaceForNetwork = getActorFaceForNetwork;
    // * Получить общие данные о игре для сети (комнаты)
    // * (используется при создании комнаты)
    function getNetworkGameInfoData() {
        return {
            id: getGameVersion(),
            title: $dataSystem.gameTitle,
            version: KDX.isMZ() ? 0 : 1,
            //@ts-ignore
            maxPlayers: ANET.PP.maxPlayersInRoom(),
            mode: 0
        };
    }
    ANETUtils.getNetworkGameInfoData = getNetworkGameInfoData;
})(ANETUtils || (ANETUtils = {}));
window['ANETUtils'] = ANETUtils;
// For compatibility
ANET['Utils'] = ANETUtils;


// * This class is responsible for synchronization and processing of game maps
var ANMapManager;
(function (ANMapManager) {
    //? COMMAND REQUESTS (sent to the server)
    // * ===============================================================
    function sendMapLoaded() {
        ANNetwork.send(NetMessage.Map("loaded", $gameMap.mapId()));
    }
    ANMapManager.sendMapLoaded = sendMapLoaded;
    function sendInitialMapData() {
        // * Forcefully send your data to all players on the map
        //@ts-ignore
        ANSyncDataManager.sendPlayerObserver();
        //@ts-ignore
        ANPlayersManager.sendPlayerLocation();
        //@ts-ignore
        if (ANGameManager.isMapMaster()) {
            sendMapEventsInitialPositions();
        }
    }
    ANMapManager.sendInitialMapData = sendInitialMapData;
    function sendEventMove(eventId) {
        try {
            const event = $gameMap.event(eventId);
            if (!event)
                return;
            const data = {
                id: eventId,
                mapId: $gameMap.mapId(),
                //@ts-ignore
                data: event.getMoveDataForNetwork()
            };
            ANNetwork.send(NetMessage.Map("eventMove", data), true);
        }
        catch (e) {
            console.warn(e);
        }
    }
    ANMapManager.sendEventMove = sendEventMove;
    // * This command is executed only by the map master when someone connects to the map
    function sendMapEventsInitialPositions() {
        for (const ev of $gameMap.events()) {
            if (!ev)
                continue;
            const eventId = ev.eventId();
            setTimeout(() => {
                ANMapManager.sendEventMove(eventId);
            }, 50);
        }
    }
    //? CALLBACKS FROM SERVER REQUESTS
    // * ===============================================================
    function onEventMove(mapId, eventId, moveData) {
        try {
            if ($gameMap.mapId() !== mapId)
                return;
            //@ts-ignore
            if (SceneManager.isBusyForNetworkData())
                return;
            const event = $gameMap.event(eventId);
            //@ts-ignore
            event === null || event === void 0 ? void 0 : event.moveStraightFromServer(moveData);
        }
        catch (e) {
            console.warn(e);
        }
    }
    ANMapManager.onEventMove = onEventMove;
    function onInitialMapSync() {
        try {
            sendInitialMapData();
        }
        catch (e) {
            console.warn(e);
        }
    }
    ANMapManager.onInitialMapSync = onInitialMapSync;
})(ANMapManager || (ANMapManager = {}));
// Assign the namespace to the global window object
window.ANMapManager = ANMapManager;


var ANNetwork;
(function (ANNetwork) {
    let socket = null;
    let client = null;
    ANNetwork.room = null;
    let _isHost = false;
    let _isWaitServer = false;
    function isConnected() {
        return !!socket;
    }
    ANNetwork.isConnected = isConnected;
    function myId() {
        return socket === null || socket === void 0 ? void 0 : socket.id;
    }
    ANNetwork.myId = myId;
    function isMasterClient() {
        return _isHost === true;
    }
    ANNetwork.isMasterClient = isMasterClient;
    /**
     * Игроки могут находиться на одной карте
     */
    function isSameMapMode() {
        // User defined by nAPI call
        //@ts-ignore
        if ($gameSystem && $gameSystem.nWaitTransferModeState) {
            //@ts-ignore
            return $gameSystem.nWaitTransferModeState === true;
        }
        else {
            // Default from PP
            //@ts-ignore
            return ANET.PP.isOnlySameMapMode();
        }
    }
    ANNetwork.isSameMapMode = isSameMapMode;
    /**
     * Надо ждать сеть
     */
    function isBusy() {
        //@ts-ignore
        return isConnected() && (isWaitServer() || ANGameManager.isShouldWaitServer());
    }
    ANNetwork.isBusy = isBusy;
    /**
     * Ждёт ответ от сервера
     */
    function isWaitServer() {
        return isConnected() && _isWaitServer === true;
    }
    ANNetwork.isWaitServer = isWaitServer;
    /**
     * Включить вручную ожидание сервера
     */
    function setWait() {
        _isWaitServer = true;
    }
    ANNetwork.setWait = setWait;
    /**
     * Отключить вручную ожидание сервера
     */
    function resetWait() {
        _isWaitServer = false;
    }
    ANNetwork.resetWait = resetWait;
    /**
     * Initial system setup
     */
    function initSystem() {
        socket = null;
        client = null;
        resetWait();
        _isHost = false;
    }
    ANNetwork.initSystem = initSystem;
    /**
     * Stop the network connection
     */
    function stop() {
        //@ts-ignore
        NetClientMethodsManager.setConnectionToMasterCallback(null);
        client === null || client === void 0 ? void 0 : client.disconnect();
        resetWait();
        socket = null;
        //@ts-ignore
        ANGameManager.reset();
    }
    ANNetwork.stop = stop;
    /**
     * Start the network connection
     */
    function startConnection() {
        //@ts-ignore
        const ip = ANET.PP.serverIp();
        //@ts-ignore
        let port = ANET.PP.serverPort();
        let protocol = "http://";
        let options = {};
        //@ts-ignore
        if (ANET.PP.isHTTPSConnection() === true) {
            LL.log("Using HTTPS secure connection");
            protocol = "https://";
            options = {
                secure: true,
                reconnect: true,
                rejectUnauthorized: false
            };
            if (port === "3034" && (ip === "anetzglobal.ru" || ip === "195.161.41.20")) {
                LL.warn("You try connect via HTTPS connection with port 3034 (http)");
                LL.warn("Port changed to 3035. Check Connection plugin parameter");
                port = 3035;
            }
        }
        const adr = `${protocol}${ip}:${port}`;
        LL.log(`Connecting to ${adr}`);
        //@ts-ignore
        socket = io(adr, options);
        //@ts-ignore
        client = new NetworkClientHandler(socket);
    }
    ANNetwork.startConnection = startConnection;
    function setConnection(callback) {
        //@ts-ignore
        NetClientMethodsManager.setConnectionToMasterCallback(callback);
        startConnection();
    }
    ANNetwork.setConnection = setConnection;
    /**
     * Просто отправить данные на сервер
     */
    function send(msg, noLog = false) {
        if (!isConnected()) {
            LL.warn("You try send message, but there is no connection!");
        }
        else {
            if (!noLog)
                LL.debug(`Send: ${msg.fullName()}`);
            msg.setFrom(socket.id).send();
        }
    }
    ANNetwork.send = send;
    /**
     * Отправить сообщение и ждать результат (есть Timeout)
     * (тут данные должен обратно отправить именно сам сервер)
     */
    function get(msg, onData, onTimeout, timeoutTime = 2000) {
        if (!isConnected()) {
            LL.warn("You try send message, but there is no connection!");
        }
        else {
            const msgName = msg.fullName();
            setWait();
            //@ts-ignore
            HUIManager.showLoader();
            const _onTimeout = (...args) => {
                LL.warn(`Timeout for: ${msgName}`);
                if (onTimeout)
                    onTimeout(...args);
                resetWait();
                //@ts-ignore
                HUIManager.hideLoader();
            };
            const _onData = (...args) => {
                LL.debug(`Response (get) for: ${msgName}`);
                if (onData)
                    onData(...args);
                resetWait();
                //@ts-ignore
                HUIManager.hideLoader();
            };
            LL.debug(`Send, get!: ${msgName}`);
            msg.setFrom(socket.id).get(_onData, _onTimeout, timeoutTime);
        }
    }
    ANNetwork.get = get;
    /**
     * Отправить сообщение и вызвать callback, когда придёт ответ
     */
    function callback(msg, method) {
        if (!isConnected()) {
            LL.debug("You try send callback message, but NOT connection!");
        }
        else {
            const msgName = msg.fullName();
            const _method = (...args) => {
                LL.debug(`Callback for: ${msgName}`);
                method(...args);
            };
            LL.debug(`Send, callback: ${msgName}`);
            msg.setFrom(socket.id).callback(_method);
        }
    }
    ANNetwork.callback = callback;
    function trace(text) {
        send(NetMessage.Trace(text, null));
    }
    ANNetwork.trace = trace;
    /**
     * Этот метод вызывается когда создаём комнату
     */
    function setRoomMaster(room) {
        this.room = room;
        _isHost = true;
        LL.debug(`You are Master (host) of room: ${room.name}`);
    }
    ANNetwork.setRoomMaster = setRoomMaster;
    /**
     * Когда подключаемся к комнате
     */
    function setRoomJoin(room) {
        this.room = room;
        _isHost = false;
        LL.debug(`You are joined to room: ${room.name}`);
    }
    ANNetwork.setRoomJoin = setRoomJoin;
    /**
     * Обновить данные комнаты (к которой подключён)
     */
    function onRoomDataFromServer(room) {
        this.room = room;
    }
    ANNetwork.onRoomDataFromServer = onRoomDataFromServer;
    /**
     * Комната была закрыта
     */
    function onRoomClosed() {
        if (!isConnected() || !ANNetwork.room)
            return;
        leaveRoom();
        _isHost = false;
        this.room = null;
    }
    ANNetwork.onRoomClosed = onRoomClosed;
    /**
     * Закрыть комнату (созданную этим клиентом)
     */
    function closeRoom() {
        if (!isMasterClient() || !ANNetwork.room)
            return;
        send(NetMessage.Lobby("closeRoom"));
    }
    ANNetwork.closeRoom = closeRoom;
    /**
     * Покинуть комнату (к которой этот клиент подключился)
     */
    function leaveRoom() {
        if (!ANNetwork.room)
            return;
        //@ts-ignore
        ANGameManager.onLeaveRoom();
        send(NetMessage.Lobby("leaveRoom", ANNetwork.room.name));
    }
    ANNetwork.leaveRoom = leaveRoom;
    /**
     * Запросить данные о игроках в комнате
     */
    function requestRoomRefresh() {
        if (!isConnected())
            return;
        send(NetMessage.Lobby("getRoomData"));
    }
    ANNetwork.requestRoomRefresh = requestRoomRefresh;
})(ANNetwork || (ANNetwork = {}));
window['ANNetwork'] = ANNetwork;


// * This namespace is responsible for synchronization and processing of player data and their characters
var ANPlayersManager;
(function (ANPlayersManager) {
    //? COMMAND REQUESTS (sent to the server)
    // * ===============================================================
    function sendBindActorFromGame(actorId) {
        ANNetwork.callback(NetMessage.Game("bindActor", actorId), bindActorResult);
    }
    ANPlayersManager.sendBindActorFromGame = sendBindActorFromGame;
    function sendBindActorFromLobby(actorId, callback) {
        ANNetwork.callback(NetMessage.Game("bindActor", actorId), callback);
    }
    ANPlayersManager.sendBindActorFromLobby = sendBindActorFromLobby;
    function sendPlayerName() {
        //@ts-ignore
        ANNetwork.send(NetMessage.Lobby("setPlayerName", ANGameManager.myPlayerData().name));
    }
    ANPlayersManager.sendPlayerName = sendPlayerName;
    function sendPlayerInRoomReady(isReady) {
        ANNetwork.send(NetMessage.Lobby("playerReady", isReady));
    }
    ANPlayersManager.sendPlayerInRoomReady = sendPlayerInRoomReady;
    function sendActorReady() {
        //@ts-ignore
        const actorData = $gameActors.actor(ANGameManager.myPlayerData().actorId);
        ANNetwork.send(NetMessage.Game("actorReady", actorData));
        //@ts-ignore
        ANGameManager.setWait('playersActors');
    }
    ANPlayersManager.sendActorReady = sendActorReady;
    function sendPlayerMove() {
        const data = {
            id: ANNetwork.myId(),
            //@ts-ignore
            data: $gamePlayer.getMoveDataForNetwork()
        };
        ANNetwork.send(NetMessage.Map("playerMove", data), true);
    }
    ANPlayersManager.sendPlayerMove = sendPlayerMove;
    function sendPlayerLocation() {
        const data = {
            id: ANNetwork.myId(),
            data: [$gamePlayer.x, $gamePlayer.y]
        };
        ANNetwork.send(NetMessage.Map("playerLocation", data));
    }
    ANPlayersManager.sendPlayerLocation = sendPlayerLocation;
    //? CALLBACKS FROM SERVER REQUESTS
    // * ===============================================================
    function bindActorResult(result) {
        // If true - reserved, further either customization or sending
        // client is ready to start the game (and waiting for players is enabled)
        // false - means this character is occupied, need to handle!
        if (result === true) {
            console.debug("BINDING GOOD, send ActorReady");
            //@ts-ignore
            ANGameManager.onPlayerCharacterIsBinded();
            sendActorReady();
        }
    }
    ANPlayersManager.bindActorResult = bindActorResult;
    function onPlayerMove(id, moveData) {
        try {
            //@ts-ignore
            if (SceneManager.isBusyForNetworkData())
                return;
            //@ts-ignore
            const char = $gameMap.networkCharacterById(id);
            char === null || char === void 0 ? void 0 : char.moveStraightFromServer(moveData);
        }
        catch (e) {
            console.warn(e);
        }
    }
    ANPlayersManager.onPlayerMove = onPlayerMove;
    function onPlayerLocation(id, positionData) {
        try {
            //@ts-ignore
            const char = $gameMap.networkCharacterById(id);
            char === null || char === void 0 ? void 0 : char.setPosition(positionData[0], positionData[1]);
        }
        catch (e) {
            console.warn(e);
        }
    }
    ANPlayersManager.onPlayerLocation = onPlayerLocation;
})(ANPlayersManager || (ANPlayersManager = {}));
// Assign the namespace to the global window object
window.ANPlayersManager = ANPlayersManager;


/**
 * Данный класс отвечает за методы передачи, обработки и
 * синхронизации игровых данных (и Observers)
 * @[GLOBAL]
 */
var ANSyncDataManagerNamespace;
(function (ANSyncDataManagerNamespace) {
    // ? КОМАНДЫ ЗАПРОСЫ (посылаются на сервер)
    // * ===============================================================
    function sendPlayerObserver() {
        _sendObserverData('playerChar', ANNetwork.myId(), 
        //@ts-ignore
        $gamePlayer.getObserverDataForNetwork());
    }
    ANSyncDataManagerNamespace.sendPlayerObserver = sendPlayerObserver;
    function sendEventObserver(eventId) {
        _sendObserverData('eventChar', {
            mapId: $gameMap.mapId(),
            eventId: eventId
        }, 
        //@ts-ignore
        $gameMap.event(eventId).getObserverDataForNetwork());
    }
    ANSyncDataManagerNamespace.sendEventObserver = sendEventObserver;
    function sendActorObserver() {
        _sendObserverData('playerActor', ANNetwork.myId(), 
        // @ts-ignore
        $gameParty.leader().getObserverDataForNetwork());
    }
    ANSyncDataManagerNamespace.sendActorObserver = sendActorObserver;
    // TODO: через GET ? или callback
    function sendBattleUnitsObserver(members) {
        //@ts-ignore
        if ($gameParty.isOneBattler())
            return;
        const observers = members.map(m => [
            m.packForNetwork(),
            m.getObserverDataForNetwork()
        ]);
        _sendObserverData('battleUnits', null, observers);
    }
    ANSyncDataManagerNamespace.sendBattleUnitsObserver = sendBattleUnitsObserver;
    function sendBattlerObserver(battler) {
        console.log("SEND BATTLER OBSERVER");
        _sendObserverData('battler', battler.packForNetwork(), battler.getObserverDataForNetwork());
    }
    ANSyncDataManagerNamespace.sendBattlerObserver = sendBattlerObserver;
    function sendBattlerResultObserver(battler) {
        console.log("SEND BATTLER RESULT");
        //@ts-ignore
        if ($gameParty.isOneBattler())
            return;
        _sendObserverData('battlerResult', battler.packForNetwork(), battler.result().getObserverDataForNetwork());
    }
    ANSyncDataManagerNamespace.sendBattlerResultObserver = sendBattlerResultObserver;
    function _sendObserverData(type, id, observerData) {
        const data = {
            type: type,
            id: id,
            data: observerData
        };
        ANNetwork.send(NetMessage.Game("observer", data), true);
    }
    // TODO: Может отправлять изменение на мастера, он уже все глобальные переменные всем отправляет
    function sendGlobalVariableChange(varId, newValue) {
        const data = {
            id: varId,
            data: newValue
        };
        ANNetwork.send(NetMessage.Game("variable", data));
    }
    ANSyncDataManagerNamespace.sendGlobalVariableChange = sendGlobalVariableChange;
    function sendGlobalSwitchChange(switchId, newValue) {
        const data = {
            id: switchId,
            data: newValue
        };
        ANNetwork.send(NetMessage.Game("switch", data));
    }
    ANSyncDataManagerNamespace.sendGlobalSwitchChange = sendGlobalSwitchChange;
    function sendSyncGlobalVariables() {
        // TODO: Синхронизация всех глобальных переменных
        // см. $gameVariables.getAllGlobalVariablesData()
    }
    ANSyncDataManagerNamespace.sendSyncGlobalVariables = sendSyncGlobalVariables;
    // ? CALLBACKS ОТ ЗАПРОСОВ НА СЕРВЕР
    // * ===============================================================
    function onObserverData(id, type, content) {
        switch (type) {
            case 'playerChar':
                _onPlayerCharObserverData(id, content);
                break;
            case 'eventChar':
                _onEventCharObserverData(id, content);
                break;
            case 'playerActor':
                _onPlayerActorObserverData(id, content);
                break;
            case 'battler':
                _onBattlerObserverData(id, content);
                break;
            case 'battlerResult':
                _onBattlerResultObserverData(id, content);
                break;
            case 'battleUnits':
                _onBattleUnitsObserverData(content);
                break;
            default:
                console.warn("From server: unknown observer data type: " + type);
        }
    }
    ANSyncDataManagerNamespace.onObserverData = onObserverData;
    function _onPlayerCharObserverData(id, content) {
        try {
            //@ts-ignore
            const char = $gameMap.networkCharacterById(id);
            char === null || char === void 0 ? void 0 : char.applyObserverData(content);
        }
        catch (e) {
            console.warn(e);
        }
    }
    function _onEventCharObserverData(id, content) {
        try {
            const { mapId, eventId } = id;
            if ($gameMap.mapId() !== mapId)
                return;
            const event = $gameMap.event(eventId);
            //@ts-ignore
            event === null || event === void 0 ? void 0 : event.applyObserverData(content);
        }
        catch (e) {
            console.warn(e);
        }
    }
    function _onPlayerActorObserverData(id, content) {
        try {
            // * Если событие перевело выбор персонажа в локальный режим
            // * то ставим специальный флаг что сейчас идёт обращение только
            // * к сетевому персонажу
            if ($gameTemp['_nLocalActorMode'] === true) {
                $gameTemp['_nNetworkActorPickRequest'] = true;
            }
            //@ts-ignore
            const player = ANGameManager.getPlayerDataById(id);
            const actor = NetPlayerDataWrapper.getActorForPlayer(player);
            // * На всякий случай сниму флаг
            $gameTemp['_nNetworkActorPickRequest'] = false;
            if (!actor)
                return;
            _convertActorEquipmens(content);
            //@ts-ignore
            actor.applyObserverData(content);
        }
        catch (e) {
            console.warn(e);
        }
    }
    function _onBattlerObserverData(battlerNetData, content) {
        try {
            if (!$gameParty.inBattle())
                return;
            const battler = ANETUtils.unpackBattlerFromNetwork(battlerNetData);
            if (!battler)
                return;
            _convertActorEquipmens(content);
            //@ts-ignore
            battler.applyObserverData(content);
        }
        catch (e) {
            console.warn(e);
        }
    }
    function _convertActorEquipmens(content) {
        if (!content._equips)
            return;
        for (let i = 0; i < content._equips.length; i++) {
            const itemData = content._equips[i];
            //@ts-ignore
            const gameItem = new Game_Item();
            gameItem._dataClass = itemData._dataClass;
            gameItem._itemId = itemData._itemId;
            content._equips[i] = gameItem;
        }
    }
    function _onBattlerResultObserverData(battlerNetData, content) {
        var _a;
        try {
            if (!$gameParty.inBattle())
                return;
            const battler = ANETUtils.unpackBattlerFromNetwork(battlerNetData);
            if (!battler)
                return;
            //@ts-ignore
            (_a = battler.result()) === null || _a === void 0 ? void 0 : _a.applyObserverData(content);
        }
        catch (e) {
            console.warn(e);
        }
    }
    function _onBattleUnitsObserverData(content) {
        try {
            if (!$gameParty.inBattle())
                return;
            for (const netData of content) {
                const battler = ANETUtils.unpackBattlerFromNetwork(netData[0]);
                if (battler) {
                    _convertActorEquipmens(netData[1]);
                    //@ts-ignore
                    battler.applyObserverData(netData[1]);
                }
            }
            // * Игрок только присоединился, нужен дополнительный refresh графики
            if ($gameTemp['_requestInitialSharedBattleRefresh'] === true) {
                //@ts-ignore
                BattleManager.nRefreshSharedBattleState();
                $gameTemp['_requestInitialSharedBattleRefresh'] = false;
            }
        }
        catch (e) {
            console.warn(e);
        }
    }
    function onVariableValue(varId, value) {
        try {
            //@ts-ignore
            $gameVariables.onVariableFromServer(varId, value);
        }
        catch (e) {
            console.warn(e);
        }
    }
    ANSyncDataManagerNamespace.onVariableValue = onVariableValue;
    function onSwitchValue(varId, value) {
        try {
            //@ts-ignore
            $gameSwitches.onSwitchFromServer(varId, value);
        }
        catch (e) {
            console.warn(e);
        }
    }
    ANSyncDataManagerNamespace.onSwitchValue = onSwitchValue;
})(ANSyncDataManagerNamespace || (ANSyncDataManagerNamespace = {}));
// Экспорт namespace в глобальную область
window['ANSyncDataManager'] = ANSyncDataManagerNamespace;


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ BattleManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__changeActor, ALIAS__update, _;
  //@[DEFINES]
  _ = BattleManager;
  if (KDX.isMZ()) {
    return;
  }
  // * Заместо selectNextActor (нету в MV такой команды)
  //@[ALIAS]
  ALIAS__changeActor = _.changeActor;
  _.changeActor = function() {
    if (ANNetwork.isConnected() && !ANGameManager.isBattleMaster()) {
      this.nSelectNextActorOnClient();
      $gameTemp._isBattleSceneShouldBeRefreshed = true;
    } else {
      ALIAS__changeActor.call(this, ...arguments);
    }
  };
  _.myNetworkActorIndex = function() {
    return $gameParty.members().indexOf($gameParty.leader());
  };
  
  // * В MV логика боя отличается от MZ, не происходит многих автоматических обновлений
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    if (this.__oldPhase !== this._phase) {
      this.__oldPhase = this._phase;
      $gameTemp._isBattleSceneShouldBeRefreshed = true;
      $gameTemp.requestBattleRefresh();
    }
    ALIAS__update.call(this);
  };
})();

// ■ END BattleManager.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ BattleManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__displayStartMessages, ALIAS__endBattle, ALIAS__processEscape, ALIAS__selectNextActor, ALIAS__selectPreviousActor, ALIAS__setup, ALIAS__update, _;
  //@[DEFINES]
  _ = BattleManager;
  //@[ALIAS]
  ALIAS__setup = _.setup;
  _.setup = function() {
    // * Если флаг что необходима Map Encounter битва
    if ($gameTemp.nNextBattleIsEncounter === true) {
      ANBattleManager.executeMapEncounterBattle(...arguments);
      // * Снимаем флаг, чтобы не мешал другим битвам
      $gameTemp.nNextBattleIsEncounter = false;
    }
    ALIAS__setup.call(this, ...arguments);
    if (ANNetwork.isConnected()) {
      if (!ANBattleManager.isBattleRegistred()) {
        // * Только если данные боя не установлены, но проверка сетевой битвы
        this.nSetupNetworkBattle();
      }
    }
  };
  //@[ALIAS]
  ALIAS__endBattle = _.endBattle;
  _.endBattle = function(result) {
    ALIAS__endBattle.call(this, result);
    if (ANNetwork.isConnected()) {
      // * Убрать флаг сетевой битвы
      this.nSetNetworkBattle(null);
    }
  };
  //@[ALIAS]
  ALIAS__selectNextActor = _.selectNextActor;
  _.selectNextActor = function() {
    if (ANNetwork.isConnected() && !ANGameManager.isBattleMaster()) {
      this.nSelectNextActorOnClient();
    } else {
      ALIAS__selectNextActor.call(this);
    }
  };
  //@[ALIAS]
  ALIAS__selectPreviousActor = _.selectPreviousActor;
  _.selectPreviousActor = function() {
    if (ANNetwork.isConnected() && !ANGameManager.isBattleMaster()) {
      this.nSelectPreviousActorOnClient();
    } else {
      ALIAS__selectPreviousActor.call(this);
    }
  };
  //@[ALIAS]
  // * В сетевом режиме Update вызывается только на мастере боя!
  ALIAS__update = _.update;
  _.update = function(activeTime) {
    ALIAS__update.call(this, activeTime);
    if (!ANNetwork.isConnected()) {
      return;
    }
    this.nUpdateNetwork();
  };
  //TEMP
  //TODO: Временно отключено начальное сообщение в бою
  //@[ALIAS]
  ALIAS__displayStartMessages = _.displayStartMessages;
  _.displayStartMessages = function() {
    if (ANNetwork.isConnected()) {

    } else {
      // * EMPTY
      return ALIAS__displayStartMessages.call(this);
    }
  };
  
  //TEMP
  //TODO: Если шанс побега не сработал, будет баг
  // * Временно шанс побега 100%
  //@[ALIAS]
  ALIAS__processEscape = _.processEscape;
  _.processEscape = function() {
    if (ANNetwork.isConnected()) {
      this._escapeRatio = 101;
    }
    return ALIAS__processEscape.call(this);
  };
})();

// ■ END BattleManager.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ BattleManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = BattleManager;
  _.nSetNetworkBattle = function(netBattleId) {
    this.netBattleId = netBattleId;
  };
  _.nIsNetworkBattle = function() {
    return this.netBattleId != null;
  };
  _.nSetupNetworkBattle = function() {
    var battleData;
    if (this.nIsNetworkBattle()) {
      battleData = {
        battleId: this.netBattleId,
        options: [$gameTroop._troopId, this._canEscape, this._canLose]
      };
      ANBattleManager.registerOnBattle(battleData);
    } else {
      ANBattleManager.registerOnLocalBattle();
    }
  };
  _.nSelectNextActorOnClient = function() {
    // * Если данный флаг == true, то игрок переключает меню ввод с группы на персонажа своего
    // * (Это если нажать Escape и появилось Party Commands, а затем снова на Fight)
    if (this._isShouldWaitMyNetworkAction === true) {
      // * Выбираем только своего персонажа снова (а не первого)
      this._currentActor = $gameParty.leader();
      if (KDX.isMV()) {
        this._actorIndex = this.myNetworkActorIndex();
        $gameTemp._isBattleSceneShouldBeRefreshed = true;
      }
      return this._isShouldWaitMyNetworkAction = false;
    } else {
      ANBattleManager.battleInputActionDone();
      return this._inputting = false;
    }
  };
  
  // * В стандартном тактическом режиме боя если нажать "отмена" (назад)
  // * То мы можем поменять выбор предыдущего персонажа, но в сети,
  // * мы не можем это сделать, поэтому просто "выходим" на меню группы
  _.nSelectPreviousActorOnClient = function() {
    return this._currentActor = null;
  };
  _.nUpdateNetwork = function() {
    ANBattleManager.updateInputChange();
    $gameTroop.nUpdateBattleDataSync();
    $gameParty.nUpdateBattleDataSync();
  };
  _.nClearClientInput = function() {
    this._inputting = false;
    this._currentActor = null;
    this._isShouldWaitMyNetworkAction = true;
    if (KDX.isMV()) {
      this.startTurn();
    }
  };
  _.nSetCurrentClientInput = function() {
    $gameParty.makeActions(); // * Чтобы был inputting action
    this._currentActor = $gameParty.leader();
    if (KDX.isMV()) {
      this._actorIndex = this.myNetworkActorIndex();
    }
    // * Готов к отправке действия сразу (по умолчанию)
    // * Команда 'Fight' делает false (см nSelectNextActorOnClient)
    return this._isShouldWaitMyNetworkAction = false;
  };
  _.nRefreshSharedBattleState = function() {
    var e;
    try {
      if (SceneManager._scene.nRefreshSharedBattle != null) {
        SceneManager._scene.nRefreshSharedBattle();
      }
    } catch (error) {
      e = error;
      console.warn(e);
    }
  };
  // * Если во время боя был удалён (вышел) сетевой игрок
  // * Без этого метода, игра переключает (или зависат) ввод другого игрока (который вышел)
  _.nSafeRemoveActor = function() {
    var e;
    if (this._phase !== "input") {
      return;
    }
    try {
      if (this._currentActor !== $gameParty.leader()) {
        return this.selectNextActor();
      }
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
  // * Можно ли клиенту (не BattleMaster) самостоятельно обновлять BattleManager
  _.nIsLocalForceUpdatePhase = function() {
    return this.isAborting() || this.isBattleEnd();
  };
})();

// ■ END BattleManager.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ConfigManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__applyData, ALIAS__makeData, _;
  //@[DEFINES]
  _ = ConfigManager;
  // * Сохранение и загрузка сетевого имени игрока

  //@[ALIAS]
  ALIAS__makeData = _.makeData;
  _.makeData = function() {
    var config;
    config = ALIAS__makeData.call(this);
    config.netPlayerName = this.netPlayerName;
    return config;
  };
  
  //@[ALIAS]
  ALIAS__applyData = _.applyData;
  _.applyData = function(config) {
    ALIAS__applyData.call(this, config);
    this.netPlayerName = config.netPlayerName;
  };
})();

// ■ END ConfigManager.coffee
//---------------------------------------------------------------------------


//╒═════════════════════════════════════════════════════════════════════════╛
// ■ DataManager.ts
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(() => {
    //@[DEFINES]
    const _ = DataManager;
    /**
     * Register NUI file for load with Database
     * @param {string} filnename - NUI file name WITHOUT extension
     */
    function pkdRegisterLocalNUIFile(filnename) {
        KDNUI.RegisterNUIFile("ANETZ", filnename);
    }
    pkdRegisterLocalNUIFile("NUI_NetworkScene");
    pkdRegisterLocalNUIFile("NUI_RoomsListScene");
    pkdRegisterLocalNUIFile("NUI_RoomsListItem");
    pkdRegisterLocalNUIFile("NUI_RoomLobbyScene");
    pkdRegisterLocalNUIFile("NUI_RoomLobbyPlayerItem");
    pkdRegisterLocalNUIFile("NUI_RoomLobbyCharacterItem");
    pkdRegisterLocalNUIFile("NUI_NetworkScene_NewRoomModal");
    pkdRegisterLocalNUIFile("NUI_NetworkScene_SettingsModal");
    //@[ALIAS]
    const ALIAS__loadDataFile = _.loadDataFile;
    _.loadDataFile = function (name, src) {
        if (src.includes("ANETZ")) {
            src = src.replace("Test_", "");
        }
        ALIAS__loadDataFile.call(this, name, src);
    };
})();
// ■ END DataManager.ts
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ DataManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__makeSavefileInfo, _;
  //@[DEFINES]
  _ = DataManager;
  //@[ALIAS]
  ALIAS__makeSavefileInfo = _.makeSavefileInfo;
  _.makeSavefileInfo = function() {
    var info;
    info = ALIAS__makeSavefileInfo.call(this);
    if (ANNetwork.isConnected() && ($gameTemp.nUniqueSaveID != null)) {
      this.nWriteNetworkSaveFileInfo(info);
      // * Сбросим флаг
      $gameTemp.nUniqueSaveID = null;
    }
    return info;
  };
})();

// ■ END DataManager.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ DataManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = DataManager;
  // * Записать информацию о сетевом сохранении (что в этом файле сетевое сохранение)
  _.nWriteNetworkSaveFileInfo = function(info) {
    // * Для определения подходящих файлов у других клиентов
    info.nUniqueSaveID = $gameTemp.nUniqueSaveID;
    // * Для определения своего персонажа
    info.nMyActorId = ANGameManager.myActorId();
  };
  
  // * Является ли файл сохранения сетевым (созданным по сети)
  _.nIsNetworkSaveFile = function(savefileId) {
    var info;
    info = this.nGetInfoForSavefileId(savefileId);
    if ((info != null) && (info.nUniqueSaveID != null) && (info.nMyActorId != null)) {
      return true;
    }
    return false;
  };
  // * Есть ли файл сетевого сохранения с уникальным ID
  _.nIsHaveNetworkSaveWithId = function(uniqueSaveID) {
    return this.nGetNetworkSaveInfoWithId(uniqueSaveID) != null;
  };
  // * Получить данные сетвого сохранения по уникальному ID
  _.nGetNetworkSaveInfoWithId = function(uniqueSaveID) {
    var file, i, index, len, ref;
    ref = this.nGetGlobalInfo();
    for (index = i = 0, len = ref.length; i < len; index = ++i) {
      file = ref[index];
      if (file == null) {
        continue;
      }
      if (this.nIsNetworkSaveFile(index)) {
        if (file.nUniqueSaveID === uniqueSaveID) {
          return file;
        }
      }
    }
    return null;
  };
  // * Получить индекс файла сохранения по уникальнмоу ID
  // * Это нужно для загрузки правильного файла
  _.nGetNetworkSaveFileIdByUniqueId = function(uniqueSaveID) {
    var file, i, index, len, ref;
    ref = this.nGetGlobalInfo();
    for (index = i = 0, len = ref.length; i < len; index = ++i) {
      file = ref[index];
      if (file == null) {
        continue;
      }
      if (this.nIsNetworkSaveFile(index) && file.nUniqueSaveID === uniqueSaveID) {
        return index;
      }
    }
    return -1;
  };
  // * Методы различаются в MV и MZ
  _.nGetGlobalInfo = function() {
    if (KDX.isMZ()) {
      return this._globalInfo;
    } else {
      return this.loadGlobalInfo();
    }
  };
  // * Методы различаются в MV и MZ
  _.nGetInfoForSavefileId = function(savefileId) {
    var info;
    if (KDX.isMZ()) {
      info = DataManager.savefileInfo(savefileId);
    } else {
      info = DataManager.loadSavefileInfo(savefileId);
    }
    return info;
  };
})();

// ■ END DataManager.coffee
//---------------------------------------------------------------------------


class DataObserver {
    constructor(_checkTime = 0, _instante = false) {
        this._fields = {};
        this._isDataChanged = false;
        this._isShouldSkipCheck = false;
        this._timer = 0;
        this._checkTime = _checkTime;
        this._instante = _instante;
    }
    // * отправка без проверки изменений (по таймеру, если задан)
    setInstanteMode() {
        this._instante = true;
    }
    // * проверка изменений (по таймеру, если задан)
    setCheckMode() {
        this._instante = false;
    }
    // * не проверять изменения, устанавливать флаг _isDataChanged сразу (по истечению таймера)
    setCheckInterval(_checkTime) {
        this._checkTime = _checkTime;
    }
    // * Пропустить проверку данных, например когда данные пришли от сервера
    skip() {
        this._isShouldSkipCheck = true;
    }
    clear() {
        this._fields = {};
    }
    addFields(obj, fieldsList) {
        for (let i = 0; i < fieldsList.length; i++) {
            this._readField(obj, fieldsList[i]);
        }
        ;
    }
    removeFields(fieldsList) {
        for (let i = 0; i < fieldsList.length; i++) {
            delete this._fields[fieldsList[i]];
        }
        ;
    }
    // * Прочитать все значения с объекта
    refreshAll(obj) {
        for (const f in this._fields) {
            this._readField(obj, f);
        }
        this._isDataChanged = false;
    }
    _readField(obj, field) {
        this._fields[field] = obj[field];
    }
    check(obj) {
        // * Если данные изменены, но зачем снова проверять?
        // * Всё равно не отслеживается какое именно поле было изменнено
        if (this.isDataChanged())
            return;
        this._timer--;
        // * Если таймер, то ждём, не проверяем
        if (this._timer > 0)
            return;
        this._timer = this._checkTime;
        // * Если надо пропустить проверку, то пропускаем
        if (this._isShouldSkipCheck) {
            this._isShouldSkipCheck = false;
            return;
        }
        // * Если постоянное обновление, то сразу флаг и пропускаем проверку
        if (this._instante) {
            this._isDataChanged = true;
            return;
        }
        for (const f in this._fields) {
            if (obj[f] !== this._fields[f]) {
                this._isDataChanged = true;
                break;
            }
        }
    }
    isDataChanged() {
        return this._isDataChanged;
    }
    // * Получить данные всех полей для отправки на сервер
    getDataForNetwork(obj) {
        this.refreshAll(obj);
        return this._fields;
    }
    // * Установить данные всех полей, когда пришли с сервера
    setDataFromNetwork(obj, observerData) {
        for (const f in this._fields) {
            obj[f] = observerData[f];
        }
        this.refreshAll(obj);
    }
}
window['DataObserver'] = DataObserver;


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_ActionResult.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__initialize, _;
  //@[DEFINES]
  _ = Game_ActionResult.prototype;
  //@[ALIAS]
  ALIAS__initialize = _.initialize;
  _.initialize = function() {
    ALIAS__initialize.call(this);
    if (ANNetwork.isConnected()) {
      return this.nCreateObserver();
    }
  };
})();

// ■ END Game_ActionResult.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_ActionResult.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_ActionResult.prototype;
  _.nCreateObserver = function() {
    this.netDataObserver = new DataObserver();
    this.nFillObserver();
    // * Создаём после nFillObserver, чтобы не было в списке полей Observer
    this.isDataObserverHaveChanges = false;
    this.netDataObserver.refreshAll(this);
  };
  // * Тут применён автоматический сбор всех полей
  _.nFillObserver = function() {
    var entries, fields, i, len, value;
    fields = [];
    entries = Object.entries(this);
    for (i = 0, len = entries.length; i < len; i++) {
      value = entries[i];
      if (value[0] === 'netDataObserver') {
        // * Так как сбор полей идёт после создания netDataObserver, то его надо исключить
        continue;
      }
      fields.push(value[0]);
    }
    this.netDataObserver.addFields(this, fields);
  };
  _.nUpdateObserver = function() {
    if (this.netDataObserver == null) {
      return;
    }
    this.netDataObserver.check(this);
    if (this.netDataObserver.isDataChanged()) {
      this.nDataObserverHaveChanges();
      this.netDataObserver.refreshAll(this);
    }
  };
  // * Тут мы напрямую не отправляем данные, так как мы не знаем кому (Battler) мы принадлежим
  // * Ставится флаг в TRUE, и Battler сам отправить данные
  _.nDataObserverHaveChanges = function() {
    return this.isDataObserverHaveChanges = true;
  };
  _.getObserverDataForNetwork = function() {
    this.isDataObserverHaveChanges = false;
    return this.netDataObserver.getDataForNetwork(this);
  };
  _.applyObserverData = function(data) {
    if (this.netDataObserver == null) {
      return;
    }
    this.netDataObserver.setDataFromNetwork(this, data);
  };
})();

// ■ END Game_ActionResult.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Action.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__apply, _;
  //@[DEFINES]
  _ = Game_Action.prototype;
  //@[ALIAS]
  ALIAS__apply = _.apply;
  _.apply = function(target) {
    if (ANNetwork.isConnected()) {
      if (this.nIsApplyItemFromMenu(target)) {
        this.nSendNetworkActionFromMenu(target);
        return;
      }
    }
    return ALIAS__apply.call(this, ...arguments);
  };
})();

// ■ END Game_Action.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Action.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  // * Глобальный метод класса Game_Action
  Game_Action.NApplyFromMenuFromNetwork = function(data) {
    var action, e, target;
    try {
      if (data == null) {
        return;
      }
      if (data.target == null) {
        return;
      }
      target = ANETUtils.unpackBattlerFromNetwork(data.target);
      // * Только для своего персонажа, т.к. Observer
      if (target !== $gameParty.leader()) {
        return;
      }
      // * Тут используется $gameParty.leader() как заглушка, т.к. должен быть Subject
      action = new Game_Action($gameParty.leader(), true);
      action.setFromNetwork(data.action);
      return action.apply($gameParty.leader());
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
  //@[DEFINES]
  _ = Game_Action.prototype;
  // * Задать действие из сети (т.е. из действия другого игрока)
  _.setFromNetwork = function(action) {
    var f;
    this.clear();
    this._nParseActionItem(action._item);
    for (f in action) {
      if (f === "_item") {
        // * пропускаем Game_Item, он уже сконвертирован
        continue;
      }
      this[f] = action[f];
    }
  };
  // * Класс Game_Item отдельно
  _._nParseActionItem = function(item) {
    var f;
    if (item == null) {
      return;
    }
    for (f in item) {
      this._item[f] = item[f];
    }
  };
  // * Применяется предмет из меню?
  _.nIsApplyItemFromMenu = function(target) {
    return !$gameParty.inBattle() && target !== $gameParty.leader() && ($gameTemp.netApplyItemUser != null);
  };
  _.nSendNetworkActionFromMenu = function(target) {
    var e;
    try {
      return ANGameManager.sendUseItemFromMenuAction(this, target);
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
})();

// ■ END Game_Action.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Actor.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__refresh, ALIAS__setup, _;
  //@[DEFINES]
  _ = Game_Actor.prototype;
  //@[ALIAS]
  ALIAS__setup = _.setup;
  _.setup = function(actorId) {
    ALIAS__setup.call(this, actorId);
    // * Чтобы refreshNetwork не вызывался когда ещё Actor не создан
    if (ANNetwork.isConnected()) {
      this.refreshNetworkDummy = this.refreshNetwork;
      if (ANET.PP.playerActorNameType() > 0) {
        this.nSetupPlayerActorName();
      }
    }
  };
  //@[ALIAS]
  ALIAS__refresh = _.refresh;
  _.refresh = function() {
    ALIAS__refresh.call(this);
    return this.refreshNetworkDummy();
  };
})();

// ■ END Game_Actor.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Actor.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Actor.prototype;
  // * Данный персонаж - мой сетевой персонаж (текущего игрока)
  _.isMyNetworkActor = function() {
    if ($gameTemp._nLocalActorMode === true) {
      // * Тут сделано разделение специально, чтобы уменьшить проблемы с LocalActor
      // * Суть в том, что при LocalActor могут отправляться данные всех персонажей,
      // * так как проверка через leader() обращается в Game_Actors, а ID всегда на
      // * своего персонажа (стоит Instance Mode, в этом ещё дело)
      // * Пока отключил передачу СВОИХ данных в режиме Local
      return false;
    }
    if ($gameParty.inBattle()) {
      return this.isMyNetworkBattler();
    } else {
      return this.actorId() === ANGameManager.myActorId();
    }
  };
  _.updateDataObserver = function() {
    // * Если в бою, то вся синхронизация идёт от мастера битвы
    if ($gameParty.inBattle()) {
      if (ANGameManager.isBattleMaster()) {
        this._updateDataObserver();
      } else {

      }
    } else {
      if (this.isMyNetworkActor()) {
        // * Если НЕ в бою, то проверка observer только свого персонажа
        // * Только приём данных
        this._updateDataObserver();
      }
    }
  };
  // * Отправка Observer только своего персонажа
  _.dataObserverHaveChanges = function() {
    // * Если в бою, то вся синхронизация идёт от мастера битвы
    if ($gameParty.inBattle()) {
      if (ANGameManager.isBattleMaster()) {
        this.requestNetBattleDataPush();
        // * Если только я в бою, то отправляю обычные данные
        // * Чтобы другие игроки видели HP и MP
        // TODO: Опция?
        if ($gameParty.isOneBattler()) {
          ANSyncDataManager.sendActorObserver();
        }
      }
    } else {
      // * Если не в бою, то только свои данные
      if (this.isMyNetworkActor()) {
        ANSyncDataManager.sendActorObserver();
      }
    }
  };
  
  //TODO: Может просто все все свойства передавать?
  // собрать их автоматически
  _._fillNetworkObserver = function() {
    Game_Battler.prototype._fillNetworkObserver.call(this);
    this.netDataObserver.addFields(this, ANETSystem.ActorObserverFields);
  };
  //?{DYNAMIC}
  _.refreshNetworkDummy = function() {}; // * EMPTY
  _.refreshNetwork = function() {
    // * Тут нельзя делать проверку на текущих Actor или нет, так как вызывает Stack Overflow
    // * Метод refresh вызывается ещё до того как Actor создан (класс)
    // * Принудительная отправка
    if (!$gameParty.inBattle()) {
      this.dataObserverHaveChanges();
    }
  };
  // * Установить заместо имени (никнейма) персонажа имя сетевого игрока
  _.nSetupPlayerActorName = function() {
    var playerData;
    // * Устанавливаем только своему персонажу, так как myPlayerData есть в начале игры
    // * Данные других персонажей прийдут сами с Observer сразу
    if (this.actorId() !== ANGameManager.myActorId()) {
      return;
    }
    playerData = ANGameManager.myPlayerData();
    if (playerData == null) {
      return;
    }
    if (ANET.PP.playerActorNameType() === 1) {
      this._name = playerData.name;
    } else if (ANET.PP.playerActorNameType() === 2) {
      this._nickname = playerData.name;
    }
  };
})();

// ■ END Game_Actor.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Actors.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__actor, _;
  //@[DEFINES]
  _ = Game_Actors.prototype;
  //TODO: Есть проблемы у этого способа! Надо больше тестов
  //TODO: Добавить дополнительные проверки, так как слишком опасно
  //@[ALIAS]
  ALIAS__actor = _.actor;
  _.actor = function(actorId) {
    // * Возвращять текущего персонажа для выборки в событии
    // * Выборка LOCAL ACTOR работает только если указан Actor с ID = 1 (ОТМЕНА!)
    //TODO: Может это и не надо, но сделал для меньших проблем, так как метод опасно переопределять
    //TODO: Временно убрал выборку только 1 актора
    if (ANNetwork.isConnected() && $gameTemp._nLocalActorMode === true) { //&& actorId == 1
      if ($gameTemp._nNetworkActorPickRequest === true) {
        $gameTemp._nNetworkActorPickRequest = false;
        return ALIAS__actor.call(this, actorId);
      } else {
        return this._data[ANGameManager.myActorId()];
      }
    } else {
      return ALIAS__actor.call(this, actorId);
    }
  };
})();

// ■ END Game_Actors.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_BattlerBase.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__initMembers, ALIAS__meetsItemConditions, ALIAS__onBattleEnd, ALIAS__onBattleStart, _;
  //@[DEFINES]
  _ = Game_BattlerBase.prototype;
  //@[ALIAS]
  ALIAS__initMembers = _.initMembers;
  _.initMembers = function() {
    ALIAS__initMembers.call(this);
    return this._createNetworkObserver();
  };
  
  //@[ALIAS]
  ALIAS__onBattleStart = _.onBattleStart;
  _.onBattleStart = function() {
    ALIAS__onBattleStart.call(this);
    if (ANNetwork.isConnected()) {
      this.netDataObserver.setCheckMode();
    }
  };
  //@[ALIAS]
  ALIAS__onBattleEnd = _.onBattleEnd;
  _.onBattleEnd = function() {
    ALIAS__onBattleEnd.call(this);
    if (ANNetwork.isConnected()) {
      this.netDataObserver.setInstanteMode();
    }
  };
  //TEMP
  //TODO: Временное решение, так как нет проверки кто именно
  // * Так как вещи другого игрока нет в инвентаре мастера боя, то
  // * мы пропускаем проверку на наличие вещи в инвентаре $gameParty.hasItem(item)
  //@[ALIAS]
  ALIAS__meetsItemConditions = _.meetsItemConditions;
  _.meetsItemConditions = function(item) {
    if (ANNetwork.isConnected()) {
      return this.meetsUsableItemConditions(item);
    } else {
      return ALIAS__meetsItemConditions.call(this, item);
    }
  };
})();

// ■ END Game_BattlerBase.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_BattlerBase.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_BattlerBase.prototype;
  // * Специальное представление данных для сети
  _.packForNetwork = function() {
    return ANETUtils.packBattlerForNetwork(this);
  };
  (function() {    // * OBSERVER
    _._createNetworkObserver = function() {
      this.netDataObserver = new DataObserver();
      this._applyDataObserverInitialParameters();
      this._fillNetworkObserver();
      return this.netDataObserver.refreshAll(this);
    };
    _._applyDataObserverInitialParameters = function() {
      // * Тут нужен Instante, чтобы данные на карте всегда были актуальны
      // * Если CheckMode, то при помощи событий можно менять параметры ХП
      // * всей группы и ХП других игроков будут отображаться не правильно
      this.netDataObserver.setInstanteMode();
      this.netDataObserver.setCheckInterval(ANET.PP.playerDataRefreshRate());
    };
    //TODO: Можно автоматически и удалять лишнее (см. Game_ActionResult)
    _._fillNetworkObserver = function() {
      this.netDataObserver.addFields(this, ["_hp", "_mp", "_tp", "_paramPlus", "_states", "_stateTurns", "_buffs", "_buffTurns"]);
      if (typeof $gameSystem !== "undefined" && $gameSystem !== null) {
        $gameSystem._nSetupUserDefinedObservers(this, 'battler');
      }
    };
    _.nRefreshUserDefinedObservers = function() {
      var e;
      try {
        if (typeof $gameSystem === "undefined" || $gameSystem === null) {
          return;
        }
        if (this.netDataObserver == null) {
          return;
        }
        return this._createNetworkObserver();
      } catch (error) {
        e = error;
        return console.warn(e);
      }
    };
    //TODO: updateStateTurns и баффы не должны выполняться на фантоме (???)

    // * Этот метод должны вызывать потомки верхнего уровня, так как нету Update в этом классе
    _._updateDataObserver = function() {
      if (this.netDataObserver == null) {
        return;
      }
      this.netDataObserver.check(this);
      if (this.netDataObserver.isDataChanged()) {
        this.dataObserverHaveChanges();
        this.netDataObserver.refreshAll(this);
      }
    };
    // * Этот метод вызывается, когда изменились сихнронизируеммые данные
    _.dataObserverHaveChanges = function() {}; // * EMPTY (for childrens)
    _.getObserverDataForNetwork = function() {
      return this.netDataObserver.getDataForNetwork(this);
    };
    _.applyObserverData = function(data) {
      if (this.netDataObserver == null) {
        return;
      }
      this.netDataObserver.setDataFromNetwork(this, data);
    };
  })();
})();

// ■ END Game_BattlerBase.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Battler.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__initialize, ALIAS__onBattleEnd, ALIAS__onBattleStart, ALIAS__startDamagePopup, _;
  //@[DEFINES]
  _ = Game_Battler.prototype;
  //@[ALIAS]
  ALIAS__initialize = _.initialize;
  _.initialize = function() {
    ALIAS__initialize.call(this);
    if (ANNetwork.isConnected()) {
      return this.nInitializeNetwork();
    }
  };
  //@[ALIAS]
  ALIAS__onBattleStart = _.onBattleStart;
  _.onBattleStart = function() {
    if (ANNetwork.isConnected()) {
      this._nStartBattleObserver();
    }
    return ALIAS__onBattleStart.call(this, ...arguments);
  };
  
  //@[ALIAS]
  ALIAS__onBattleEnd = _.onBattleEnd;
  _.onBattleEnd = function() {
    ALIAS__onBattleEnd.call(this);
    if (ANNetwork.isConnected()) {
      this._nEndBattleObserver();
    }
  };
  // * Отдельная реализация, чтобы передавать battleResult
  //@[ALIAS]
  ALIAS__startDamagePopup = _.startDamagePopup;
  _.startDamagePopup = function() {
    if (ANNetwork.isConnected() && ANGameManager.isBattleMaster() && !$gameParty.isOneBattler()) {
      ANSyncDataManager.sendBattlerResultObserver(this);
      ANBattleManager.callBattleMethod(this, "startDamagePopup", null);
    }
    return ALIAS__startDamagePopup.call(this);
  };
})();

// ■ END Game_Battler.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Battler.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Battler.prototype;
  _.nInitializeNetwork = function() {
    this._nRegisterSyncBattleMethod("requestEffect");
    this._nRegisterSyncBattleMethod("requestMotion");
    this._nRegisterSyncBattleMethod("startWeaponAnimation");
    this._nRegisterSyncBattleMethod("setActionState");
    // * Sound effects
    this._nRegisterSyncBattleMethod("performDamage");
    this._nRegisterSyncBattleMethod("performCollapse");
    this._nRegisterSyncBattleMethod("performMiss");
    this._nRegisterSyncBattleMethod("performRecovery");
    this._nRegisterSyncBattleMethod("performEvasion");
    this._nRegisterSyncBattleMethod("performMagicEvasion");
    this._nRegisterSyncBattleMethod("performCounter");
    this._nRegisterSyncBattleMethod("performReflection");
  };
  // * Данный баттлер является моим (этого сетевого игрока)
  _.isMyNetworkBattler = function() {
    if (ANNetwork.isConnected()) {
      return this === $gameParty.leader();
    } else {
      return true;
    }
  };
  // * Подписать метод на синхронизацию через сервер
  _._nRegisterSyncBattleMethod = function(methodName) {
    var alias;
    alias = this[methodName];
    this[methodName] = function() {
      if (ANNetwork.isConnected() && ANGameManager.isBattleMaster()) {
        // * В данной реализации передаётся только один аргумент, так как ... перед arguments
        ANBattleManager.callBattleMethod(this, methodName, ...arguments);
      }
      return alias.call(this, ...arguments);
    };
  };
  _.isNeedNetPushBattleData = function() {
    return this._netBattleObserverNeedToPush === true;
  };
  _.onNetBattleDataPushed = function() {
    return this._netBattleObserverNeedToPush = null;
  };
  _.requestNetBattleDataPush = function() {
    return this._netBattleObserverNeedToPush = true;
  };
  (function() {    // * Специальный Data Observer для боя
    // -----------------------------------------------------------------------
    // * Данные только для боя (эти данные передаёт только Battle Master)
    _._nStartBattleObserver = function() {
      // * Включаем Instance режим
      //@netDataObserver.setInstanteMode()
      this.netDataObserver.setCheckInterval(ANET.PP.battleDataRefreshRate());
      this._addBattleFieldsToNetowrkDataObserver();
    };
    // * Добавляем дополнительные поля в Observer
    _._addBattleFieldsToNetowrkDataObserver = function() {
      this.netDataObserver.addFields(this, ANETSystem.BattlerObserverFields);
    };
    // * После битвы нет необходимости хранить observer
    return _._nEndBattleObserver = function() {
      // * Возвращаем режим проверки
      this._applyDataObserverInitialParameters();
      // * Убираем добавленные для боя поля
      this.netDataObserver.removeFields(this, ANETSystem.BattlerObserverFields);
    };
  })();
})();

// ■ END Game_Battler.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_CharacterBase.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__initMembers, ALIAS__isCollidedWithCharacters, ALIAS__update, _;
  //@[DEFINES]
  _ = Game_CharacterBase.prototype;
  //@[ALIAS]
  ALIAS__initMembers = _.initMembers;
  _.initMembers = function() {
    ALIAS__initMembers.call(this);
    return this._createNetworkObserver();
  };
  
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    ALIAS__update.call(this);
    if (ANNetwork.isConnected()) {
      return this._updateDataObserver();
    }
  };
  //@[ALIAS]
  ALIAS__isCollidedWithCharacters = _.isCollidedWithCharacters;
  _.isCollidedWithCharacters = function(x, y) {
    var result;
    result = ALIAS__isCollidedWithCharacters.call(this, ...arguments);
    if (ANNetwork.isConnected() && ANET.PP.isAllowCollsBetweenNetChars()) {
      return result || $gameMap.netCharsIsSomeoneCollided(x, y);
    }
    return result;
  };
})();

// ■ END Game_CharacterBase.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_CharacterBase.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_CharacterBase.prototype;
  // * MoveRoute команда для движения события
  _.moveTowardNetworkChar = function(netCharShortcut) {
    var e;
    try {
      if (!ANNetwork.isConnected()) {
        return;
      }
      return this._netMoveTarget = netCharShortcut;
    } catch (error) {
      e = error;
      console.warn(e);
      return this._netMoveTarget = null;
    }
  };
  (function() {    // * OBSERVER
    _._createNetworkObserver = function() {
      this.netDataObserver = new DataObserver();
      this.netDataObserver.setCheckInterval(ANET.PP.playerDataRefreshRate());
      this._fillNetworkObserver();
      return this.netDataObserver.refreshAll(this);
    };
    //TODO: Добавить API для разработчиков плагинов вносить свои поля (и так со всем Observers)
    // * Движение передаётся отдельным методом для достижения плавности
    _._fillNetworkObserver = function() {
      this.netDataObserver.addFields(this, ["_opacity", "_blendMode", "_walkAnime", "_stepAnime", "_directionFix", "_transparent", "_direction", "_characterName", "_characterIndex"]);
      if (typeof $gameSystem !== "undefined" && $gameSystem !== null) {
        $gameSystem._nSetupUserDefinedObservers(this, 'character');
      }
    };
    _.nRefreshUserDefinedObservers = function() {
      var e;
      try {
        if (typeof $gameSystem === "undefined" || $gameSystem === null) {
          return;
        }
        if (this.netDataObserver == null) {
          return;
        }
        return this._createNetworkObserver();
      } catch (error) {
        e = error;
        return console.warn(e);
      }
    };
    _._updateDataObserver = function() {
      if (this.netDataObserver == null) {
        return;
      }
      this.netDataObserver.check(this);
      if (this.netDataObserver.isDataChanged()) {
        this.dataObserverHaveChanges();
        this.netDataObserver.refreshAll(this);
      }
    };
    // * Этот метод вызывается, когда изменились сихнронизируеммые данные
    _.dataObserverHaveChanges = function() {}; // * EMPTY (for childrens)
    _.getObserverDataForNetwork = function() {
      return this.netDataObserver.getDataForNetwork(this);
    };
    _.applyObserverData = function(data) {
      if (this.netDataObserver == null) {
        return;
      }
      this.netDataObserver.setDataFromNetwork(this, data);
    };
  })();
  _.moveStraightFromServer = function(moveData) {
    // * Всегда успех, так как если нет, то данные и не прийдут от другого игрока
    this.setMovementSuccess(true);
    this.setDirection(moveData.direction);
    this._x = moveData.x;
    this._y = moveData.y;
    this._realX = moveData.realX;
    this._realY = moveData.realY;
    // * Чтобы синхронизировать правильно бег
    this._moveSpeed = moveData.moveSpeed;
    this.increaseSteps();
  };
  _.getMoveDataForNetwork = function() {
    return {
      direction: this._direction,
      moveSpeed: this.realMoveSpeed(),
      x: this.x,
      y: this.y,
      realX: this._realX,
      realY: this._realY
    };
  };
})();

// ■ END Game_CharacterBase.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Enemy.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Enemy.prototype;
})();

// ■ END Game_Enemy.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Enemy.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Enemy.prototype;
  //TODO: Есть проблема, dead enemies не исчезают у второго игрока

  // * Дополнительные найстройки Observer для врагов
  _._addBattleFieldsToNetowrkDataObserver = function() {
    Game_Battler.prototype._addBattleFieldsToNetowrkDataObserver.call(this);
    // * Данные поля не нужны (наверное) врагам, так как не видно их полосу
    this.netDataObserver.removeFields(this, ["_tpbChargeTime"]);
  };
  // * Только мастер битвы может отправлять данные (вызывается из Scene_Battle)
  _.updateDataObserver = function() {
    if ($gameParty.inBattle() && ANGameManager.isBattleMaster()) {
      this._updateDataObserver();
    }
  };
  _.dataObserverHaveChanges = function() {
    if ($gameParty.inBattle() && ANGameManager.isBattleMaster()) {
      this.requestNetBattleDataPush();
    }
  };
  // * Добавляем свои поля
  _._fillNetworkObserver = function() {
    Game_Battler.prototype._fillNetworkObserver.call(this);
    this.netDataObserver.addFields(this, ANETSystem.EnemyObserverFields);
  };
})();

// ■ END Game_Enemy.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Event.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS___fillNetworkObserver, ALIAS__initMembers, ALIAS__isNearTheScreen, ALIAS__updateSelfMovementNNX, _;
  //@[DEFINES]
  _ = Game_Event.prototype;
  // * Следование за Network Character
  // -----------------------------------------------------------------------

  //@[ALIAS]
  ALIAS__initMembers = _.initMembers;
  _.initMembers = function() {
    ALIAS__initMembers.call(this, ...arguments);
    this._netMoveTarget = null;
  };
  //@[ALIAS]
  ALIAS___fillNetworkObserver = _._fillNetworkObserver;
  _._fillNetworkObserver = function() {
    ALIAS___fillNetworkObserver.call(this, ...arguments);
    this.netDataObserver.addFields(this, ['_netMoveTarget']);
  };
  //@[ALIAS]
  ALIAS__updateSelfMovementNNX = _.updateSelfMovement;
  _.updateSelfMovement = function() {
    var char;
    ALIAS__updateSelfMovementNNX.call(this, ...arguments);
    if (this._netMoveTarget == null) {
      return;
    }
    if (!this._locked && this.isNearTheScreen() && this.checkStop(this.stopCountThreshold())) {
      char = ANETUtils.getNetworkCharByShortcut(this._netMoveTarget);
      if (char != null) {
        this.nMoveTypeTowardNetworkCharacter(char);
      } else {
        console.warn("Can't get Network Character for " + this._netMoveTarget);
        this._netMoveTarget = null;
      }
    }
  };
  //@[ALIAS]
  ALIAS__isNearTheScreen = _.isNearTheScreen;
  _.isNearTheScreen = function() {
    if (ANNetwork.isConnected()) {
      return true;
    } else {
      return ALIAS__isNearTheScreen.call(this, ...arguments);
    }
  };
  (function() {    
    // * Синхронизация движения
    // -----------------------------------------------------------------------
    var ALIAS__moveDiagonally, ALIAS__moveStraight, ALIAS__updateSelfMovement;
    //@[ALIAS]
    ALIAS__moveStraight = _.moveStraight;
    _.moveStraight = function(d) {
      if (ANNetwork.isConnected()) {
        if (ANGameManager.isMapMaster()) {
          // * Запоминаем предыдующие координаты (перед движением)
          this.___x = this.x;
          this.___y = this.y;
          // * Движение
          ALIAS__moveStraight.call(this, d);
          // * Если координаты сменились, значит персонаж
          // совершил движение, можно отправить на сервер
          if (this.___x !== this.x || this.___y !== this.y) {
            return ANMapManager.sendEventMove(this.eventId());
          }
        } else {

        }
      } else {
        // * SKIP MOVEMENT
        // * Движение событий выполняется только на мастере карты
        return ALIAS__moveStraight.call(this, d);
      }
    };
    
    //@[ALIAS]
    ALIAS__moveDiagonally = _.moveDiagonally;
    _.moveDiagonally = function(horz, vert) {
      if (ANNetwork.isConnected()) {
        if (ANGameManager.isMapMaster()) {
          // * Запоминаем предыдующие координаты (перед движением)
          this.___x = this.x;
          this.___y = this.y;
          // * Движение
          ALIAS__moveDiagonally.call(this, horz, vert);
          // * Если координаты сменились, значит персонаж
          // совершил движение, можно отправить на сервер
          if (this.___x !== this.x || this.___y !== this.y) {
            ANMapManager.sendEventMove(this.eventId());
          }
        } else {

        }
      } else {
        // * SKIP MOVEMENT
        // * Движение событий выполняется только на мастере карты
        ALIAS__moveDiagonally.call(this, horz, vert);
      }
    };
    //@[ALIAS]
    ALIAS__updateSelfMovement = _.updateSelfMovement;
    return _.updateSelfMovement = function() {
      if (ANNetwork.isConnected()) {
        if (ANGameManager.isMapMaster()) {
          return ALIAS__updateSelfMovement.call(this);
        } else {

        }
      } else {
        // * NOTHING
        // * Обновление движения события только на мастере карты
        return ALIAS__updateSelfMovement.call(this);
      }
    };
  })();
})();

// ■ END Game_Event.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Event.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Event.prototype;
  _.dataObserverHaveChanges = function() {
    if (ANGameManager.isMapMaster()) {
      ANSyncDataManager.sendEventObserver(this.eventId());
    }
  };
  // * Если мы не отправляем данные Observer,
  // * то check не будет работать, пока не сбросить флаг
  _.nMoveTypeTowardNetworkCharacter = function(char) {
    var e;
    try {
      if (char == null) {
        return;
      }
      return this.moveTowardCharacter(char);
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
})();

// ■ END Game_Event.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Followers.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__isSomeoneCollided, ALIAS__setup, _;
  //@[DEFINES]
  _ = Game_Followers.prototype;
  //@[ALIAS]
  ALIAS__setup = _.setup;
  _.setup = function() {
    if (ANNetwork.isConnected()) {
      return this._data = [];
    } else {
      // * Нет последователей! Используется другой класс
      return ALIAS__setup.call(this);
    }
  };
  
  // * Учёт коллизий с сетевыми игроками при движении событий
  // * В этом методе, а не в NETCharactersGroup, чтобы было больше совместимости
  //@[ALIAS]
  ALIAS__isSomeoneCollided = _.isSomeoneCollided;
  _.isSomeoneCollided = function(x, y) {
    if (ANNetwork.isConnected()) {
      return $gameMap.netCharsIsSomeoneCollided(x, y);
    } else {
      return ALIAS__isSomeoneCollided.call(this, x, y);
    }
  };
})();

// ■ END Game_Followers.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Interpreter.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Interpreter.prototype;
  (function() {    // * Статус запуска события
    // -----------------------------------------------------------------------
    var ALIAS__clear, ALIAS__initialize, ALIAS__setup, ALIAS__update, ALIAS__updateWaitMode;
    //@[ALIAS]
    ALIAS__initialize = _.initialize;
    _.initialize = function(depth) {
      ALIAS__initialize.call(this, depth);
      this._nRunningCheckTimer = 0;
      // * Отключаем некоторые команды
      if (ANNetwork.isConnected()) {
        this.nDisableNotNetCommands();
      }
    };
    //@[ALIAS]
    ALIAS__setup = _.setup;
    _.setup = function(list, eventId) {
      var ref;
      ALIAS__setup.call(this, list, eventId);
      if (ANNetwork.isConnected()) {
        // * Сброс сетевой битвы, если началось другое событие
        BattleManager.nSetNetworkBattle(null);
        this.nCheckEventStartOptions();
        if (!this.isPassStartOptions()) { // * Проверка опций запуска события
          if (this.nIsAutorunEvent()) {
            // * Turn off Auto trigger for Event
            if ((ref = $gameMap.event(eventId)) != null) {
              ref._trigger = 0;
            }
          }
          // * Выключаем Auto триггер, чтобы игра не циклилась
          // * игра зацикливается, т.к. нет EraseEvent или
          // * переключения страницы, ведь мы подменяем на
          // * пустой лист команд
          this._list = []; // * Не будет выполняться
        } else {
          if (!this.nIsParallelEvent()) {
            ANInterpreterManager.sendEventStarted(eventId);
          }
          if (this.nIsEventIsShared()) {
            this.nPrepareSharedEvent();
          }
          this.nClearFlags();
        }
      }
    };
    
    //@[ALIAS]
    ALIAS__clear = _.clear;
    _.clear = function() {
      if (ANNetwork.isConnected()) {
        if (!this.nIsParallelEvent()) {
          ANInterpreterManager.eventProcessExit();
        }
        this.nClearFlags();
      }
      ALIAS__clear.call(this);
    };
    //@[ALIAS]
    ALIAS__update = _.update;
    _.update = function() {
      ALIAS__update.call(this);
      if (ANNetwork.isConnected() && !this.nIsParallelEvent()) {
        this._nRunningCheckTimer++;
        if (this._nRunningCheckTimer >= 60) {
          ANInterpreterManager.checkEventRunning();
          this._nRunningCheckTimer = 0;
        }
      }
    };
    //@[ALIAS]
    ALIAS__updateWaitMode = _.updateWaitMode;
    return _.updateWaitMode = function() {
      if (this._waitMode === 'netPlayersPool') {
        return this.nUpdateWaitPlayersPool();
      } else if (this._waitMode === 'netNextCommand') {
        return this.nUpdateWaitServerNextCommandPermission();
      } else {
        return ALIAS__updateWaitMode.call(this);
      }
    };
  })();
  (function() {    // * Выполнение команд в сети
    // -----------------------------------------------------------------------
    var ALIAS__command108;
    //@[ALIAS, STORED]
    _.ALIAS__executeCommand = _.executeCommand;
    _.executeCommand = function() {
      if (ANNetwork.isConnected()) {
        if (this.nIsOptionsForCurrentCommand()) {
          return this.nProcessCommandWithOptions();
        }
      }
      return _.ALIAS__executeCommand.call(this);
    };
    //TODO: MV
    //@[ALIAS]
    ALIAS__command108 = _.command108;
    return _.command108 = function(params) {
      if (ANNetwork.isConnected()) {
        if (KDX.isMV()) {
          params = this._params;
        }
        // * Проверить комментарий на наличие NET команд
        this._nCheckNetComment(params[0]);
      }
      return ALIAS__command108.call(this, params);
    };
  })();
})();

// ■ END Game_Interpreter.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Interpreter.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//$[ENCODE]
(function() {
  var _;
  // * Используется Virtual Interpreter. Команда от сервера запускается в отдельном Interpreter, а не
  // * в аналогичном событии (как это было в Alpha NET).
  // * Некоторы команды выполняются напрямую, а некоторые через общие события только с одной командой

  //@[DEFINES]
  _ = Game_Interpreter.prototype;
  // * Отключение не подходящих для сети комманд
  _.nDisableNotNetCommands = function() {
    var code, disableCommand, i, len, ref;
    disableCommand = function() {
      return _["command" + code] = function() {
        return true;
      };
    };
    ref = [129, 202, 206, 216, 217, 137];
    // * Change Party Member
    // * Set Vehicle Location
    // * Get on/off Vehicle
    // * Change Player Followers
    // * Gather Followers
    // * Change Formation Access
    for (i = 0, len = ref.length; i < len; i++) {
      code = ref[i];
      disableCommand(code);
    }
  };
  _.nIsHaveCommandOptions = function() {
    return this._nCommandOptionsRequested === true && (this.nCommandStartOptions != null);
  };
  _.nClearCommandOptions = function() {
    this._nCommandOptionsRequested = false;
    return this.nCommandStartOptions = null;
  };
  // * Устанавливаем опции (набор данных) и флаг что надо использовать на следующей команде
  _.nSetCommandOptions = function(nCommandStartOptions) {
    this.nCommandStartOptions = nCommandStartOptions;
    return this._nCommandOptionsRequested = true;
  };
  // * Опции подходят для "текущей" (следующей на выполнение) команды
  _.nIsOptionsForCurrentCommand = function() {
    if (!this.nIsHaveCommandOptions()) {
      return false;
    }
    if (ANETSystem.ForbiddenVirtualCommandsList.contains(this.currentCommand().code)) {
      return false;
    }
    return true;
  };
  // * Проверка опций и выполнение команды в соответсвии с ними
  _.nProcessCommandWithOptions = function() {
    var e;
    try {
      // * Снимаем флаг, что надо использовать опции
      this._nCommandOptionsRequested = false;
      switch (this.nCommandStartOptions.whoSelector) {
        case "All":
          return this._nProcessCommandForAll();
        case "Master":
          return this._nProcessCommandForMaster(true);
        case "Master Except":
          return this._nProcessCommandForMaster(false);
        case "Actor List":
          return this._nProcessCommandForActorsList(true);
        case "Actor List Except":
          return this._nProcessCommandForActorsList(false);
        case "Me Except":
          return this._nProcessCommandNotMe();
      }
    } catch (error) {
      e = error;
      console.warn(e);
    }
    return _.ALIAS__executeCommand.call(this);
  };
  _._nProcessCommandForAll = function() {
    this._nSendCommandToServer();
    // * Выполнение команды как обычно у себя (так как там broadcast)
    return _.ALIAS__executeCommand.call(this);
  };
  _._nProcessCommandForMaster = function(isInclude) {
    if (ANNetwork.isMasterClient() === isInclude) {
      return _.ALIAS__executeCommand.call(this);
    } else {
      this._nSendCommandToServer();
      return this._nSkipCommand();
    }
  };
  _._nProcessCommandForActorsList = function(isInclude) {
    this._nSendCommandToServer();
    if (ANETUtils.isMyActorInValidListToStart(this.nCommandStartOptions.actorList, isInclude)) {
      return _.ALIAS__executeCommand.call(this);
    } else {
      return this._nSkipCommand();
    }
  };
  _._nProcessCommandNotMe = function() {
    this._nSendCommandToServer();
    return this._nSkipCommand();
  };
  _._nSkipCommand = function() {
    this._index++;
    this.nClearCommandOptions();
    return true;
  };
  _._nSendCommandToServer = function() {
    ANInterpreterManager.sendEventVirtualCommand(this.currentCommand(), this.nCommandStartOptions, this.eventId());
  };
  // * Проверить комментарий на наличие NET команд
  _._nCheckNetComment = function(commentLine) {
    var command;
    command = ANETUtils.getNetCommentCommand(commentLine);
    if (!KString.any(command)) {
      return;
    }
    switch (command) {
      case "localActor":
        this._nOnNetCommand_LocalActor(commentLine);
        break;
      case "all":
        this._nOnNetCommand_SingleSelectorEventCommand("All", commentLine);
        break;
      case "!me":
        this._nOnNetCommand_SingleSelectorEventCommand("Me Except", commentLine);
        break;
      case "master":
        this._nOnNetCommand_SingleSelectorEventCommand("Master", commentLine);
        break;
      case "!master":
        this._nOnNetCommand_SingleSelectorEventCommand("Master Except", commentLine);
        break;
      case "forActors":
        this._nOnNetCommand_ActorListSelectorEventCommand(commentLine, true);
        break;
      case "!forActors":
        this._nOnNetCommand_ActorListSelectorEventCommand(commentLine, false);
        break;
      case "wait":
        if (ANInterpreterManager.isSharedEventIsRunning()) {
          this.nRequestSyncedNextEventCommand();
        } else {
          console.warn("N wait can be used only in Shared Events");
        }
        break;
      case "choicesForMaster":
        if (ANInterpreterManager.isSharedEventIsRunning()) {
          this.nRequestMasterOnlyChoicesModeForNextChoice();
        } else {
          console.warn("N choicesForMaster can be used only in Shared Events");
        }
        break;
      case "start":
        break;
      default:
        // * Это коммент опций запуска, просто пропускаем, чтобы ошибку не писать в консоль
        // * Обрабатывается он отдельно, так как если условие ложно, событие не должно
        // * Вообще запускаться, а эти команды обрабатываеются уже в запущенном событии
        console.warn("Unknown NET Comment command " + command);
    }
  };
  // * Сделать следующую битву сетевой битвой (общей, расшаринной)
  _.nSetSharedBattle = function(battleId) {
    if (!KString.any(battleId)) {
      // * Если пустая строка, то Null
      battleId = null;
    }
    BattleManager.nSetNetworkBattle(battleId);
  };
  // * Сбросить все сетевые флаги \ настройки перед запуском очередного события
  _.nClearFlags = function() {
    $gameTemp._nLocalActorMode = false;
    this._nRunningCheckTimer = 0;
    this.nClearCommandOptions();
  };
  (function() {    // * Опции запуска события
    // -----------------------------------------------------------------------
    _.isHaveNetworkStartOptions = function() {
      return this.nStartOptions != null;
    };
    // * Может ли данный игрок запустить это событие
    _.isPassStartOptions = function() {
      // * Если это общее событие и запускаетс от сервера, то по любому можно запускать
      if (this.nIsEventIsShared() && $gameTemp._nSharedEventOuterStartFlag === true) {
        return true;
      } else {
        if (!this.isHaveNetworkStartOptions()) {
          return true;
        }
        if (this.nIsLockedEvent()) {
          if (ANETUtils.isEventStartedByAny(this.eventId())) {
            return false;
          }
        }
        return ANETUtils.isPassEventFilterOptions(this.nStartOptions);
      }
    };
    // * Закрытыми могут быть только события с собственным ID (т.е. события карты)
    _.nIsLockedEvent = function() {
      var ref;
      return this.eventId() > 0 && ((ref = this.nStartOptions) != null ? ref.lockMode : void 0) === "true";
    };
    // * Есть ли опции (условия) запуска события для сети
    _.nCheckEventStartOptions = function() {
      var e, options, ref;
      this.nStartOptions = null; // * сбрасываем
      try {
        options = (ref = this._list) != null ? ref.find(function(line) {
          var ref1;
          return line.code === 357 && ((ref1 = line.parameters) != null ? ref1[1] : void 0) === "EventStartOptions";
        }) : void 0;
        if (options != null) {
          this.nStartOptions = options.parameters[3];
        } else {
          // * Меньший приоритет, т.е. параметр плагина главнее
          this.nCheckEventStartOptionsFromCommentCommand();
        }
      } catch (error) {
        e = error;
        console.warn(e);
        this.nStartOptions = null;
      }
    };
    _.nIsAutorunEvent = function() {
      var e, event;
      try {
        event = $gameMap.event(this.eventId());
        return (event != null ? event._trigger : void 0) === 3;
      } catch (error) {
        e = error;
        console.warn(e);
      }
      return true;
    };
    return _.nIsParallelEvent = function() {
      var e, event;
      try {
        event = $gameMap.event(this.eventId());
        return (event != null ? event._trigger : void 0) === 4;
      } catch (error) {
        e = error;
        console.warn(e);
      }
      return true;
    };
  })();
})();

// ■ END Game_Interpreter.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Interpreter.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  // * Обработка комманд из комментариев (алтернатива командам плагинов)

  //@[DEFINES]
  _ = Game_Interpreter.prototype;
  //input: "N localActor" | "N localActor end"
  _._nOnNetCommand_LocalActor = function(commentLine) {
    if (commentLine.contains("end")) {
      $gameTemp._nLocalActorMode = false;
    } else {
      $gameTemp._nLocalActorMode = true;
    }
  };
  
  //input: "N (selector)" | "N (selector) [scope]" | "N (selector) [scope] [mode]"
  //selcetor: all, !me, master, !master
  //scope: world, mode: virtual
  _._nOnNetCommand_SingleSelectorEventCommand = function(selector, commentLine) {
    var mode, scope;
    ({scope, mode} = ANETUtils.convertEventCommandScopeAndMode(commentLine));
    this._nSetAnyEventCommandOptions(selector, "[]", scope, mode);
  };
  // * Установить опции команды события для следующей комманды
  _._nSetAnyEventCommandOptions = function(selector, list, scope, mode) {
    var options;
    if (!KString.any(scope)) {
      // * Стандартные значения из команды плагина
      scope = "Same map";
    }
    if (!KString.any(mode)) {
      mode = "Auto";
    }
    options = ANETUtils.buildEventCommandOptions(selector, list, scope, mode);
    this.nSetCommandOptions(options);
  };
  _._nOnNetCommand_ActorListSelectorEventCommand = function(commentLine, isInclude) {
    var list, mode, scope, selector;
    ({scope, mode} = ANETUtils.convertEventCommandScopeAndMode(commentLine));
    list = ANETUtils.extractActorsListFromComment(commentLine);
    selector = "Actor List";
    if (!isInclude) {
      selector += " Except";
    }
    this._nSetAnyEventCommandOptions(selector, list, scope, mode);
  };
  // * Есть ли опции (условия) запуска события для сети (проверка команды - комментария)
  _.nCheckEventStartOptionsFromCommentCommand = function() {
    var commentLine;
    if (this._list == null) {
      return;
    }
    commentLine = this.__getEventCommentValue("N start", this._list);
    if (commentLine == null) {
      return;
    }
    this.nStartOptions = ANETUtils.parseEventStartOptionsFromCommentLine(commentLine);
  };
  // * TEMPORARY METHOD, should be KGameEvents.GetCommentLine
  _.__getEventCommentValue = function(commentCode, list) {
    var comment, e, i, item;
    try {
      if (list && list.length > 1) {
        i = 0;
        while (i < list.length) {
          item = list[i++];
          if (!item) {
            continue;
          }
          if (item.code === 108) {
            comment = item.parameters[0];
            if (comment.contains(commentCode)) {
              return comment;
            }
          }
        }
      }
    } catch (error) {
      e = error;
      console.warn(e);
    }
    return null;
  };
})();

// ■ END Game_Interpreter.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Interpreter.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
//$[ENCODE]
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Interpreter.prototype;
  _.nIsEventIsShared = function() {
    var e;
    try {
      return this.isHaveNetworkStartOptions() && this.nStartOptions.sharedMode !== "No";
    } catch (error) {
      e = error;
      console.warn(e);
      return false;
    }
  };
  _.nIsEventIsSharedAndStrict = function() {
    var e, ref;
    try {
      return this.nIsEventIsShared() && ((ref = this.nStartOptions.sharedMode) != null ? ref.contains("Strict") : void 0);
    } catch (error) {
      e = error;
      console.warn(e);
      return false;
    }
  };
  _.nIsSharedEventCanBeForceCancelled = function() {
    return !this.nIsEventIsSharedAndStrict() && this.nSyncWaitCommandData.index === 0;
  };
  _.nPrepareSharedEvent = function() {
    ANInterpreterManager.resetSharedEvent();
    console.log("PREPARE SHARED MOD", this._eventId);
    if ($gameTemp._nSharedEventOuterStartFlag == null) {
      // * Сброс пула игроков
      this.nPlayerPool = null;
      // * Регестрируем общее событие (второй аргумент флаг - мастер этот клиент?)
      ANInterpreterManager.setupSharedInterpreter(this, true);
      // * Запускаем пул игроков (на карте)
      this.nRequestSyncedNextEventCommand();
    } else {
      console.log("OUUTER START");
      // * Сброс флага
      $gameTemp._nSharedEventOuterStartFlag = null;
      // * Отправим, что мы зарегестрировались на этом событии
      ANInterpreterManager.setupSharedInterpreter(this, false);
      // * Ждём разрешение на старт следующей команды (от сервера, мастера общего события)
      this.nRequestSyncedNextEventCommand();
    }
  };
  
  // * Игрок отменил ожидания других игроков (события должно закрыться сразу)
  _.nIsSharedEventWaitPoolCancelled = function() {
    var e;
    try {
      if (!this.nIsSharedEventCanBeForceCancelled()) {
        return;
      }
      if (Input.isCancel()) {
        // * Прерываем событие сразу (не запускаем)
        // * Очищаем ввод, чтобы меню сразу не выскочело после нажатия Esc
        Input.clear();
        ANInterpreterManager.forceCancelSharedEvent();
        this.terminate();
        return true;
      }
    } catch (error) {
      e = error;
      console.warn(e);
    }
    return false;
  };
  // * Следующая команда события должна быть синхронизированна
  _.nRequestSyncedNextEventCommand = function() {
    this.nSyncWaitCommandData = {
      index: this._index,
      indent: this._indent
    };
    if (ANInterpreterManager.isSharedEventMaster()) {
      this.nSetWaitPlayerPool();
    } else {
      this.nSetWaitStartNextCommandFromServer();
    }
    ANInterpreterManager.showWaitPlayersOnSharedEvent();
  };
  // * Когда пришли данные от клиента
  _.nOnSyncedEventCommandResponse = function(index, indent, actorId) {
    var e;
    try {
      if (this.nSyncWaitCommandData == null) {
        return;
      }
      if (this.nPlayerPool == null) {
        return;
      }
      if (this.nSyncWaitCommandData.index === index && this.nSyncWaitCommandData.indent === indent) {
        console.log("PLAYER ANSWER ", actorId);
        return this.nPlayerPool.onAnswer(actorId);
      }
    } catch (error) {
      e = error;
      console.warn(e);
    }
  };
  // * Ожидания пула игроков
  _.nSetWaitPlayerPool = function() {
    console.log("START POOL");
    if (this.nPlayerPool == null) {
      this.nPlayerPool = new PlayersWaitPool();
    } else {
      // * Не пересоздаём, так как нам важно учитывать только тех игроков на карте
      // * которые были во время запуска события, а не подключились позже
      this.nPlayerPool.reset();
    }
    // * Отправляем на сервер запрос
    this.nPlayerPool.register();
    this._waitMode = "netPlayersPool";
  };
  // * Ожидание готовности пула игроков (этот метод работает только на мастере общего события)
  _.nUpdateWaitPlayersPool = function() {
    var waiting;
    // * Пул надо обновлять (таймер внутри на повторную отправку запроса о готовности клиентов)
    this.nPlayerPool.update();
    if (this.nIsSharedEventWaitPoolCancelled()) {
      console.log("STOP WAITING PLAYERS : IS CANCELED!");
      return true; // * Сразу выход из ожидания, если ожидание было преврано
    }
    waiting = !this.nPlayerPool.isReady();
    if (!waiting) {
      // * Теперь событие продолжается (мастер)
      console.log("STOP WAITING PLAYERS : IS READY");
      ANInterpreterManager.sendSharedEventReadyToContinue();
      ANInterpreterManager.hideWaitPlayersOnSharedEvent();
      this.nClearSharedSyncEventCommandWait();
      this._waitMode = '';
    }
    return waiting;
  };
  // * Очистить пул и данные команды на синхронизацию
  _.nClearSharedSyncEventCommandWait = function() {
    this.nSyncWaitCommandData = null;
  };
  // * Ждать разрешение от сервера (мастера общего события) на запуск следующей команды события
  // * Этот метод работает только на клиентах (не мастере общего события)
  _.nSetWaitStartNextCommandFromServer = function() {
    this._canContinueSharedEvent = false;
    ANInterpreterManager.sendSharedEventRegisteredDone();
    console.log("WAIT SERVER FOR NEXT COMMAND");
    // * Когда клиент уже на команде, которую надо синхронизировать, он будет
    // * каждую секунду "напоминать" о себе (снова отправлять что он готов продолжать)
    this._nRepeatAnswerToServerTimer = 60;
    this._waitMode = "netNextCommand";
  };
  // * Ожидание разрешения от сервера на запуск следующей команды
  _.nUpdateWaitServerNextCommandPermission = function() {
    var waiting;
    // * Сервер закрыл общее событие (отменил ожидание старта)
    // * В GameTemp, потому что может отменить, как тут ещё и не стартует это событие
    if ($gameTemp._shouldForceExitSharedEvent === true) {
      this.terminate();
      return true;
    }
    waiting = !this._canContinueSharedEvent;
    if (!waiting) {
      // * Событие продолжается (клиент)
      console.log("CAN PROCESS TO NEXT COMMAND");
      this._waitMode = '';
    } else {
      if (this._nRepeatAnswerToServerTimer >= 0) {
        this._nRepeatAnswerToServerTimer--;
        if (this._nRepeatAnswerToServerTimer === 0) {
          this.nSetWaitStartNextCommandFromServer();
        }
      }
    }
    return true;
  };
  // * Получен ответ от сервера, что можно продолжать выполнение общего события
  _.nAllowContinueSharedEvent = function() {
    if (this._waitMode !== "netNextCommand") {
      return;
    }
    this._canContinueSharedEvent = true;
    // * Чтобы сброс переменной не произошёл снова
    this._nRepeatAnswerToServerTimer = -1;
    ANInterpreterManager.hideWaitPlayersOnSharedEvent();
  };
  // * Следующий выбор (команда 102) будет в режиме "только мастер события"
  _.nRequestMasterOnlyChoicesModeForNextChoice = function() {
    // * Если Пул игроков пустой, то не задаём флаг, чтобы сервер лишний раз не грузить
    if ((this.nPlayerPool != null) && this.nPlayerPool.isSinglePool()) {
      return;
    }
    console.log("Shared Event Choices in Master only mode");
    $gameTemp.nRequireChoiceOnlyForMaster = true;
  };
})();

// ■ END Game_Interpreter.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__initialize, ALIAS__refresh, ALIAS__setup, ALIAS__setupStartingEvent, ALIAS__update, ALIAS__updateInterpreter, _;
  //@[DEFINES]
  _ = Game_Map.prototype;
  //@[ALIAS]
  ALIAS__initialize = _.initialize;
  _.initialize = function() {
    ALIAS__initialize.call(this);
    this._networkCharacters = new NETCharactersGroup();
  };
  //@[ALIAS]
  ALIAS__setup = _.setup;
  _.setup = function(mapId) {
    ALIAS__setup.call(this, mapId);
    if (ANNetwork.isConnected()) {
      // * Клиент переходит на новую карту
      ANGameManager.onNewGameMapSetup();
      this.setupNetworkCharacters();
    }
  };
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function(sceneActive) {
    ALIAS__update.call(this, sceneActive);
    if (ANNetwork.isConnected()) {
      return this.updateNetwork();
    }
  };
  
  //@[ALIAS]
  ALIAS__updateInterpreter = _.updateInterpreter;
  _.updateInterpreter = function() {
    // * Данная проверка была добавлена в версии 0.8.1 чтобы работали Autorun
    // * события которые имеют Event Start Options или Event Command Options
    if (ANNetwork.isConnected()) {
      if (ANGameManager.isActorIsBinded()) {
        return ALIAS__updateInterpreter.call(this, ...arguments);
      }
    } else {
      return ALIAS__updateInterpreter.call(this, ...arguments);
    }
  };
  
  //@[ALIAS]
  ALIAS__refresh = _.refresh;
  _.refresh = function() {
    ALIAS__refresh.call(this);
    if (ANNetwork.isConnected()) {
      return this.refreshNetworkCharacters();
    }
  };
  //@[ALIAS]
  ALIAS__setupStartingEvent = _.setupStartingEvent;
  _.setupStartingEvent = function() {
    if (ANNetwork.isConnected()) {
      if ($gameTemp.isNetworkSharedEventReserved()) {
        return this.nSetupNetworkSharedEvent();
      }
    }
    return ALIAS__setupStartingEvent.call(this);
  };
})();

// ■ END Game_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Map.prototype;
  // * Безопасное обновление карты, так как может вызываться когда пришли данные игроков (на любой сцене в любой момент)
  _.nSafeRefresh = function() {
    var e;
    try {
      if (SceneManager.isBusyForNetworkData()) {
        return;
      }
      if (!KUtils.IsMapScene()) {
        return;
      }
      if (typeof $dataMap === "undefined" || $dataMap === null) {
        return;
      }
      this.refresh();
    } catch (error) {
      e = error;
      console.warn(e);
    }
  };
  _.netCharsIsSomeoneCollided = function(x, y) {
    var e;
    try {
      return this._networkCharacters.isSomeoneCollided(x, y);
    } catch (error) {
      e = error;
      console.warn(e);
      return false;
    }
  };
  _.nGetNetCharXY = function(x, y) {
    if (this.netCharsIsSomeoneCollided(x, y)) {
      return this._networkCharacters.getInPos(x, y);
    } else {
      return null;
    }
  };
  _.netChars = function() {
    return this._networkCharacters.characters();
  };
  _.networkCharacterByActorId = function(actorId) {
    return this._networkCharacters.characterByActorId(actorId);
  };
  _.networkCharacterById = function(id) {
    return this._networkCharacters.characterById(id);
  };
  // * Инициализация персонажей отображаемых на карте
  _.setupNetworkCharacters = function() {
    return this._networkCharacters.setup();
  };
  _.updateNetwork = function() {
    return this._networkCharacters.update();
  };
  _.refreshNetworkCharacters = function() {
    return this._networkCharacters.refresh();
  };
  // * Запуск общего события (которое пришло от сервера)
  _.nSetupNetworkSharedEvent = function() {
    var e, event;
    try {
      event = this.event($gameTemp.retrieveNetworkSharedEvent());
      if (event == null) {
        return false;
      }
      $gameTemp._nSharedEventOuterStartFlag = true;
      event.start();
      return true;
    } catch (error) {
      e = error;
      console.warn(e);
    }
    return false;
  };
  _.nRefreshNetworkObserversForAll = function() {
    var char, e, event, i, j, len, len1, ref, ref1, results;
    try {
      if (!ANNetwork.isConnected()) {
        return;
      }
      try {
        if (typeof $gamePlayer !== "undefined" && $gamePlayer !== null) {
          $gamePlayer.nRefreshUserDefinedObservers();
        }
      } catch (error) {
        e = error;
        console.warn(e);
      }
      ref = this.events();
      for (i = 0, len = ref.length; i < len; i++) {
        event = ref[i];
        if (event == null) {
          continue;
        }
        try {
          event.nRefreshUserDefinedObservers();
        } catch (error) {
          e = error;
          console.warn(e);
        }
      }
      ref1 = this._networkCharacters.characters();
      results = [];
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        char = ref1[j];
        if (char == null) {
          continue;
        }
        try {
          results.push(char.nRefreshUserDefinedObservers());
        } catch (error) {
          e = error;
          results.push(console.warn(e));
        }
      }
      return results;
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
})();

// ■ END Game_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Message.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__clear, _;
  //@[DEFINES]
  _ = Game_Message.prototype;
  //@[ALIAS]
  ALIAS__clear = _.clear;
  _.clear = function() {
    ALIAS__clear.call(this);
    if (ANNetwork.isConnected()) {
      return this.nEndCallback();
    }
  };
})();

// ■ END Game_Message.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Message.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Message.prototype;
  _.nSetEndCallback = function(_nEndCallbackMethod) {
    this._nEndCallbackMethod = _nEndCallbackMethod;
  };
  _.nEndCallback = function() {
    if (this._nEndCallbackMethod != null) {
      this._nEndCallbackMethod();
      this._nEndCallbackMethod = null;
    }
  };
})();

// ■ END Game_Message.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Party.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__battleMembers, ALIAS__charactersForSavefile, ALIAS__facesForSavefile, ALIAS__leader, ALIAS__partyAbility, ALIAS__setupStartingMembers, _;
  //@[DEFINES]
  _ = Game_Party.prototype;
  //@[ALIAS]
  ALIAS__battleMembers = _.battleMembers;
  _.battleMembers = function() {
    if (ANNetwork.isConnected()) {
      return ANBattleManager.battleMembers();
    } else {
      return ALIAS__battleMembers.call(this);
    }
  };
  
  //@[ALIAS]
  ALIAS__setupStartingMembers = _.setupStartingMembers;
  _.setupStartingMembers = function() {
    if (ANNetwork.isConnected()) {
      if (ANET.PP.isMultiActorsMode()) {
        ALIAS__setupStartingMembers.call(this);
        // * Делаем копию начальных персонажей
        this._nSharedPartyMembers = [...this._actors];
        this._nSharedPartyOwners = {};
      }
      // * Нет начальной группы
      this._actors = [];
    } else {
      ALIAS__setupStartingMembers.call(this);
    }
  };
  
  //@[ALIAS]
  ALIAS__leader = _.leader;
  _.leader = function() {
    if (ANNetwork.isConnected()) {
      return this.networkLeader();
    } else {
      return ALIAS__leader.call(this);
    }
  };
  
  //@[ALIAS]
  ALIAS__charactersForSavefile = _.charactersForSavefile;
  _.charactersForSavefile = function() {
    if (ANNetwork.isConnected()) {
      return this.members().map(function(actor) {
        return [actor.characterName(), actor.characterIndex()];
      });
    } else {
      return ALIAS__charactersForSavefile.call(this);
    }
  };
  
  //@[ALIAS]
  ALIAS__facesForSavefile = _.facesForSavefile;
  _.facesForSavefile = function() {
    if (ANNetwork.isConnected()) {
      return this.members().map(function(actor) {
        return [actor.faceName(), actor.faceIndex()];
      });
    } else {
      return ALIAS__facesForSavefile.call(this);
    }
  };
  // * На всякий слуйчай добавил try \ catch, бывает выдаёт ошибку этот метод
  //@[ALIAS]
  ALIAS__partyAbility = _.partyAbility;
  _.partyAbility = function() {
    var e;
    if (ANNetwork.isConnected()) {
      try {
        return ALIAS__partyAbility.call(this, ...arguments);
      } catch (error) {
        e = error;
        console.warn(e);
        return false;
      }
    } else {
      return ALIAS__partyAbility.call(this, ...arguments);
    }
  };
})();

// ■ END Game_Party.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Party.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Party.prototype;
  _.setupNetworkGame = function() {};
  // * В бою участвует только один персонаж?
  _.isOneBattler = function() {
    return this.battleMembers().length <= 1;
  };
  //TODO: как задать после выбора персонажа, чтобы каждый раз не вычислять
  _.networkLeader = function() {
    var actorId;
    actorId = ANGameManager.myPlayerData().actorId;
    return $gameActors.actor(actorId);
  };
  //TODO: Есть метод onRefreshGameParty (в ANGameManager) -> путаница может быть
  // * Этот метод вызывается когда группа была изменена (кто-то отключился)
  _.nRefreshNetworkActors = function() {
    var actor, e, i, id, len, playerForActor, ref;
    try {
      ref = this.members();
      for (i = 0, len = ref.length; i < len; i++) {
        actor = ref[i];
        id = actor.actorId();
        // * Ищем игрока для каждого Actor
        playerForActor = ANGameManager.playersData.find(function(pl) {
          return pl.actorId === id;
        });
        // * Если нету больше игрока с таким Actor, удаляем из партии
        if (playerForActor == null) {
          this.nRemoveNetPlayerActor(id);
        }
      }
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
  //TODO: Возможно это и на сцену битвы надо? (или там по другому работает)

  // * Данный метод очищает группу чтобы перераспределить Actors между игроками
  _.nClearBeforeRefresh = function() {
    return this._actors = [];
  };
  _.nRefreshNetworkObserversForAll = function() {
    var actor, e, i, len, ref, results;
    try {
      if (!ANNetwork.isConnected()) {
        return;
      }
      ref = this.members();
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        actor = ref[i];
        if (actor == null) {
          continue;
        }
        try {
          results.push(actor.nRefreshUserDefinedObservers());
        } catch (error) {
          e = error;
          results.push(console.warn(e));
        }
      }
      return results;
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
})();

// ■ END Game_Party.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Party.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Party.prototype;
  // * ОБЩИЙ персонаж - это персонаж которым также управляет игрок (но не его основной)
  // * Проверка, является ли actorId - СВОБОДНЫМ общим персонажем
  _.nIsValidSharedActor = function(actorId) {
    var playerForActor;
    playerForActor = ANGameManager.playersData.find(function(pl) {
      return pl.actorId === actorId;
    });
    if (playerForActor != null) {
      // * Данный ActorId является игроком!!!
      return false;
    } else {
      return true;
    }
  };
  _.nIsOwnedSharedActor = function(actorId) {
    return this.nGetOwnerOfSharedActor(actorId) != null;
  };
  _.nGetOwnerOfSharedActor = function(actorId) {
    return this._nSharedPartyOwners[actorId];
  };
  
  // * Я (данный клиент) управляю данным персонажем? (дополнительным)
  _.nIsIOwnedSharedActor = function(actorId) {
    return this.nIsOwnedSharedActor(actorId) && this.nGetOwnerOfSharedActor(actorId) === ANNetwork.myId();
  };
  //TODO: Надо чтобы NetworkCharacters на карте не создавались, а то ошибки и вылеты при JoinGame

  // * Оставляем shared акторов (которых контролирует игрок)
  _.nRefreshSharedMembers = function() {
    var actorId, i, len, ref;
    if (!ANET.PP.isMultiActorsMode()) {
      return;
    }
    ref = this._nSharedPartyMembers;
    for (i = 0, len = ref.length; i < len; i++) {
      actorId = ref[i];
      if (this.nIsValidSharedActor(actorId)) {
        this._actors.push(actorId);
        if (ANNetwork.isMasterClient()) {
          // * Если никто не занял, значит персонаж - хоста (по умолчанию)
          if (this._nSharedPartyOwners[actorId] == null) {
            this._nSharedPartyOwners[actorId] = ANNetwork.myId();
          }
        }
      } else {
        // * Если персонажем играют, то его удаляем
        delete this._nSharedPartyOwners[actorId];
      }
    }
  };
  //TODO: syncover clients @_nSharedPartyOwners
  _.nRemoveNetPlayerActor = function(actorId) {
    if (ANET.PP.isMultiActorsMode()) {
      if (!this.nIsValidSharedActor(actorId)) {
        ANGameManager.anotherPlayerLeaveGame(actorId);
      }
      if (ANNetwork.isMasterClient()) {
        console.log("TODO: refresh shared actor binding");
      }
    } else {
      // * not remove, Actor now is shared
      this.removeActor(actorId);
      //TODO: Этот метод не вызывается если уходит настоящий игрок!!! (в режиме мульти чар)
      ANGameManager.anotherPlayerLeaveGame(actorId);
    }
  };
})();

// ■ END Game_Party.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__canMove, ALIAS__executeEncounter, ALIAS__getInputDirection, ALIAS__moveDiagonally, ALIAS__moveStraight, ALIAS__update, _;
  //@[DEFINES]
  _ = Game_Player.prototype;
  //@[ALIAS]
  ALIAS__getInputDirection = _.getInputDirection;
  _.getInputDirection = function() {
    var dir;
    if (ANNetwork.isConnected() && $gameTemp._netAutoFollowActorId > 0) {
      dir = ALIAS__getInputDirection.call(this);
      if (dir !== 0) {
        $gameTemp._netAutoFollowActorId = null;
      }
      return dir;
    } else {
      return ALIAS__getInputDirection.call(this);
    }
  };
  
  //@[ALIAS]
  ALIAS__canMove = _.canMove;
  _.canMove = function() {
    if (ANNetwork.isConnected()) {
      if (ANNetwork.isBusy()) {
        // * Игрок не может ходить если игра ждёт ответ от сервера
        return false;
      }
    }
    return ALIAS__canMove.call(this, ...arguments);
  };
  //@[ALIAS]
  ALIAS__moveStraight = _.moveStraight;
  _.moveStraight = function(d) {
    if (ANNetwork.isConnected()) {
      // * Запоминаем предыдующие координаты (перед движением)
      this.___x = this.x;
      this.___y = this.y;
      // * Движение
      ALIAS__moveStraight.call(this, d);
      // * Если координаты сменились, значит персонаж
      // совершил движение, можно отправить на сервер
      if (this.___x !== this.x || this.___y !== this.y) {
        return ANPlayersManager.sendPlayerMove();
      }
    } else {
      return ALIAS__moveStraight.call(this, d);
    }
  };
  
  //@[ALIAS]
  ALIAS__moveDiagonally = _.moveDiagonally;
  _.moveDiagonally = function(horz, vert) {
    if (ANNetwork.isConnected()) {
      // * Запоминаем предыдующие координаты (перед движением)
      this.___x = this.x;
      this.___y = this.y;
      // * Движение
      ALIAS__moveDiagonally.call(this, horz, vert);
      // * Если координаты сменились, значит персонаж
      // совершил движение, можно отправить на сервер
      if (this.___x !== this.x || this.___y !== this.y) {
        ANPlayersManager.sendPlayerMove();
      }
    } else {
      ALIAS__moveDiagonally.call(this, horz, vert);
    }
  };
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function(sceneActive) {
    ALIAS__update.call(this, sceneActive);
    if (ANNetwork.isConnected()) {
      this.updateNetwork();
      if (sceneActive === true) {
        this.nUpdatePlayerInputForNetwork();
      }
    }
  };
  //@[ALIAS]
  ALIAS__executeEncounter = _.executeEncounter;
  _.executeEncounter = function() {
    var result;
    if (ANNetwork.isConnected() && ANET.PP.isMapEncountersGlobal()) {
      $gameTemp.nNextBattleIsEncounter = true;
      result = ALIAS__executeEncounter.call(this, ...arguments);
      // * Снимаем флаг, чтобы не мешал другим битвам
      $gameTemp.nNextBattleIsEncounter = false;
      return result;
    } else {
      return ALIAS__executeEncounter.call(this, ...arguments);
    }
  };
})();

// ■ END Game_Player.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Player.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Player.prototype;
  _.dataObserverHaveChanges = function() {
    return ANSyncDataManager.sendPlayerObserver();
  };
  _.updateNetwork = function() {
    var ref;
    if ($gameParty.isEmpty()) {
      return;
    }
    // * Проверяем и обновляем DataObserver своего персонажа
    // * Тут этот ? (првоерка Null) нужна!
    return (ref = $gameParty.leader()) != null ? ref.updateDataObserver() : void 0;
  };
  _.nUpdatePlayerInputForNetwork = function() {
    return this.nUpdateAutoFollowMode();
  };
  //%[I] Показывать какую-то иконку над игроком (или целью) что в режиме преследования находится
  _.nUpdateAutoFollowMode = function() {
    var actorForFollow;
    if (!($gameTemp._netAutoFollowActorId > 0)) {
      return;
    }
    if (this.isMoving() || !this.canMove()) {
      return;
    }
    actorForFollow = $gameMap.networkCharacterByActorId($gameTemp._netAutoFollowActorId);
    if (actorForFollow != null) {
      Game_Follower.prototype.chaseCharacter.call(this, actorForFollow);
    } else {
      $gameTemp._netAutoFollowActorId = null;
    }
  };
})();

// ■ END Game_Player.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Switches.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__onChange, ALIAS__setValue, _;
  //@[DEFINES]
  _ = Game_Switches.prototype;
  //@[ALIAS]
  ALIAS__setValue = _.setValue;
  _.setValue = function(switchId, value) {
    if (ANNetwork.isConnected()) {
      // * Вызываем страндартный метод
      ALIAS__setValue.call(this, switchId, value);
      // * Если были изменения
      if (this.__variableChangedOk === true) {
        if (this.isGlobalSwitch(switchId)) {
          ANSyncDataManager.sendGlobalSwitchChange(switchId, this.value(switchId));
        }
      }
      this.__variableChangedOk = false;
    } else {
      ALIAS__setValue.call(this, switchId, value);
    }
  };
  
  //@[ALIAS]
  ALIAS__onChange = _.onChange;
  _.onChange = function() {
    ALIAS__onChange.call(this);
    if (ANNetwork.isConnected()) {
      this.__variableChangedOk = true;
    }
  };
})();

// ■ END Game_Switches.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Switches.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Switches.prototype;
  _.isGlobalSwitch = function(switchId) {
    return ANET.PP.globalSwitchesIds().contains(switchId);
  };
  _.onSwitchFromServer = function(switchId, value) {
    this._data[switchId] = value;
    return this.onChange();
  };
})();

// ■ END Game_Switches.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_System.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var OBSERVERS_STORE_FIELD_NAME, _;
  //@[DEFINES]
  _ = Game_System.prototype;
  // * Инициализация набора общих событий для команд пользователя
  _.nInitCustomCommandsCE = function() {
    if (this.nCustomCommandsCE == null) {
      return this.nCustomCommandsCE = {};
    }
  };
  // * Проверка, есть ли для кастомной команды общее событие (и запуск если есть)
  _.nCheckCustomCommandForCEStart = function(name) {
    var ceId, e;
    try {
      this.nInitCustomCommandsCE();
      ceId = this.nCustomCommandsCE[name];
      if ((ceId != null) && ceId > 0) {
        $gameTemp.reserveCommonEvent(ceId);
      }
    } catch (error) {
      e = error;
      console.warn(e);
    }
  };
  // * Зарегестрировать вызов общего события для кастомной команды
  _.nRegisterCustomCommandCE = function(name, ceId) {
    var e;
    try {
      this.nInitCustomCommandsCE();
      this.nCustomCommandsCE[name] = ceId;
    } catch (error) {
      e = error;
      console.warn(e);
    }
  };
  _.nRefreshWaitTransferMode = function(isWait, __isOuter = false) {
    var e;
    try {
      this.nWaitTransferModeState = isWait;
      if (!ANNetwork.isConnected()) {
        return;
      }
      if (!__isOuter) {
        ANGameManager.sendNetworkOption('waitTransferMode', isWait);
      }
      if (isWait === false) {
        if (ANGameManager._waitMode === "playersOnMap") {
          return ANGameManager.resetWait();
        }
      }
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
  _._nSetupUserDefinedObservers = function(observerObj, typeId) {
    var e, userDefinedFields;
    try {
      if (observerObj == null) {
        return;
      }
      userDefinedFields = this._nGetUserDefinedObserverFields(typeId);
      if ((userDefinedFields != null) && userDefinedFields.length > 0) {
        return observerObj.netDataObserver.addFields(observerObj, userDefinedFields);
      }
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
  OBSERVERS_STORE_FIELD_NAME = "_netUserDefinedObserverStore_";
  _._nGetUserDefinedObserverFields = function(typeId) {
    var e, fieldName;
    try {
      if (!KString.any(typeId)) {
        return [];
      }
      fieldName = OBSERVERS_STORE_FIELD_NAME;
      if (this[fieldName + typeId] == null) {
        return [];
      }
      return this[fieldName + typeId];
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
  _.nModifyUserDefinedObserver = function(typeId, prop, isAdd) {
    var e, fieldName;
    try {
      fieldName = OBSERVERS_STORE_FIELD_NAME;
      if (this[fieldName + typeId] == null) {
        this[fieldName + typeId] = [];
      }
      if (isAdd === true) {
        if (!this[fieldName + typeId].contains(prop)) {
          this[fieldName + typeId].push(prop);
        }
      } else {
        this[fieldName + typeId].delete(prop);
      }
      if (typeof $gameMap !== "undefined" && $gameMap !== null) {
        $gameMap.nRefreshNetworkObserversForAll();
      }
      if (typeof $gameParty !== "undefined" && $gameParty !== null) {
        $gameParty.nRefreshNetworkObserversForAll();
      }
      if (ANNetwork.isConnected()) {
        ANGameManager.sendNetworkOption('userDefinedObservers', {
          typeId,
          data: this[fieldName + typeId]
        });
      }
    } catch (error) {
      e = error;
      console.warn(e);
    }
  };
  _._nModifyUserDefinedObserversFromServer = function({typeId, data}) {
    var e;
    try {
      this[OBSERVERS_STORE_FIELD_NAME + typeId] = data;
      if (typeof $gameMap !== "undefined" && $gameMap !== null) {
        $gameMap.nRefreshNetworkObserversForAll();
      }
      return typeof $gameParty !== "undefined" && $gameParty !== null ? $gameParty.nRefreshNetworkObserversForAll() : void 0;
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
})();

// ■ END Game_System.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Temp.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__reservedCommonEvent, _;
  //@[DEFINES]
  _ = Game_Temp.prototype;
  if (KDX.isMZ()) {
    return;
  }
  // * В MV нету метода retrieveCommonEvent
  //@[ALIAS]
  ALIAS__reservedCommonEvent = _.reservedCommonEvent;
  _.reservedCommonEvent = function() {
    if (this.isVirtualCommonEventReserved()) {
      return this._virtualEventQueue.shift();
    } else {
      return ALIAS__reservedCommonEvent.call(this);
    }
  };
  // * В MV нету метода requestBattleRefresh
  _.requestBattleRefresh = function() {
    if ($gameParty.inBattle()) {
      return this._needsBattleRefresh = true;
    }
  };
  _.isBattleRefreshRequested = function() {
    return this._needsBattleRefresh === true;
  };
  _.clearBattleRefreshRequest = function() {
    return this._needsBattleRefresh = false;
  };
})();

// ■ END Game_Temp.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Temp.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__initialize, ALIAS__isCommonEventReserved, ALIAS__requestAnimation, ALIAS__retrieveCommonEvent, ALIAS__setDestination, _;
  //@[DEFINES]
  _ = Game_Temp.prototype;
  //@[ALIAS]
  ALIAS__setDestination = _.setDestination;
  _.setDestination = function() {
    ALIAS__setDestination.call(this, ...arguments);
    $gameTemp._netAutoFollowActorId = null;
  };
  //@[ALIAS]
  ALIAS__initialize = _.initialize;
  _.initialize = function() {
    ALIAS__initialize.call(this);
    // * Виртуальные общие события от сервера
    this._virtualEventQueue = [];
  };
  
  //@[ALIAS]
  ALIAS__isCommonEventReserved = _.isCommonEventReserved;
  _.isCommonEventReserved = function() {
    return this.isVirtualCommonEventReserved() || ALIAS__isCommonEventReserved.call(this);
  };
  
  // * Виртуальные события в приоритете
  //@[ALIAS]
  ALIAS__retrieveCommonEvent = _.retrieveCommonEvent;
  _.retrieveCommonEvent = function() {
    if (this.isVirtualCommonEventReserved()) {
      return this._virtualEventQueue.shift();
    } else {
      return ALIAS__retrieveCommonEvent.call(this);
    }
  };
  //@[ALIAS]
  ALIAS__requestAnimation = _.requestAnimation;
  _.requestAnimation = function() {
    if (ANNetwork.isConnected()) {
      // * В бою анимацию синхронизируется (только мастер)(отправляется другим игрокам)
      if ($gameParty.inBattle() && ANGameManager.isBattleMaster()) {
        ANBattleManager.requestAnimation(...arguments);
      }
    }
    return ALIAS__requestAnimation.call(this, ...arguments);
  };
})();

// ■ END Game_Temp.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Temp.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Temp.prototype;
  (function() {    // * Virtual Common Events
    // -----------------------------------------------------------------------
    _.reserveNetworkSharedEvent = function(_reservedNetworkSharedEvent) {
      this._reservedNetworkSharedEvent = _reservedNetworkSharedEvent;
    };
    _.isNetworkSharedEventReserved = function() {
      return this._reservedNetworkSharedEvent >= 1;
    };
    // * Забираем (и сразу очищаем)
    _.retrieveNetworkSharedEvent = function() {
      var eventId;
      eventId = this._reservedNetworkSharedEvent;
      this._reservedNetworkSharedEvent = 0;
      return eventId;
    };
    _.reserveVirtualCommonEvent = function(list) {
      return this._virtualEventQueue.push(list);
    };
    _.isVirtualCommonEventReserved = function() {
      return this._virtualEventQueue.length > 0;
    };
  })();
})();

// ■ END Game_Temp.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Troop.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Troop.prototype;
})();

// ■ END Game_Troop.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Unit.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Unit.prototype;
  _.nUpdateBattleDataSync = function() {
    var members;
    members = this.members();
    if (members.some(function(m) {
      return m.isNeedNetPushBattleData();
    })) {
      ANSyncDataManager.sendBattleUnitsObserver(members);
      members.forEach(function(m) {
        return m.onNetBattleDataPushed();
      });
    }
  };
})();

// ■ END Game_Unit.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Variables.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__onChange, ALIAS__setValue, _;
  //@[DEFINES]
  _ = Game_Variables.prototype;
  //@[ALIAS]
  ALIAS__setValue = _.setValue;
  _.setValue = function(variableId, value) {
    if (ANNetwork.isConnected()) {
      // * Вызываем страндартный метод
      ALIAS__setValue.call(this, variableId, value);
      // * Если были изменения
      if (this.__variableChangedOk === true) {
        if (this.isGlobalVariable(variableId)) {
          ANSyncDataManager.sendGlobalVariableChange(variableId, this.value(variableId));
        }
      }
      this.__variableChangedOk = false;
    } else {
      ALIAS__setValue.call(this, variableId, value);
    }
  };
  //@[ALIAS]
  ALIAS__onChange = _.onChange;
  _.onChange = function() {
    ALIAS__onChange.call(this);
    if (ANNetwork.isConnected()) {
      return this.__variableChangedOk = true;
    }
  };
})();

// ■ END Game_Variables.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Variables.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Game_Variables.prototype;
  _.isGlobalVariable = function(varId) {
    return ANET.PP.globalVariablesIds().contains(varId);
  };
  _.getAllGlobalVariablesData = function() {
    var i, j, variables;
    variables = [];
    for (i = j = 1; j <= 8; i = ++j) {
      variables.push([i, this.value[i]]);
    }
    return variables;
  };
  _.onVariableFromServer = function(varId, value) {
    this._data[varId] = value;
    return this.onChange();
  };
})();

// ■ END Game_Variables.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ ImageManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = ImageManager;
  _.loadNETZ = function(filename) {
    return this.loadBitmap('img/Alpha_NETZ/', filename);
  };
})();

// ■ END ImageManager.coffee
//---------------------------------------------------------------------------


var LL;
(function (LL) {
    let _isDebugMode = false;
    function log(message) {
        console.log(`%c${"NETZ: " + message}`, "background-color:#191a19; color:purple; padding: 2px 5px; border-radius: 3px;");
    }
    LL.log = log;
    function warn(message) {
        console.log(`%c${"NETZ Warning: " + message}`, "background-color:#191a19; color:orange; padding: 5px 10px; border-radius: 5px;");
    }
    LL.warn = warn;
    function debug(message) {
        if (!_isDebugMode)
            return;
        console.log(`%c${"NETZ Debug: " + message}`, "background-color:#cccc77; color:black; padding: 2px 5px;");
    }
    LL.debug = debug;
    function extensionLoaded(name) {
        console.log(`%c${"NETZ Extension loaded: " + name}`, "background-color:#191a19; color:lightblue; padding: 4px 8px; border-radius: 12px;");
    }
    LL.extensionLoaded = extensionLoaded;
})(LL || (LL = {}));
ANET['LL'] = LL;


class NETCharacter extends Game_Character {
    constructor(id) {
        super();
        this.id = "";
        // Иконка сетевого состояния игрока (меню, карта, торговля, чат и т.д.)
        this.networkStateIcon = 0;
        this.id = id;
    }
    playerData() {
        try {
            //@ts-ignore
            return ANGameManager.getPlayerDataById(this.id);
        }
        catch (error) {
            console.warn(error);
        }
        return null;
    }
    actor() {
        try {
            let pd = this.playerData();
            if (!pd)
                return null;
            return $gameActors.actor(pd.actorId);
        }
        catch (error) {
            console.warn(error);
        }
        return null;
    }
    actorId() {
        try {
            let actor = this.actor();
            if (!actor)
                return -1;
            return actor.actorId();
        }
        catch (error) {
            console.warn(error);
        }
        return -1;
    }
    refresh() {
        try {
            let actor = this.actor();
            if (!actor)
                return;
            //@ts-ignore
            this.setImage(actor.characterName(), actor.characterIndex());
        }
        catch (error) {
            console.warn(error);
        }
    }
    requestNetworkStateIcon(networkStateIcon) {
        this.networkStateIcon = networkStateIcon;
    }
}
window['NETCharacter'] = NETCharacter;


/**
 * Данный класс содержит NETCharacter всех игроков на карте (аналог Game_Followers)
 */
class NETCharactersGroup {
    constructor() {
        this._data = [];
        this._data = [];
    }
    setup() {
        console.log("SETUP NETWORK CHARS");
        this._data = [];
        this._refreshCharacters();
    }
    /**
     * Вызывается из Game_Map.refresh
     */
    refresh() {
        this._refreshCharacters();
        for (const char of this._data) {
            char.refresh();
        }
    }
    characters() {
        return this._data;
    }
    characterById(id) {
        return this.characters().find(c => c.id === id);
    }
    characterByActorId(actorId) {
        return this.characters().find(c => c.actorId() === actorId);
    }
    update() {
        for (const c of this.characters()) {
            c.update();
        }
    }
    isSomeoneCollided(x, y) {
        return this.characters().some(c => c.pos(x, y));
    }
    getInPos(x, y) {
        return this.characters().find(c => c.pos(x, y));
    }
    /**
     * Данный метод удаляет (отключённых) и создаёт (подключённых) персонажей
     */
    _refreshCharacters() {
        this._removeNotExistsCharacters();
        this._addNewCharacters();
        this._refreshNetworkCharactersSprites();
    }
    /**
     * Удаляем (отключился или ушёл на другую карту)
     */
    _removeNotExistsCharacters() {
        //@ts-ignore
        const x = ANGameManager.anotherPlayersOnMap();
        for (const char of this.characters()) {
            if (!char)
                continue;
            if (!x.find(c => c.id === char.id)) {
                const index = this._data.indexOf(char);
                if (index > -1) {
                    this._data.splice(index, 1);
                }
            }
        }
    }
    /**
     * Добавляем новых персонажей
     */
    _addNewCharacters() {
        // anotherPlayersOnMap - значит на текущей карте и characterReady is true - Это важно
        //@ts-ignore
        const x = ANGameManager.anotherPlayersOnMap();
        for (const pl of x) {
            const char = this.characterById(pl.id);
            if (!char) {
                this._data.push(new NETCharacter(pl.id));
            }
        }
    }
    /**
     * Пересоздать спрайты персонажей
     */
    _refreshNetworkCharactersSprites() {
        var _a, _b;
        if (!KUtils.IsMapScene())
            return;
        try {
            (_b = (_a = SceneManager._scene) === null || _a === void 0 ? void 0 : _a._spriteset) === null || _b === void 0 ? void 0 : _b.refreshNetworkCharacters();
        }
        catch (error) {
            console.warn(error);
        }
    }
}
window['NETCharactersGroup'] = NETCharactersGroup;


// Generated by CoffeeScript 2.7.0
// * Основной класс менеджер интерфейса (API)
// * Аналогичен классу AA.UI из ABSZ
ANET.UI = function() {};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ ANET.UI.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = ANET.UI;
  _.setUI = function(uiSet) {
    this.uiSet = uiSet;
  };
  _.isValid = function() {
    return (this.uiSet != null) && ANNetwork.isConnected();
  };
  // * Когда появляется окно с сообщением
  _.onGameMessageStart = function() {
    if (!this.isValid()) {
      return;
    }
    this.uiSet.onGameMessageStart();
  };
  // * Когда заканчивается окно с сообщением
  _.onGameMessageEnd = function() {
    if (!this.isValid()) {
      return;
    }
    return this.uiSet.onGameMessageEnd();
  };
  // * Когда было нажатие мышки на какой-либо UI элемент
  _.isUITouched = function() {
    return false;
  };
  // * Вызывается когда сцена карты заканчивается
  _.terminate = function() {
    var ref;
    if ((ref = this.uiSet) != null) {
      ref.terminate();
    }
  };
  (function() {    
    // * Основной интерфейс Spriteset_UI
    // -----------------------------------------------------------------------
    _.refresh = function() {
      var ref;
      return (ref = this.uiSet) != null ? ref.refresh() : void 0;
    };
    _.hide = function() {
      var ref;
      return (ref = this.uiSet) != null ? ref.hide() : void 0;
    };
    _.show = function() {
      var ref;
      return (ref = this.uiSet) != null ? ref.show() : void 0;
    };
    // * Если какой-либо UI элемент обрабатывает нажатие курсора, то true
    return _.isAnyUIElementTouchProcess = function() {
      return false;
    };
  })();
})();

// ■ END ANET.UI.coffee
//---------------------------------------------------------------------------
// -----------------------------------------------------------------------


class NetMessage {
    constructor(socket) {
        this._name = "";
        this._from = "";
        this._to = "";
        this._data = "";
        this._waited = false;
        this._socket = socket;
    }
    get name() {
        return this._name;
    }
    get from() {
        return this._from;
    }
    get to() {
        return this._to;
    }
    get data() {
        return this._data;
    }
    get waited() {
        return this._waited;
    }
    static SetOwnSocket(socket) {
        this._OwnerSocket = socket;
    }
    setName(name) {
        this._name = name;
        return this;
    }
    setFrom(from) {
        this._from = from;
        return this;
    }
    setTo(to) {
        this._to = to;
        return this;
    }
    setData(data) {
        this._data = data;
        return this;
    }
    fullName() {
        if (this._data && this._data.id) {
            return this._name + "_" + this._data.id;
        }
        return this._name;
    }
    send(data) {
        this._socket.emit(this._name, this._makeData(data));
        return this;
    }
    callback(callback) {
        this._socket.emit(this._name, this._makeData(null), callback);
        return this;
    }
    get(onSuccess, onTimeout, timeoutTime, data) {
        let timeoutFunc = NetMessage.WithTimeout;
        this._socket.emit(this._name, this._makeData(data), timeoutFunc(onSuccess, onTimeout, timeoutTime));
        return this;
    }
    broadcast(data) {
        this._socket.broadcast.emit(this._name, this._makeData(data));
        return this;
    }
    _makeData(data) {
        if (!data) {
            data = this._data;
        }
        else {
            this._data = data;
        }
        let netData = {
            data: data,
            from: this._from,
            to: this._to,
            waited: this._waited
        };
        return netData;
    }
    static WithTimeout(onSuccess, onTimeout, timeout) {
        let called = false;
        const timer = setTimeout(() => {
            if (called)
                return;
            called = true;
            onTimeout();
        }, timeout);
        return (...args) => {
            if (called)
                return;
            called = true;
            clearTimeout(timer);
            onSuccess.apply(this, args);
        };
    }
    static Trace(message, socket) {
        return this.EmptyMessage(socket).setName("trace").setData(message);
    }
    static EmptyMessage(socket) {
        let targetSocket = socket;
        if (!targetSocket) {
            targetSocket = this._OwnerSocket;
        }
        let message = new NetMessage(targetSocket);
        if (targetSocket) {
            message.setFrom(targetSocket.id);
        }
        return message;
    }
    static EmptyMessageWithFlag(flagName, data, socket) {
        let message = this.EmptyMessage(socket);
        message.setData({
            id: flagName,
            content: data
        });
        return message;
    }
    // * Network messages shortcuts * //
    static Lobby(flagName, data, socket) {
        return this.EmptyMessageWithFlag(flagName, data, socket).setName("lobby");
    }
    static Map(flagName, data, socket) {
        return this.EmptyMessageWithFlag(flagName, data, socket).setName("map");
    }
    static Game(flagName, data, socket) {
        return this.EmptyMessageWithFlag(flagName, data, socket).setName("game");
    }
    static Event(flagName, data, socket) {
        return this.EmptyMessageWithFlag(flagName, data, socket).setName("event");
    }
    static Battle(flagName, data, socket) {
        return this.EmptyMessageWithFlag(flagName, data, socket).setName("battle");
    }
    static Other(flagName, data, socket) {
        return this.EmptyMessageWithFlag(flagName, data, socket).setName("ohter");
    }
    static Common(innerFlagName, data, socket) {
        return this._commonCommandMessage("forClients", innerFlagName, data, socket);
    }
    // * Через broadcast, т.е. самому себе не прийдёт
    static ABSZ(innerFlagName, data, socket) {
        return this._commonCommandMessage("absz", innerFlagName, data, socket);
    }
    static _commonCommandMessage(commandName, innerFlagName, data, socket) {
        let commonData = {
            cmd: innerFlagName,
            data: data
        };
        return this.EmptyMessageWithFlag(commandName, commonData, socket).setName('common');
    }
}
window["NetMessage"] = NetMessage;
// * For compatibility with old code (used in some plugins) * //
window["NMS"] = NetMessage;


var NetPlayerDataWrapper;
(function (NetPlayerDataWrapper) {
    let _tempPlayerNetworkName = "";
    function createLocal() {
        let playerName = _getPlayerNameFromConfig();
        if (!playerName || playerName == "") {
            if (_tempPlayerNetworkName == "") {
                _tempPlayerNetworkName = "Player_" + Math.floor(Math.random() * 1000);
            }
            playerName = _tempPlayerNetworkName;
        }
        return {
            //@ts-ignore
            id: ANNetwork.myId(),
            name: playerName,
            mapId: 0,
            actorId: 0,
            index: 0,
            scene: "",
            characterReady: false,
            isMapMaster: false,
            onEvent: 0,
            onCommonEvent: 0,
            isReadyInRoom: false
        };
    }
    NetPlayerDataWrapper.createLocal = createLocal;
    function isHaveCharacterInGame(player) {
        if (!player)
            return false;
        return player.characterReady == true && player.actorId > 0;
    }
    NetPlayerDataWrapper.isHaveCharacterInGame = isHaveCharacterInGame;
    function isCharOnMap(player) {
        if (!player)
            return false;
        return player.characterReady == true && player.mapId == $gameMap.mapId();
    }
    NetPlayerDataWrapper.isCharOnMap = isCharOnMap;
    function isOnMapScene(player) {
        if (!player)
            return false;
        return player.scene == "map" && isCharOnMap(player);
    }
    NetPlayerDataWrapper.isOnMapScene = isOnMapScene;
    function isOnAnyEvent(player) {
        if (!player)
            return false;
        return isCharOnMap(player) && (player.onEvent > 0 || player.onCommonEvent > 0);
    }
    NetPlayerDataWrapper.isOnAnyEvent = isOnAnyEvent;
    function isOnBattleScene(player) {
        if (!player)
            return false;
        return getRequestedNetworkState(player) == 5;
    }
    NetPlayerDataWrapper.isOnBattleScene = isOnBattleScene;
    function getRequestedNetworkState(player) {
        if (!player)
            return -1;
        if (isOnAnyEvent(player))
            return 1;
        switch (player.scene) {
            case "menu":
                return 2;
            case "trade":
                return 3;
            case "battle":
                return 5;
            case "chat":
                return 6;
            default:
                return 0;
        }
    }
    NetPlayerDataWrapper.getRequestedNetworkState = getRequestedNetworkState;
    function isFreeOnMap(player) {
        if (!player)
            return false;
        return !isOnAnyEvent(player) && isOnMapScene(player);
    }
    NetPlayerDataWrapper.isFreeOnMap = isFreeOnMap;
    function isCurrentPlayerActor(actor, player) {
        if (!player)
            return false;
        if (!actor)
            return false;
        return player.actorId == actor.actorId();
    }
    NetPlayerDataWrapper.isCurrentPlayerActor = isCurrentPlayerActor;
    function isOnEvent(player, eventId) {
        if (!player)
            return false;
        return player.onEvent == eventId;
    }
    NetPlayerDataWrapper.isOnEvent = isOnEvent;
    function getNetCharacterForPlayer(player) {
        if (!player)
            return null;
        //@ts-ignore
        return $gameMap.networkCharacterById(player.id);
    }
    NetPlayerDataWrapper.getNetCharacterForPlayer = getNetCharacterForPlayer;
    function getActorForPlayer(player) {
        if (!player)
            return null;
        return $gameActors.actor(player.actorId);
    }
    NetPlayerDataWrapper.getActorForPlayer = getActorForPlayer;
    function _getPlayerNameFromConfig() {
        //@ts-ignore
        return ConfigManager.netPlayerName;
    }
})(NetPlayerDataWrapper || (NetPlayerDataWrapper = {}));
window["NetPlayerDataWrapper"] = NetPlayerDataWrapper;


var NetRoomDataWrapper;
(function (NetRoomDataWrapper) {
    function createLocal() {
        return {
            name: "Room " + Math.floor(Math.random() * 100),
            masterId: "",
            masterName: "",
            inGame: false,
            playersIds: [],
            readyPlayersIds: [],
            gameId: "0",
            gameTitle: "",
            rpgVersion: 0,
            maxPlayers: 0,
            gameMode: 0,
            canConnect: true
        };
    }
    NetRoomDataWrapper.createLocal = createLocal;
    function isRoomProperToJoin(r) {
        if (!r)
            return false;
        try {
            // --- Общие проверки ---
            // * Нельзя подключиться если разные игры
            if (r.gameId != ANETUtils.getGameVersion())
                return false;
            // * Нельзя подключаться, если комната полная
            if (_isRoomFull(r))
                return false;
            // * Если разные движки
            if (!_isMyRPGVersion(r))
                return false;
            // --- Проверки режима ---
            // * Если ЗАПРЕЩЕНО подключаться к запущенной игре
            //@ts-ignore
            if (ANET.PP.isJoinStartedRoomAllowed() === false) {
                // * Нельзя подключаться к уже запущенной игре
                if (isStartedGameRoom(r))
                    return false;
                // * Если комната загрузки сетевого сохранения
                if (isLoadGameRoom(r)) {
                    // * То клиент должен иметь файл данного сохранения
                    //@ts-ignore
                    if (!DataManager.nIsHaveNetworkSaveWithId(r.uniqueSaveID))
                        return false;
                }
            }
            else {
                // * Если комната загрузки сетевого сохранения
                if (isLoadGameRoom(r)) {
                    // * Нельзя подключиться к загруженной игре (уже запущенной) если ОТКЛЮЧЁН соответсвующий параметр
                    //@ts-ignore
                    if (!ANET.PP.isJoinStartedAndLoadedRoom())
                        return false;
                }
            }
            // * Если специальный флаг
            //TODO: Пока не обрабатывается
            //if (r.canConnect === false) {
            //    return false;
            //}
        }
        catch (e) {
            console.warn(e);
        }
        return true;
    }
    NetRoomDataWrapper.isRoomProperToJoin = isRoomProperToJoin;
    function isLoadGameRoom(r) {
        return r.uniqueSaveID != null || r.uniqueSaveID != undefined;
    }
    NetRoomDataWrapper.isLoadGameRoom = isLoadGameRoom;
    function isStartedGameRoom(r) {
        return r.inGame === true;
    }
    NetRoomDataWrapper.isStartedGameRoom = isStartedGameRoom;
    function _isMyRPGVersion(r) {
        if (!r)
            return false;
        if (r.rpgVersion === 0) {
            return KDX.isMZ();
        }
        else {
            return KDX.isMV();
        }
    }
    function _isRoomFull(r) {
        if (!r)
            return true;
        return r.playersIds.length >= r.maxPlayers;
    }
})(NetRoomDataWrapper || (NetRoomDataWrapper = {}));
window['NetRoomDataWrapper'] = NetRoomDataWrapper;


class NetworkClientHandler {
    constructor(socket) {
        this.socket = socket;
        this._init();
    }
    disconnect() {
        var _a;
        (_a = this.socket) === null || _a === void 0 ? void 0 : _a.disconnect();
    }
    _init() {
        // * Задаём ссылку на собственный сокет в класс сообщений
        // Чтобы можно было отправлять сообщения каждый раз не передавая сокет
        NetMessage.SetOwnSocket(this.socket);
        this._handleCommands();
    }
    _handleCommands() {
        this._handleBaseSocketEvents();
        this._handleDebugEvents();
        this._handleANETServerEvents();
    }
    _handleBaseSocketEvents() {
        //@ts-ignore
        this.socket.on('disconnect', () => NetClientMethodsManager.onDisconnect());
        //@ts-ignore
        this.socket.on('connect', () => NetClientMethodsManager.onConnect());
        //@ts-ignore
        this.socket.on('connect_error', () => NetClientMethodsManager.onConnectionError());
    }
    _handleDebugEvents() {
        this.socket.on('trace', (n) => LL.log("Trace: " + n));
    }
    _handleANETServerEvents() {
        this.socket.on('serverPrc', (n) => {
            this._handleServerPrcEvent(n);
        });
    }
    _handleServerPrcEvent(n) {
        const { id, flag, content } = n;
        const eventHandlerMethodName = id + "_" + flag;
        //@ts-ignore
        if (NetClientMethodsManager.isExistPrcEvent(eventHandlerMethodName)) {
            //@ts-ignore
            NetClientMethodsManager.handlePrcEvent(eventHandlerMethodName, content);
        }
        else {
            LL.warn("Unknown Event from server " + eventHandlerMethodName);
        }
    }
}
window['NetworkClientHandler'] = NetworkClientHandler;


// Generated by CoffeeScript 2.7.0
// * Класс которые работает с параметрами и командами плагина
(function() {
  var ParamsManager;
  ParamsManager = (function() {
    class ParamsManager extends KDX.ParamLoader {
      constructor() {
        super("ANETZ");
        this._prepareParameters();
      }

      //? GAME ID --------------------------------------------------------------
      // * Пользовательский GameID
      isUseCustomGameId() {
        return this.getParam("isCustomGameId", false) && KString.any(this.getCustomGameId());
      }

      getCustomGameId() {
        return this.getParam("customGameId", "");
      }

      //? CONNECTION -----------------------------------------------------------
      // * Настройки соединения
      serverIp() {
        return this._ip;
      }

      serverPort() {
        return this._port;
      }

      isHTTPSConnection() {
        return this._isHttps === true;
      }

      //Allow Quick Connection?
      isQuickDevConnectionAllowed() {
        return this.getParam("isQuickDevConnectionAllowed", false);
      }

      isEndGameWhenHostIsLeave() {
        return this.getParam('isEndGameWhenHostIsLeave', true);
      }

      //? MULTIPLAYER GROUP -----------------------------------------------------------
      isAddNetGameCmdToTitleMenu() {
        return this.getParam("netGameTitleCmd", true);
      }

      //Join to Game Allowed?
      isJoinStartedRoomAllowed() {
        return this.getParam("joinStartedAllowed", false);
      }

      //Join to Loaded Game?
      isJoinStartedAndLoadedRoom() {
        return this.getParam("joinStartedAndLoadedAllowed", true);
      }

      //On Player Joined CE
      getJoinedRoomCommonEvent() {
        return this.getParam("onJoinCE", 0);
      }

      //Wait Map Transfer?
      isOnlySameMapMode() {
        return this.getParam("onlySameMap", true);
      }

      // New Game Allowed?
      // * Доступна ли обычная локальная Новая игра
      isSinglePlayerAllowed() {
        return this.getParam("singlePlayerAllowed", true);
      }

      // Is Check Ready?
      // * Проверять готовность игрока перед началом игры?
      isCheckPlayerReadyState() {
        return this.getParam("isReadyStatusCheck", true);
      }

      //Rooms Filter?
      isRoomFilterON() {
        return ANET.isPro() && this.getParam("roomFilter", false);
      }

      //Save and Load Allowed?
      // * Сохранение и загрузка сетевой игры
      isSaveLoadAllowed() {
        return this.getParam("saveLoadGame", true);
      }

      // Is show network icons?
      // * Показывать иконки статуса игрока
      isShowNetworkIcons() {
        return this.getParam("networkStatusIcons", true);
      }

      // Join Random Room Option
      // * Показывать опцию (Подключиться к случайной комнате)
      isJoinRandomRoomAllowed() {
        return this.getParam("isJoinRandomOptionExists", true);
      }

      //Is Encounters is Global?
      isMapEncountersGlobal() {
        return this.getParam("isMapEncountersGlobal", false);
      }

      //Is Custom Start Map?
      //Note: <nCustomStart:MAPID,X,Y,DIR>
      isCustomStartMap() {
        return !this.isOnlySameMapMode() && this.getParam("isCustomStartMap", false);
      }

      //? PLAYER SETTINGS GROUP -----------------------------------------------------------

        // * Набор персонажей Actors для сетевой игры
      //Actors
      actorsForNetwork() {
        return this.getParam("actorsForNetwork", [1, 2, 3, 4]);
      }

      //?VERSION
      //Players per Room
      maxPlayersInRoom() {
        return this.getParam("maxPlayersInRoom", 4);
      }

      // * Можно ли выбирать персонажа себе
      //Actor selection?
      isActorSelectionAllowed() {
        return this.getParam("isActorSelectionAllowed", true);
      }

      // * Можно ли начать сетевую игру одному
      //One player start?
      isSingleActorNetworkGameAllowed() {
        return this.getParam("isSinglePlayerStartAllowed", true);
      }

      // * Отображение имени игрока заместо имени персонажа
      // * 0 - Не показывать, 1 - Name, 2 - Nickname
      //?DINAMIC
      //Player Name for Actor
      playerActorNameType() {
        return 0;
      }

      //On Player Disconnect CE
      getPlayerLeaveGameCommonEventId() {
        return this.getParam("playerLeaveGameCommonEvent", 0);
      }

      //Players Collisions
      isAllowCollsBetweenNetChars() {
        return this.getParam("isAllowCollsBetweenNetChars", false);
      }

      //? OTHER -----------------------------------------------------------
      globalVariablesIds() {
        return this._globalVars;
      }

      globalSwitchesIds() {
        return this._globalSwitches;
      }

      //Input Max Length
      getTextInputMaxLength() {
        return this.getParam("textInputMaxLength", 12);
      }

      getLocaleValue(id, arg) {
        var value;
        value = this._localeDB[id] || (id.toString() + "*");
        if ((arg != null) && KString.any(arg.toString())) {
          value = value.replace("%1", arg);
        }
        return value;
      }

      //? NOT IN HEADER YET -------------------------------------

        // * Можно ли просматривать статус других игроков
      isOtherPlayersMenuStatusAllowed() {
        return true;
      }

      // * Видно ли других игроков в меню
      isOtherPlayersVisibleInMenu() {
        return true;
      }

      // * Ожидание получения действия от каждого игрока в битве
      isForceBattleSyncMode() {
        return true;
      }

      // * Время обновления данных игрока (на карте)
      playerDataRefreshRate() {
        return 60;
      }

      // * Время обновления данных в битве (влияет на производительность)
      battleDataRefreshRate() {
        return 60;
      }

      // * Настройки Trade сцены (визуальные)
      tradeSceneSettings() {} //TODO:

      
        //TODO: Параметр
      isSaveOnlyInMenu() {
        return false;
      }

      tradeSceneCompleteSE() {
        return "";
      }

      //$[EXPEREMENT, inDEV]
      //TODO: Параметр
      isMultiActorsMode() {
        return false;
      }

    };

    // * Создаём Shortcut для этого методы
    ANET.LV = function() {
      return ANET.PP.getLocaleValue(...arguments);
    };

    return ParamsManager;

  }).call(this);
  ANET.link(ParamsManager);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = ANET.ParamsManager.prototype;
  _._prepareParameters = function() {
    this._prepareConnectionSettings();
    this._preparePlayerActorName();
    this._prepareGlobalData();
    this._prepareLocaleValues();
  };
  //?VERSION
  //! У базовой версии свой метод!
  _._prepareConnectionSettings = function() {
    var p;
    p = this.getParam("connection", {
      serverIp: "195.161.41.20",
      serverPort: "3034",
      isHttpsConnection: false
    });
    this._ip = p.serverIp;
    this._port = p.serverPort;
    this._isHttps = p.isHttpsConnection;
    // * Это тут по сути не нужно (так как у базовой версии свой метод)
    if (this.isHTTPSConnection() && !ANET.isPro()) {
      window.alert("Only Alpha NET Z [PRO] supports HTTPS connection!");
      this._isHttps = false;
    }
  };
  _._preparePlayerActorName = function() {
    var p;
    p = this.getParam("playerActorNameType", "");
    switch (p) {
      case "Instead Name":
        this.playerActorNameType = function() {
          return 1;
        };
        break;
      case "Instead Nickname":
        this.playerActorNameType = function() {
          return 2;
        };
        break;
    }
  };
  // * Ничего, так как 0 по умолчанию
  _._prepareGlobalData = function() {
    var p;
    p = this.getParam("globalData", {
      globalSwitchesIds: [],
      globalVariablesIds: []
    });
    this._globalVars = p.globalVariablesIds;
    this._globalSwitches = p.globalSwitchesIds;
  };
  _._prepareLocaleValues = function() {
    var p;
    // * Чтобы не дублировать, тут используем {} пустой
    p = this.getParam("localeDB", {});
    // * Заполняем значение с учётом Default значений
    // * Так сделано, так как при добавлении новых, их может ещё не быть у пользователя
    this._localeDB = {
      network: p.network || "Network",
      createRoom: p.createRoom || "Create Room",
      joinRoom: p.joinRoom || "Join Room",
      joinRandomRoom: p.joinRandomRoom || "Join Random Room",
      settings: p.settings || "Settings",
      start: p.start || "Start",
      leave: p.leave || "Leave",
      joinGame: p.joinGame || "Join Game",
      ready: p.ready || "Ready",
      character: p.character || "Character",
      close: p.close || "Close",
      welcome: p.welcome || "Welcome, %1",
      playersCount: p.playersCount || "Players on server: %1"
    };
  };
})();

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------


class PlayersDataPool {
    constructor(anotherPlayersGetter) {
        this.anotherPlayersGetter = anotherPlayersGetter;
        this._isBooleanFlagMode = false;
        this._isReady = false;
        this._isTimedOut = false;
        this._repeatTimer = PlayersDataPool.REPEAT_TIMER_DEFAULT;
        this._timeout = PlayersDataPool.TIMEOUT_DEFAULT;
        this._anotherPlayersData = {};
        this.requestMethod = () => { };
        this._reset();
    }
    // * Режим ожидания не данных, а чтобы у всех был TRUE
    setFlagMode() {
        this._isBooleanFlagMode = true;
    }
    // * Главный метод -> отправка на сервер запроса
    register(requestMethod) {
        this.requestMethod = requestMethod;
        requestMethod();
    }
    update() {
        if (this.isReady())
            return; // * Чтобы цикла не было по вызову callback
        this._timeout--;
        if (this._repeatTimer >= 0) {
            this._repeatTimer--;
        }
        else {
            this._checkPool();
            if (!this.isReady()) {
                this._resetTimer();
                if (this._timeout > 0) {
                    this.register(this.requestMethod);
                }
                else {
                    this._isTimedOut = true;
                    if (this.failCallback)
                        this.failCallback();
                    // * Сброс (например если Timeout не предусмотрен, не задан метод failCallback)
                    this._resetTimeout();
                }
            }
            else {
                if (this.callback)
                    this.callback();
            }
        }
    }
    // * Проверка пула данных
    _checkPool() {
        let poolSize = 0;
        // * Подразумевается что в этом массиве только ID других игроков (кроме себя)
        const anotherPlayersIds = this.anotherPlayersGetter().map(pl => pl.actorId);
        for (const id of anotherPlayersIds) {
            if (this.isDataExistsFor(id))
                poolSize += 1;
        }
        if (poolSize === anotherPlayersIds.length) {
            // * Поэтому, когда пул полный, проверяем что данные от себя тоже есть
            this._isReady = this.isMyDataExists();
        }
        else {
            this._isReady = false;
        }
    }
    onReady(callback) {
        this.callback = callback;
    }
    onFail(failCallback) {
        this.failCallback = failCallback;
    }
    isReady() {
        return this._isReady === true;
    }
    isTimedOut() {
        return this._isTimedOut === true;
    }
    setMyData(data) {
        //@ts-ignore
        this.onAnswer(ANGameManager.myActorId(), data);
    }
    isMyDataExists() {
        //@ts-ignore
        return this.isDataExistsFor(ANGameManager.myActorId());
    }
    isDataExistsFor(actorId) {
        return this.getDataFor(actorId) !== undefined;
    }
    getDataFor(actorId) {
        return this._anotherPlayersData[actorId];
    }
    getData() {
        return this._anotherPlayersData;
    }
    // * Этот метод вызывается внешне, когда пришли данные от сервера
    onAnswer(actorId, data) {
        if (!this._isBooleanFlagMode) {
            this._anotherPlayersData[actorId] = data;
        }
        else {
            // * Если в режиме флагов, то только при TRUE присваиваем данные
            if (data === true) {
                this._anotherPlayersData[actorId] = data;
            }
            else {
                // * null, а не false, потому что проверка через ? идёт
                this._anotherPlayersData[actorId] = null;
                delete this._anotherPlayersData[actorId];
            }
        }
    }
    _reset() {
        this._resetTimer();
        this._resetTimeout();
        this._isReady = false;
        this._isBooleanFlagMode = false;
        this._isTimedOut = false;
        this._anotherPlayersData = {};
    }
    _resetTimer() {
        this._repeatTimer = PlayersDataPool.REPEAT_TIMER_DEFAULT;
    }
    _resetTimeout() {
        this._timeout = PlayersDataPool.TIMEOUT_DEFAULT;
    }
}
PlayersDataPool.REPEAT_TIMER_DEFAULT = 60;
PlayersDataPool.TIMEOUT_DEFAULT = 600;
window["PlayersDataPool"] = PlayersDataPool;


class PlayersWaitPool {
    constructor() {
        this._playersReady = {};
        this._repeatTimer = PlayersWaitPool.REPEAT_TIMER_DEFAULT;
        // * Запоминается при создании, чтобы можно было сбросить
        // * Это нужно, чтобы если игрок новый переместился на карту, его
        // * не добавили в ожидание, если на этой карте уже запущено общее событие
        //@ts-ignore
        this._anotherPlayersIds = ANGameManager.anotherPlayersOnMap().map(pl => pl.actorId);
        this.reset();
    }
    // * Зарегестрировать (отправить на сервер)
    register() {
        this._resetTimer();
        //@ts-ignore
        ANInterpreterManager.sendSharedEventRequireRegister();
    }
    // * Только один игрок (мастер события) запустил событие (один на карте или в игре)
    isSinglePool() {
        return this._anotherPlayersIds.length === 0;
    }
    // * Проверить, что игроки, которые в пуле, онлайн (не отключились)
    checkPool() {
        //@ts-ignore
        const playersOnMap = ANGameManager.anotherPlayersOnMap();
        for (const id of this._anotherPlayersIds) {
            // * Если игрока больше нет на карте, мы его удаляем из пула
            const player = playersOnMap.find(pl => pl.actorId === id);
            if (!player) {
                this._anotherPlayersIds = this._anotherPlayersIds.filter(playerId => playerId !== id);
                // * Игрок отключился, делаем ему true, чтобы можно было продолжить событие
                // * (в следующей команде он уже участвовать не будет, так как будет Reset)
                this._playersReady[id] = true;
            }
        }
    }
    // * Ответ от сервера
    onAnswer(actorId) {
        this._playersReady[actorId] = true;
    }
    update() {
        if (this._repeatTimer >= 0) {
            this._repeatTimer--;
        }
        else {
            if (!this.isReady()) {
                this.checkPool();
                this.register();
            }
        }
    }
    isReady() {
        for (const value of Object.values(this._playersReady)) {
            // * Если хоть одно значение false, значит не готов
            if (value === false)
                return false;
        }
        return true;
    }
    _resetTimer() {
        this._repeatTimer = PlayersWaitPool.REPEAT_TIMER_DEFAULT;
    }
    // * Сбросить до нового ожидания
    reset() {
        // * Добавляем себя как готового всегда (тут не важен именно ID)
        // * В принципе можно и не добавлять, так как важнее другие игроки
        this._playersReady = {
            myActorId: true
        };
        // * Добавляем всех игроков как изначально не готовых
        for (const id of this._anotherPlayersIds) {
            this._playersReady[id] = false;
        }
        this._resetTimer();
    }
}
PlayersWaitPool.REPEAT_TIMER_DEFAULT = 60;
window['PlayersWaitPool'] = PlayersWaitPool;


// Generated by CoffeeScript 2.7.0
// * Команды плагина
// * Нет класса или менеджера, так как только методы регистрации команд
(function() {
  var registerPluginCommandsMV, registerPluginCommandsMZ;
  // * Основной метод загрузки (регистрации команд плагина)
  ANET.loadPluginCommands = function() {
    if (KDX.isMZ()) {
      registerPluginCommandsMZ('Alpha_NETZ');
      return registerPluginCommandsMZ('Alpha_NETZ_MZ');
    } else {
      return registerPluginCommandsMV();
    }
  };
  registerPluginCommandsMZ = function(pluginName) {
    PluginManager.registerCommand(pluginName, 'EventCommandSelector', function(args) {
      var e;
      try {
        return this.nSetCommandOptions(args);
      } catch (error) {
        e = error;
        return console.warn(e);
      }
    });
    PluginManager.registerCommand(pluginName, 'SharedBattle', function(args) {
      var e;
      try {
        return this.nSetSharedBattle(args.battleId);
      } catch (error) {
        e = error;
        return console.warn(e);
      }
    });
  };
  registerPluginCommandsMV = function() {
    var e;
    try {
      // * Этот метод только для MV существует
      return ANET.registerMVPluginCommands();
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
})();


(function () {
    ANET['registerMVPluginCommands'] = function () {
        //@[ALIAS]
        var _Game_Interpreter_pluginCommand_ANET = Game_Interpreter.prototype.pluginCommand;
        Game_Interpreter.prototype.pluginCommand = function (command, args) {
            _Game_Interpreter_pluginCommand_ANET.call(this, command, args);
            if (command === 'SetSharedBattle') {
                try {
                    this.nSetSharedBattle(args[0]);
                }
                catch (e) {
                    console.warn(e);
                }
            }
        };
    };
})();


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SceneManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__changeScene, ALIAS__isGameActive, _;
  //@[DEFINES]
  _ = SceneManager;
  //? Всегда требует активного статуса чтобы всегда принимать данные от сервера
  //@[ALIAS]
  ALIAS__isGameActive = _.isGameActive;
  _.isGameActive = function() {
    if (ANNetwork.isConnected()) {
      return true;
    } else {
      return ALIAS__isGameActive.call(this);
    }
  };
  //@[ALIAS]
  ALIAS__changeScene = _.changeScene;
  _.changeScene = function() {
    if (ANNetwork.isConnected() && this.isSceneChanging()) {
      if (typeof HUIManager !== "undefined" && HUIManager !== null) {
        HUIManager.onGameSceneChanged();
      }
    }
    ALIAS__changeScene.call(this);
  };
})();

// ■ END SceneManager.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SceneManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = SceneManager;
  //? ONLY FOR MV
  _.isSceneReadyForNetwork = function() {
    return true;
  };
  // * Сцена занята для событий из сети (scene events) (общий метод для MV и MZ)
  _.isBusyForNetworkData = function() {
    return SceneManager.isSceneChanging() || !SceneManager.isSceneReadyForNetwork();
  };
})();

// ■ END SceneManager.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Base.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__isActive, ALIAS__terminate, ALIAS__update, _;
  //@[DEFINES]
  _ = Scene_Base.prototype;
  //@[ALIAS]
  ALIAS__isActive = _.isActive;
  _.isActive = function() {
    if (ANNetwork.isBusy()) {
      return false;
    } else {
      return ALIAS__isActive.call(this);
    }
  };
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    if (ANNetwork.isBusy()) {
      ANGameManager.updateWaiting();
    } else {
      ALIAS__update.call(this);
    }
    if (ANNetwork.isConnected()) {
      this.nUpdatePlayersActivityState();
    }
  };
  
  //@[ALIAS]
  ALIAS__terminate = _.terminate;
  _.terminate = function() {
    // * Смена сцены
    if (ANNetwork.isConnected()) {
      ANGameManager.sendSceneChanging();
    }
    return ALIAS__terminate.call(this);
  };
})();

// ■ END Scene_Base.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Base.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Scene_Base.prototype;
  //?EVENT
  // * Когда соединение прервано, вызывается это событие
  _.onLostConnection = function() {
    HUIManager.hideLoader();
    return SceneManager.goto(Scene_Title);
  };
  
  //?EVENT
  // * Когда закрывается комната, вызывается это событие
  _.netOn_lobby_roomClosed = function() {
    // * По умолчанию из любой сцены выходит в главное меню
    return SceneManager.goto(Scene_Title);
  };
  // * Когда пришло какое-либо сообщение от сервера
  //?EVENT
  _.onServerEvent = function(name) {
    var eventMethod;
    if (SceneManager.isBusyForNetworkData()) {
      return;
    }
    eventMethod = "netOn_" + name;
    if (this[eventMethod] != null) {
      if (ANET.isShowExtOutput()) {
        console.log("Call scene callback for event " + name);
      }
      this[eventMethod]();
    }
  };
  _.nUpdatePlayersActivityState = function() {
    /*if ANETUtils.isGameInActiveState()
        ANGameManager.sendRefreshActivityWhenInactive()
    else
        ANGameManager.sendRefreshActivityWhenActive()*/
    var e;
    try {
      if (!$gameTemp.__netAnyMapBeenLoaded) {

      }
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
})();

// ■ END Scene_Base.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Battle.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__changeInputWindow, ALIAS__commandFight, ALIAS__shouldAutosave, ALIAS__stop, ALIAS__updateBattleProcess, ALIAS__updateBattleProcessMV, ALIAS__updateTpbAutoBattle, _;
  //@[DEFINES]
  _ = Scene_Battle.prototype;
  // * В сетевом режиме автосхранения отключены
  //@[ALIAS]
  ALIAS__shouldAutosave = _.shouldAutosave;
  _.shouldAutosave = function() {
    if (ANNetwork.isConnected()) {
      return false;
    } else {
      return ALIAS__shouldAutosave.call(this);
    }
  };
  //@[ALIAS, STORED]
  _.ALIAS__NET_start = _.start;
  _.start = function() {
    // * Если бой в сетевом режиме и ещё не зарегестрирован, то сцена боя не отрисовывается
    if (ANNetwork.isConnected() && BattleManager.nIsNetworkBattle() && !ANBattleManager.isBattleRegistred()) {
      return;
    }
    // * Метод Start вызывается автоматически у SceneManager, поэтому когда
    // * данные прийдут, сцена старт
    _.ALIAS__NET_start.call(this);
    if (ANNetwork.isConnected()) {
      this.nOnBattleStarted();
    }
  };
  //@[ALIAS]
  ALIAS__stop = _.stop;
  _.stop = function() {
    ALIAS__stop.call(this);
    if (ANNetwork.isConnected()) {
      this.nOnBattleEnd();
    }
  };
  //TODO: Есть проблема, ввод доступен, пока ждём сервер battleMethod
  //TODO: Может просто деактивировать все окна? Чтобы нельзя было выбирать действие

  // * Игрок не может видеть команды "ввода" персонажей других игроков
  //@[ALIAS]
  ALIAS__changeInputWindow = _.changeInputWindow;
  _.changeInputWindow = function() {
    ALIAS__changeInputWindow.call(this);
    if (ANNetwork.isConnected() && BattleManager.isInputting() && !$gameParty.isOneBattler()) {
      if (BattleManager.actor() != null) {
        if (BattleManager.actor() !== $gameParty.leader()) {
          this.endCommandSelection();
        }
      }
    }
  };
  
  //@[ALIAS]
  ALIAS__commandFight = _.commandFight;
  _.commandFight = function() {
    if (ANNetwork.isConnected()) {
      // * Игрок снова должен сделать выбор
      BattleManager._isShouldWaitMyNetworkAction = true;
    }
    ALIAS__commandFight.call(this);
  };
  // * Должен идти перед переопределением общим, поэтому в этом файле
  if (KDX.isMV()) {
    //@[ALIAS]
    ALIAS__updateBattleProcessMV = _.updateBattleProcess;
    _.updateBattleProcess = function() {
      if (ANNetwork.isConnected()) {
        if (!this.isAnyInputWindowActive() || BattleManager.isAborting() || BattleManager.isBattleEnd()) {
          this.changeInputWindow();
        }
        return BattleManager.update(); // * Надо обновлять не зависимо от условия вверху
      } else {
        return ALIAS__updateBattleProcessMV.call(this);
      }
    };
  }
  //@[ALIAS]
  ALIAS__updateBattleProcess = _.updateBattleProcess;
  _.updateBattleProcess = function() {
    // * На данный момент, если игрок один в битве, то он ничего не отравляет на сервер
    if (ANNetwork.isConnected()) {
      if ($gameParty.isOneBattler()) {
        // * Только обновлять данные HP и MP другим игрокам
        $gameParty.leader().updateDataObserver();
      } else {
        // * Логика сетевого боя (общая для мастера и клиентов)
        this.nUpdateBattleProcess();
        if (ANGameManager.isBattleMaster()) {
          ANBattleManager.update();
          // * Если ждём сервер, то не обновляем BattleManager
          if (ANBattleManager.isShouldWaitServer()) {
            return;
          }
        } else {
          // * BattleManager update (ALIAS__updateBattleProcess) выполняет только мастер битвы
          if (!BattleManager.nIsLocalForceUpdatePhase()) {
            return;
          }
        }
      }
    }
    ALIAS__updateBattleProcess.call(this);
  };
  
  // * На всякий случай отключу автобитву
  //@[ALIAS]
  ALIAS__updateTpbAutoBattle = _.updateTpbAutoBattle;
  _.updateTpbAutoBattle = function() {
    if (ANNetwork.isConnected()) {

    } else {
      return ALIAS__updateTpbAutoBattle.call(this);
    }
  };
})();

// ■ END Scene_Battle.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Battle.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Scene_Battle.prototype;
  // * Когда пришли данные о битве от сервера (регистрация, новый участник)
  // * Этот метод выполняется на клиентах, которые УЖЕ в битве (а не на тех, кто присоединился)
  _.netOn_battle_serverBattleData = function() {
    var battler, battlerId, i, j, len, len1, ref, ref1;
    if ($gameTemp._previousNetBattleActors == null) {
      $gameTemp._previousNetBattleActors = [];
    }
    ref = $gameParty.battleMembers();
    // * Для всех новых, надо выполнять некоторые методы
    for (i = 0, len = ref.length; i < len; i++) {
      battler = ref[i];
      if (!$gameTemp._previousNetBattleActors.contains(battler.actorId())) {
        battler.onBattleStart();
        battler.makeActions();
      }
    }
    ref1 = $gameTemp._previousNetBattleActors;
    // * Всех старых, надо удалить из битвы
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      battlerId = ref1[j];
      if (!ANBattleManager.battleData.actors.contains(battlerId)) {
        $gameParty.removeActor(battlerId);
        BattleManager.nSafeRemoveActor();
      }
    }
    $gameTemp._previousNetBattleActors = [];
    $gamePlayer.refresh();
    $gameMap.requestRefresh();
    $gameTemp.requestBattleRefresh();
  };
  _.nOnBattleStarted = function() {
    // * Отправляем на сервер, что мы начали бой
    ANBattleManager.onBattleStarted();
  };
  _.nOnBattleEnd = function() {
    // * Отправляем на сервер, что мы покинули (закончили) бой
    ANBattleManager.onBattleEnd();
  };
  _.nUpdateBattleProcess = function() {
    var actor, enemy, i, j, len, len1, ref, ref1;
    // * За отправку данных отвечает только мастер боя
    if (ANGameManager.isBattleMaster()) {
      ref = $gameParty.battleMembers();
      for (i = 0, len = ref.length; i < len; i++) {
        actor = ref[i];
        actor.updateDataObserver();
      }
      ref1 = $gameTroop.members();
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        enemy = ref1[j];
        enemy.updateDataObserver();
      }
    }
  };
  _.nRefreshSharedBattle = function() {
    // * Обновить спрайты врагов
    return this._spriteset.nRefreshNetBattle();
  };
})();

// ■ END Scene_Battle.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Boot.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__initialize, ALIAS__start, _;
  //@[DEFINES]
  _ = Scene_Boot.prototype;
  // * Загружаем и инициализируем сетевой код
  //@[ALIAS]
  ALIAS__initialize = _.initialize;
  _.initialize = function() {
    ALIAS__initialize.call(this);
    ANET.extendLibrariesForExtensions(KDX, KDNUI, KColor, KNSprite);
    ANETSystem.initSystem();
  };
  // * Перезагружаем параметры плагина
  //@[ALIAS]
  ALIAS__start = _.start;
  _.start = function() {
    ALIAS__start.call(this, ...arguments);
    //? Это нужно чтобы eval от Graphics.width выполнился правильно
    ANETSystem.loadParameters();
  };
})();

// ■ END Scene_Boot.coffee
//---------------------------------------------------------------------------
//TODO: Remove this after testing
//@startNormalGame()
//SceneManager.goto(Scene_Map);


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Equip.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__needsPageButtons, _;
  //@[DEFINES]
  _ = Scene_Equip.prototype;
  //@[ALIAS]
  ALIAS__needsPageButtons = _.needsPageButtons;
  _.needsPageButtons = function() {
    // * В сетевом режиме нельзя переключать персонажей
    if (ANNetwork.isConnected()) {
      return false;
    } else {
      return ALIAS__needsPageButtons.call(this);
    }
  };
})();

// ■ END Scene_Equip.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_ItemBase.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__applyItem, _;
  //@[DEFINES]
  _ = Scene_ItemBase.prototype;
  //@[ALIAS]
  ALIAS__applyItem = _.applyItem;
  _.applyItem = function() {
    if (ANNetwork.isConnected()) {
      this.nPrepareApplyItemForNetwork();
    }
    ALIAS__applyItem.call(this);
    this.nClearApplyItemForNetwork();
  };
})();

// ■ END Scene_ItemBase.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_ItemBase.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Scene_ItemBase.prototype;
  //TODO: MV ???
  //TODO: Параметр? А как в PVP быть? Можно же "яд" применить на другого перед боем
  //TODO: На одной карте или нет? Куча параметров в общем!
  // * Когда нужно выполнить действие из меню на другого игрока (например применить зелье)
  _.nPrepareApplyItemForNetwork = function() {
    $gameTemp.netApplyItemUser = this.user();
    $gameTemp.netApplyItemItem = this.item();
  };
  // * Очищаем флаги, чтобы другим действиям не мешать
  _.nClearApplyItemForNetwork = function() {
    $gameTemp.netApplyItemUser = null;
    $gameTemp.netApplyItemItem = null;
  };
})();

// ■ END Scene_ItemBase.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Item.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Scene_Item.prototype;
})();

// ■ END Scene_Item.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Load.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__onSavefileOk, _;
  //@[DEFINES]
  _ = Scene_Load.prototype;
  if (KDX.isMZ()) {
    return;
  }
  // * В MV версии нету проверки на Enabled, так что доп. проверка
  //@[ALIAS]
  ALIAS__onSavefileOk = _.onSavefileOk;
  _.onSavefileOk = function() {
    // * Если сетевое сохранение, то НЕЛЬЗЯ загружать в обычной сцене загрузки
    if (DataManager.nIsNetworkSaveFile(this.savefileId())) {
      this.onLoadFailure();
    } else {
      ALIAS__onSavefileOk.call(this);
    }
  };
  
  // * В MV нету этого метода, добавим и будем использовать для загрузки сетевых сохранений
  //?[NEW]
  _.executeLoad = function(savefileId) {
    if (DataManager.loadGame(savefileId)) {
      this.onLoadSuccess();
    } else {
      this.onLoadFailure();
    }
  };
})();

// ■ END Scene_Load.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Load.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__initialize, ALIAS__onLoadFailure, ALIAS__terminate, _;
  //@[DEFINES]
  _ = Scene_Load.prototype;
  //@[ALIAS]
  ALIAS__initialize = _.initialize;
  _.initialize = function() {
    ALIAS__initialize.call(this);
    if (ANNetwork.isConnected() && $gameTemp._nRequestLoadNetworkGame === true) {
      if (KDX.isMZ()) {
        this.nLoadNetworkGameFromSavefile(); // * В MV в одном потоке, не переключает сцену сразу после инициализации
      } else {
        setTimeout((() => {
          return this.nLoadNetworkGameFromSavefile();
        }), 1);
      }
    }
  };
  //@[ALIAS]
  ALIAS__onLoadFailure = _.onLoadFailure;
  _.onLoadFailure = function() {
    // * Своя обработка ошибки загрузки в сетевом режиме
    if (ANNetwork.isConnected() && $gameTemp._nRequestLoadNetworkGame === true) {
      this.nOnLoadFailure();
    } else {
      ALIAS__onLoadFailure.call(this);
    }
  };
  //@[ALIAS]
  ALIAS__terminate = _.terminate;
  _.terminate = function() {
    ALIAS__terminate.call(this);
    // * Сбросим флаг
    $gameTemp._nRequestLoadNetworkGame = false;
  };
})();

// ■ END Scene_Load.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Load.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Scene_Load.prototype;
  _.nLoadNetworkGameFromSavefile = function() {
    var savefileId;
    savefileId = DataManager.nGetNetworkSaveFileIdByUniqueId(ANNetwork.room.uniqueSaveID);
    if (savefileId < 0) {
      this.nOnLoadFailure();
    } else {
      this.executeLoad(savefileId);
    }
  };
  _.nOnLoadFailure = function() {
    HUIManager.notifyError("Can't load Save file!");
    // * Через timeout а то не успевает, если сразу ошибка
    setTimeout((function() {
      return SceneManager.goto(Scene_Title);
    }), 1);
  };
})();

// ■ END Scene_Load.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__createSpriteset, ALIAS__onMapLoaded, ALIAS__onMapTouch, ALIAS__shouldAutosave, ALIAS__stop, _;
  //@[DEFINES]
  _ = Scene_Map.prototype;
  //@[ALIAS]
  ALIAS__onMapLoaded = _.onMapLoaded;
  _.onMapLoaded = function() {
    ALIAS__onMapLoaded.call(this);
    // * Если сцена была вызвана API командой из одиночного режима игры
    // * То мы должны закрыть сцену
    $gameTemp.__netAnyMapBeenLoaded = true;
    if ($gameTemp.__netShouldDisconnectAfterLocalModeScene === true) {
      if (ANNetwork.isConnected()) {
        ANNetwork.stop();
      }
      $gameTemp.__netShouldDisconnectAfterLocalModeScene = null;
    }
    if (ANNetwork.isConnected()) {
      ANGameManager.onMapLoaded();
      $gameParty.nRefreshNetworkActors();
      // * Сбрасываем режим "следовать"
      $gameTemp._netAutoFollowActorId = null;
    }
    // * На всякий случай (для чата и торговли)
    $gameTemp.kdButtonUnderMouse = null;
    $gameTemp.floatingWindowUnderMouse = null;
    setTimeout((function() {
      $gameTemp.kdButtonUnderMouse = null;
      return $gameTemp.floatingWindowUnderMouse = null;
    }), 10);
  };
  
  // * В сетевом режиме автосхранения отключены
  //@[ALIAS]
  ALIAS__shouldAutosave = _.shouldAutosave;
  _.shouldAutosave = function() {
    if (ANNetwork.isConnected()) {
      return false;
    } else {
      return ALIAS__shouldAutosave.call(this);
    }
  };
  //@[ALIAS]
  // * Создаём интерфейс
  ALIAS__createSpriteset = _.createSpriteset;
  _.createSpriteset = function() {
    ALIAS__createSpriteset.call(this);
    if (!ANNetwork.isConnected()) {
      return;
    }
    this._netUI = new ANET.Spriteset_UI();
    this.addChild(this._netUI);
  };
  // * Запрет движения при нажатии на UI элементы
  //@[ALIAS]
  ALIAS__onMapTouch = _.onMapTouch;
  _.onMapTouch = function() {
    if (ANNetwork.isConnected()) {
      if (ANET.UI.isUITouched()) {
        return;
      }
    }
    ALIAS__onMapTouch.call(this);
  };
  // * Закрываем интерфейс
  //@[ALIAS]
  ALIAS__stop = _.stop;
  _.stop = function() {
    ALIAS__stop.call(this);
    ANET.UI.terminate();
  };
})();

// ■ END Scene_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Scene_Map.prototype;
  //?EVENT
  // * Когда игрок выходит или входит в комнату (покидает игру)
  _.netOn_lobby_refreshRoomData = function() {
    //TODO: Если игрок отключился, надо общее событие!
    $gameParty.nRefreshNetworkActors();
    $gameMap.refreshNetworkCharacters();
  };
})();

// ■ END Scene_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_MenuBase.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Scene_MenuBase.prototype;
  //?EVENT
  // * Когда пришли какие-либо данные DataObserver
  _.netOn_game_observerData = function() {
    return this.refreshNetwork();
  };
  //?EVENT
  // * Когда игрок выходит или входит в комнату (покидает игру)
  _.netOn_lobby_refreshRoomData = function() {
    var e, ref;
    try {
      $gameParty.nRefreshNetworkActors();
      // * Если есть окно с персонажами, обновить его
      // * Можно было вынести в класс Scene_Menu, но не хочу плодить одинаковые методы
      // * Так как тут в Scene_MenuBase тоже нужен метод
      if ((ref = this._statusWindow) != null) {
        ref.refresh();
      }
    } catch (error) {
      //TODO: Сделать как и в ALphaNET общий Refresh всех окон сцены
      e = error;
      console.warn(e);
    }
  };
  // * Обновить все окна при изменениях данных из сети
  _.refreshNetwork = function() {
    var child, e, i, len, ref;
    if (!ANNetwork.isConnected()) {
      return;
    }
    try {
      this.updateActor();
      if (this._windowLayer == null) {
        return;
      }
      ref = this._windowLayer.children;
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        if ((child != null) && (child.refresh != null)) {
          child.refresh();
        }
      }
      return;
    } catch (error) {
      e = error;
      console.warn(e);
    }
  };
})();

// ■ END Scene_MenuBase.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Menu.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Scene_Menu.prototype;
})();

// ■ END Scene_Menu.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_NetworkGameMenu.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
var Scene_NetworkGameMenu;

Scene_NetworkGameMenu = class Scene_NetworkGameMenu extends Scene_MenuBase {
  constructor() {
    super();
    return;
  }

  //$[OVER]
  createButtons() {}

  create() {
    super.create();
    this._isInputAllowed = true;
    // * Например если вернулись "назад" на эту сцену, то не надо снова соединяться
    if (!ANNetwork.isConnected()) {
      this._initNetwork();
    } else {
      this._initSceneComponents();
      this.refreshWelcomeText();
    }
  }

  update() {
    var ref;
    super.update();
    this._updateBackButton();
    this._updateRandomJoin(); //2
    if ((ref = this._playerCountRefreshThread) != null) {
      ref.update();
    }
  }

  stop() {
    HUIManager.removeInput();
    HUIManager.hideLoader();
    return super.stop();
  }

  refreshWelcomeText() {
    var e, ref;
    try {
      return (ref = this.playerNameText) != null ? ref.refreshBindings(this) : void 0;
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  }

  refreshPlayersCountText(count = 0) {
    var e, ref;
    try {
      this._playersCountOnServer = count;
      return (ref = this.playersCountText) != null ? ref.refreshBindings(this) : void 0;
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  }

  // * Данный метод используется чтобы  заблокировать нажатие кнопкоп под HTML чатом
  setInputAllowed(isAllowed) {
    this._isInputAllowed = isAllowed;
  }

  inModalMode() {
    return this._isInModalMode === true;
  }

  isExitButtonVisible() {
    return !HUIManager.isLoaderActive() && !this.inModalMode();
  }

  isInputAllowed() {
    return this._isInputAllowed === true;
  }

  showModalWindow() {
    var ref;
    this.setInputAllowed(false);
    this._isInModalMode = true;
    return (ref = this.root) != null ? ref.refreshBindings(this) : void 0;
  }

  hideModalWindow() {
    var ref;
    this.setInputAllowed(true);
    this._isInModalMode = false;
    return (ref = this.root) != null ? ref.refreshBindings(this) : void 0;
  }

  //?EVENT
  netOn_lobby_changePlayerName() {
    var ref;
    this.refreshWelcomeText();
    if ((ref = this._playerCountRefreshThread) != null) {
      ref.call();
    }
  }

  //?EVENT
  // * Когда игрок выходит или входит в комнату
  // * Этот метод тут, чтобы перекрыть Scene_MenuBase реализацию
  // * Так как пока нет необходимости $gameParty менять
  netOn_lobby_refreshRoomData() {} // * NOTHING

};

(function() {
  var _;
  //@[DEFINES]
  _ = Scene_NetworkGameMenu.prototype;
  _._initNetwork = function() {
    HUIManager.showLoader();
    ANNetwork.initSystem();
    ANNetwork.setConnection(this._onConnectionStatus.bind(this));
  };
  //?EVENT
  // * 0 - error, 1 - connect
  _._onConnectionStatus = function(statusCode) {
    switch (statusCode) {
      case 0:
        this._onConnectionRefused();
        break;
      case 1:
        this._onConnectionGood();
    }
  };
  _._onConnectionRefused = function() {
    HUIManager.hideLoader();
    HUIManager.notifyError("Server not response in time");
    return this.popScene();
  };
  _._onConnectionGood = function() {
    HUIManager.hideLoader();
    if (!ANGameManager.isInited()) {
      ANGameManager.init();
    }
    HUIManager.notifySucess("Connected to server");
    return this._initSceneComponents();
  };
  // * Отрисовка меню, если соединение  было установлено
  _._initSceneComponents = function() {
    this.loadSceneNUIScheme();
    this._createPlayerCountRefreshThread();
  };
  _._updateBackButton = function() {
    var ref, ref1;
    if ((ref = this.exitButton) != null) {
      ref.refreshBindings(this);
    }
    if (Input.isCancel() && !HUIManager.isLoaderActive()) {
      if (this.inModalMode()) {
        this._cancelModalMode();
      } else {
        if (this.isInputAllowed()) {
          if (((ref1 = this.exitButton) != null ? ref1.visible : void 0) === true) {
            this._cancelNetworkScene();
          }
        }
      }
    }
  };
  _._cancelNetworkScene = function() {
    if (!this.isInputAllowed()) {
      return;
    }
    //TODO: PopUp message, are you sure?
    return this.popScene();
  };
})();

// ■ END Scene_NetworkGameMenu.coffee
//---------------------------------------------------------------------------
window['Scene_NetworkGameMenu'] = Scene_NetworkGameMenu;


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_NetworkGameMenu.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Scene_NetworkGameMenu.prototype;
  _._createPlayerCountRefreshThread = function() {
    var refreshMethod;
    refreshMethod = function() {
      return ANNetwork.callback(NetMessage.Lobby("playersCountOnServ"), (count) => {
        var e;
        try {
          if (SceneManager.isSceneChanging()) {
            return;
          }
          return this.refreshPlayersCountText(count);
        } catch (error) {
          e = error;
          return console.warn(e);
        }
      });
    };
    this._playerCountRefreshThread = new KDX.TimedUpdate(300, refreshMethod.bind(this));
    this._playerCountRefreshThread.call();
  };
  _._createRoom = function() {
    var ref, ref1, ref2, sprite;
    if (!this.isInputAllowed()) {
      return;
    }
    this.showModalWindow();
    sprite = KDNUI.FromScheme(ANET.GetNUIFile('NUI_NetworkScene_NewRoomModal'), this, this);
    HUIManager.showInput(sprite.uiConstant('inputTitleText'));
    sprite.refreshBindings(this);
    setTimeout((function() {
      return HUIManager.focusInput();
    }), 100);
    if ((ref = this.startGameButton) != null) {
      ref.addClickHandler(() => {
        return this._createNewRoom(HUIManager.getInputValue());
      });
    }
    if ((ref1 = this.loadGameModalButton) != null) {
      ref1.addClickHandler(() => {
        return this._loadGame();
      });
    }
    if ((ref2 = this.cancelRoomModalButton) != null) {
      ref2.addClickHandler(() => {
        return this._cancelModalMode();
      });
    }
  };
  _._cancelModalMode = function() {
    var ref, ref1;
    if ((ref = this.newRoomModalSprite) != null) {
      ref.removeFromParent();
    }
    if ((ref1 = this.settingsModalSprite) != null) {
      ref1.removeFromParent();
    }
    HUIManager.removeInput();
    this.hideModalWindow();
  };
  _._createNewRoom = function(roomName, uniqueSaveId = null) {
    var newRoomData;
    // * Используем название команаты с предыдущей сцены
    if (!KString.any(roomName)) {
      roomName = "Room_" + Math.randomInt(1000);
    }
    // * Собираем данные об новой комнате
    newRoomData = {
      name: roomName,
      gameInfo: ANETUtils.getNetworkGameInfoData(),
      uniqueSaveID: uniqueSaveId
    };
    // * Отправляем данные об текущей игре (клиенте)
    ANNetwork.get(NetMessage.Lobby("createRoom", newRoomData), (result) => {
      return this._onRoomCreated(result);
    }, () => {
      console.log("Can't create Room, server not response in time");
      return this._cancelModalMode();
    });
  };
  //?EVENT
  _._onRoomCreated = function(roomData) {
    if (roomData != null) {
      ANNetwork.setRoomMaster(roomData);
      // * Мастер всегда готов
      ANPlayersManager.sendPlayerInRoomReady(true);
      SceneManager.push(Scene_NetworkRoom);
    } else {
      HUIManager.notifyError("Can't create room with name: " + this._lastRoomName);
      this._cancelModalMode();
    }
  };
  _._joinRoom = function() {
    if (!this.isInputAllowed()) {
      return;
    }
    return SceneManager.push(Scene_NetworkRoomsList);
  };
  _._joinRandRoom = function() {
    if (!this.isInputAllowed()) {
      return;
    }
    this.roomsList = null; // * Обнуляем список комнат
    this.requestRoomsListFromServer();
    this._waitRoomsForRandomJoin = true;
  };
  _._openSettings = function() {
    var ref, sprite;
    if (!this.isInputAllowed()) {
      return;
    }
    this.showModalWindow();
    sprite = KDNUI.FromScheme(ANET.GetNUIFile('NUI_NetworkScene_SettingsModal'), this, this);
    HUIManager.showInput(sprite.uiConstant('inputTitleText'));
    HUIManager.setInputValue(ANGameManager.myPlayerData().name);
    setTimeout((function() {
      return HUIManager.focusInput();
    }), 100);
    if ((ref = this.savePlayerNameButton) != null) {
      ref.addClickHandler(() => {
        return this._savePlayerName(HUIManager.getInputValue());
      });
    }
  };
  _._loadGame = function() {
    var e, ref;
    if (!ANET.PP.isSaveLoadAllowed()) {
      return;
    }
    try {
      this.startGameButton.disable();
      this.loadGameModalButton.disable();
      this.cancelRoomModalButton.disable();
    } catch (error) {
      e = error;
      console.warn(e);
    }
    this._tempRoomName = HUIManager.getInputValue();
    HUIManager.removeInput();
    if ((ref = this.modalBackground) != null) {
      ref.visible = false;
    }
    this._createGamesToLoadList();
  };
  _._createGamesToLoadList = function() {
    var rect, wh, ww, wx, wy;
    ww = Graphics.boxWidth - 100;
    if (KDX.isMZ()) {
      wh = this.mainAreaHeight();
    } else {
      wh = Graphics.height - 20;
    }
    wx = (Graphics.boxWidth - ww) / 2;
    wy = (Graphics.boxHeight - wh) / 2;
    rect = new Rectangle(wx, wy, ww, wh);
    this._listWindow = new Window_SavefileList(rect);
    this._listWindow.setHandler("ok", this.onLoadFileSelected.bind(this));
    this._listWindow.setHandler("cancel", this.onLoadFileSelectCancel.bind(this));
    this._listWindow.setMode("loadNet", false);
    if (KDX.isMZ()) {
      this._listWindow.selectSavefile(0);
    } else {
      this._listWindow.select(0);
    }
    this._listWindow.refresh();
    this.addChild(this._listWindow);
    this._listWindow.activate();
  };
  _.onLoadFileSelected = function() {
    var info, savefileId;
    if (KDX.isMZ()) {
      savefileId = this._listWindow.savefileId();
    } else {
      savefileId = this._listWindow.index() + 1;
    }
    if (DataManager.nIsNetworkSaveFile(savefileId)) {
      info = DataManager.nGetInfoForSavefileId(savefileId);
      this._createNewRoom(this._tempRoomName, info.nUniqueSaveID);
    } else {
      SoundManager.playBuzzer();
      this._listWindow.activate();
    }
  };
  _.onLoadFileSelectCancel = function() {
    this._listWindow.hide();
    this.removeChild(this._listWindow);
    this._cancelModalMode();
  };
  _._savePlayerName = function(newName) {
    if (KString.any(newName)) {
      ANGameManager.myPlayerData().name = newName;
      // * Отправим на сервер
      ANPlayersManager.sendPlayerName();
      ConfigManager.netPlayerName = newName;
      ConfigManager.save();
    }
    this._cancelModalMode();
  };
})();

// ■ END Scene_NetworkGameMenu.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_NetworkGameMenu.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Scene_NetworkGameMenu.prototype;
  // * Методы обработки подключения к случайной комнате
  _.requestRoomsListFromServer = function() {
    ANNetwork.get(NetMessage.Lobby("getRoomsList"), (result) => {
      return this.roomsList = result;
    }, () => {
      // * Timeout
      console.log("Server not returns rooms list in time");
      return this._onCantJointRandomRoom();
    });
  };
  _._onCantJointRandomRoom = function() {
    this._waitRoomsForRandomJoin = false;
    HUIManager.notifyError("No available open rooms to join");
  };
  // * Ждём список комнат и пытаемся подключиться к случайной
  _._updateRandomJoin = function() {
    var randomRoomName;
    if (!this._waitRoomsForRandomJoin) {
      return;
    }
    if (this.roomsList == null) {
      return;
    }
    this._waitRoomsForRandomJoin = false;
    this.applyFiltersToRoomList();
    if (this.roomsList.length === 0) {
      this._onCantJointRandomRoom();
    } else {
      randomRoomName = this.roomsList.sample().name;
      this.joinToRoomRequest(randomRoomName);
    }
  };
  _.applyFiltersToRoomList = function() {
    if (this.roomsList == null) {
      this.roomsList = [];
    }
    if (this.roomsList.length === 0) {
      return;
    }
    this.roomsList = this.roomsList.filter((r) => {
      return this.isProperRoomToJoin(r);
    });
  };
  _.isProperRoomToJoin = function(roomData) {
    return NetRoomDataWrapper.isRoomProperToJoin(roomData);
  };
  _.joinToRoomRequest = function(roomName) {
    ANNetwork.get(NetMessage.Lobby("joinToRoom", roomName), (result) => {
      return this._onJoinedToRoom(result);
    }, function() {
      return console.log("Can't join to Room, server not response in time");
    });
  };
  //?EVENT
  _._onJoinedToRoom = function(roomData) {
    if (roomData == null) {
      console.log("Can't join to Room, Room not exists anymore");
    } else {
      ANNetwork.setRoomJoin(roomData);
      SceneManager.push(Scene_NetworkRoom);
    }
  };
})();

// ■ END Scene_NetworkGameMenu.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_NetworkGameMenu.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Scene_NetworkGameMenu.prototype;
  _.getPlayersCount = function() {
    return this._playersCountOnServer || 1;
  };
  _.getPlayerName = function() {
    var e;
    try {
      if (ANGameManager.myPlayerData() != null) {
        return ANGameManager.myPlayerData().name;
      }
    } catch (error) {
      e = error;
      console.warn(e);
    }
    return "Player";
  };
  _.loadSceneNUIScheme = function() {
    var ref, ref1, ref2, ref3, ref4;
    KDNUI.FromScheme(ANET.GetNUIFile('NUI_NetworkScene'), this, this);
    if ((ref = this.exitButton) != null) {
      ref.addClickHandler(() => {
        return this._cancelNetworkScene();
      });
    }
    if ((ref1 = this.newRoomButton) != null) {
      ref1.addClickHandler(() => {
        return this._createRoom();
      });
    }
    //@loadGameButton?.addClickHandler(=> @_loadGame())
    if ((ref2 = this.joinRoomButton) != null) {
      ref2.addClickHandler(() => {
        return this._joinRoom();
      });
    }
    if ((ref3 = this.joinRandomRoomButton) != null) {
      ref3.addClickHandler(() => {
        return this._joinRandRoom();
      });
    }
    if ((ref4 = this.settingsButton) != null) {
      ref4.addClickHandler(() => {
        return this._openSettings();
      });
    }
  };
})();

// ■ END Scene_NetworkGameMenu.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
var Scene_NetworkRoom;

Scene_NetworkRoom = class Scene_NetworkRoom extends Scene_MenuBase {
  constructor() {
    super();
    this._startingGameTransition = false;
  }

  create() {
    super.create();
    this.room = ANNetwork.room;
    this.loadSceneNUIScheme();
    if (this.isLoadGame()) {
      this.prepareSaveFile();
    }
    this.refreshRoom();
  }

  //$[OVER]
  createButtons() {}

  loadSceneNUIScheme() {
    var ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7;
    KDNUI.FromScheme(ANET.GetNUIFile('NUI_RoomLobbyScene'), this, this);
    if ((ref = this.exitButton) != null) {
      ref.setClickHandler(this.exitFromRoom.bind(this));
    }
    if ((ref1 = this.startGameButton) != null) {
      ref1.setClickHandler(this._onStartRoomCommand.bind(this));
    }
    if ((ref2 = this.readyButton) != null) {
      ref2.setClickHandler(this._onReadyInRoomCommand.bind(this));
    }
    if ((ref3 = this.characterSelectButton) != null) {
      ref3.setClickHandler(this._onCharacterSelectCommand.bind(this));
    }
    if ((ref4 = this.joinInGameButton) != null) {
      ref4.setClickHandler(this._onJoinAlreadyGameCommand.bind(this));
    }
    if ((ref5 = this.actorsListElement) != null) {
      ref5.list.deactivate();
    }
    if ((ref6 = this.actorsListElement) != null) {
      ref6.visible = false;
    }
    if ((ref7 = this.actorsListElement) != null) {
      ref7.list.setOkHandler(this._onActorSelectOk.bind(this));
    }
  }

  start() {
    super.start();
    ANNetwork.requestRoomRefresh();
    // * Так как есть искуственная задержка загрузки сцены на MV
    if (KDX.isMV()) {
      setTimeout((function() {
        try {
          return ANNetwork.requestRoomRefresh();
        } catch (error) {

        }
      }), 300);
    }
  }

  isBottomHelpMode() {
    return false;
  }

  isLoadGame() {
    return ANETUtils.isLoadGameRoom();
  }

  refreshRoom() {
    this.room = ANNetwork.room;
    this._refreshButtons();
    this._refreshRoomTitle();
    this._refreshPlayerList();
    this._refreshActorsList();
  }

  //?EVENT
  // * Когда игрок выходит или входит в комнату
  netOn_lobby_refreshRoomData() {
    // * Пришли данные о комнате (и игроках), надо обновить
    return this.refreshRoom();
  }

  //?EVENT
  // * Когда игрок выбирает персонажа
  netOn_game_playersData() {
    // * Пришли данные о комнате (и игроках), надо обновить
    return this.refreshRoom();
  }

  //?EVENT
  netOn_lobby_startGame() {
    this._startingGameTransition = true;
    if (this.isLoadGame()) {
      this.loadAndStartGame();
    } else {
      this.startNewGame();
    }
  }

  //?EVENT
  // * Когда закрывается комната, вызывается это событие
  netOn_lobby_roomClosed() {
    if (!this._shouldNotPopScene) {
      // * Из этой сцены мы возвращаемся в сетевое меню (если мы не мастер)
      // * Для мастера не надо, так как сцена и так закрывается сама и получается
      // * что возврат происходит на Scene_Title
      //TODO: Когда идёт запрос на подключение в запущенную игру надо его прервать!
      return this.popScene();
    }
  }

  update() {
    var ref;
    super.update();
    if (Input.isCancel() && !HUIManager.isLoaderActive()) {
      if (((ref = this.actorsListElement) != null ? ref.visible : void 0) === true) {
        return this.switchToPlayersList();
      } else {
        return this.exitFromRoom();
      }
    }
  }

  stop() {
    super.stop();
    // * Если TRUE - значит мы переходим на сцену с игрой и не надо закрывать коммнату
    if (this._startingGameTransition === true) {
      return;
    }
    if (ANNetwork.isMasterClient()) {
      this._shouldNotPopScene = true;
      return ANNetwork.closeRoom();
    } else {
      return ANNetwork.leaveRoom();
    }
  }

  getRoomName() {
    return ANNetwork.room.name;
  }

  isRoomHosted() {
    return ANNetwork.isMasterClient();
  }

  isStartedRoom() {
    return ANETUtils.isStartedRoom();
  }

  isCanSelectActors() {
    return ANET.PP.isActorSelectionAllowed() && !this.isLoadGame();
  }

  isNeedStartGameButton() {
    return ANNetwork.isMasterClient();
  }

  isNeedReadyButton() {
    return ANET.PP.isCheckPlayerReadyState() && !ANNetwork.isMasterClient() && !this.isStartedRoom();
  }

  isNeedJoinButton() {
    return !ANNetwork.isMasterClient() && this.isStartedRoom();
  }

  isStartButtonIsEnabled() {
    return this._isStartEnabled();
  }

  isReadyButtonIsEnabled() {
    return this._isReadyEnabled();
  }

  isJoinButtonIsEnabled() {
    return this._isJoinInAlreadyGameEnabled();
  }

  isCharSelectButtonIsEnabled() {
    return this._isCharSelectEnabled();
  }

  isNeedCharacterSelectButton() {
    return this.isCanSelectActors();
  }

  isMenuVisible() {
    if (this.actorsListElement != null) {
      if (this.actorsListElement.visible === true) {
        return false;
      }
    }
    return true;
  }

  _refreshButtons() {
    var ref;
    return (ref = this.menuGroup) != null ? ref.refreshBindings(this) : void 0;
  }

  _refreshPlayers() {}

  exitFromRoom() {
    return this.popScene();
  }

  switchToActorsList() {
    var ref, ref1, ref2, ref3;
    if ((ref = this.actorsListElement) != null) {
      ref.list.activate();
    }
    if ((ref1 = this.actorsListElement) != null) {
      ref1.visible = true;
    }
    if ((ref2 = this.playersListElement) != null) {
      ref2.visible = false;
    }
    if ((ref3 = this.menuGroup) != null) {
      ref3.deactivateHandlerManagment();
    }
    this._refreshActorsList();
    this._refreshButtons();
  }

  switchToPlayersList() {
    var ref, ref1, ref2, ref3;
    if ((ref = this.actorsListElement) != null) {
      ref.list.deactivate();
    }
    if ((ref1 = this.actorsListElement) != null) {
      ref1.visible = false;
    }
    if ((ref2 = this.playersListElement) != null) {
      ref2.visible = true;
    }
    if ((ref3 = this.menuGroup) != null) {
      ref3.activateHandlerManagment();
    }
    this._refreshPlayerList();
    this._refreshButtons();
  }

};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ Scene_NetworkRoom.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = Scene_NetworkRoom.prototype;
  _.startNewGame = function() {
    // * Сейчас нету _commandWindow, так что временно создадим его чтобы не было ошибки
    this._commandWindow = {
      close: function() {}
    };
    Scene_Title.prototype.commandNewGame.call(this);
  };
  _.loadAndStartGame = function() {
    // * Задаём флаг, что будем загружать сетевую игру
    $gameTemp._nRequestLoadNetworkGame = true;
    SceneManager.push(Scene_Load);
  };
  _._refreshRoomTitle = function() {
    var ref, ref1;
    if ((ref = this.roomNameText) != null) {
      ref.refreshBindings(this);
    }
    return (ref1 = this.hostedInfoRect) != null ? ref1.refreshBindings(this) : void 0;
  };
  _._refreshPlayerList = function() {
    var playerItems;
    if (this.playersListElement == null) {
      return;
    }
    playerItems = ANGameManager.playersData.map(function(pl) {
      if (pl != null) {
        return new Sprite_NetworkRoom_PlayerListItem(pl);
      }
    });
    this.playersListElement.list.setItems(playerItems);
  };
  _._onStartRoomCommand = function() {
    if (!this.isStartButtonIsEnabled()) {
      return;
    }
    if (this._isAllInRoomReady()) { // TODO: В Wrapper, так как окно тоже проверяет
      if (ANNetwork.isMasterClient()) {
        ANNetwork.send(NetMessage.Lobby("startGame"));
      }
    }
  };
  _._onReadyInRoomCommand = function() {
    var playerData;
    if (!this.isReadyButtonIsEnabled()) {
      return;
    }
    playerData = ANGameManager.myPlayerData();
    ANPlayersManager.sendPlayerInRoomReady(!playerData.isReadyInRoom);
    this._refreshButtons();
  };
  _._onCharacterSelectCommand = function() {
    if (!this.isCharSelectButtonIsEnabled()) {
      return;
    }
    if (this.isCanSelectActors()) {
      this.switchToActorsList();
    }
  };
  //TODO: Флаги готовности, сбрасывать при нажатии Character
  // * См. readyPlayersIds у данных комнаты
  _._isAllInRoomReady = function() {
    return true;
  };
  _._onActorSelectOk = function() {
    var ref, selectedActor, selectedActorId;
    if (this.actorsListElement == null) {
      return;
    }
    selectedActor = this.actorsListElement.list.selectedItem();
    selectedActorId = (ref = selectedActor.characterData) != null ? ref.id : void 0;
    if (selectedActorId <= 0 || selectedActor.isPicked()) {
      SoundManager.playBuzzer();
      this.actorsListElement.list.activate();
    } else {
      ANPlayersManager.sendBindActorFromLobby(selectedActorId, this._onBindActorResult.bind(this));
    }
  };
  _._onBindActorResult = function(resultFlag) {
    if (resultFlag === true) {
      this.switchToPlayersList();
    } else {
      SoundManager.playBuzzer();
      this.actorsListElement.list.activate();
    }
    this.refreshRoom();
  };
  _._refreshActorsList = function() {
    var actorsItems;
    if (this.actorsListElement == null) {
      return;
    }
    actorsItems = ANET.PP.actorsForNetwork().map(function(actorId) {
      var actor;
      actor = $dataActors[actorId];
      return new Sprite_NetworkRoom_CharacterListItem(actor);
    });
    this.actorsListElement.list.setItems(actorsItems);
  };
  _.prepareSaveFile = function() {
    var info;
    info = DataManager.nGetNetworkSaveInfoWithId(this.room.uniqueSaveID);
    if (info == null) {
      HUIManager.notifyError("Save file data not found!");
      console.warn("Save file with ID " + this.room.uniqueSaveID + " not found!");
      this.popScene.bind(this);
    } else {
      //TODO: На сервере нет проверки на занятость персонажа??? НЕТУ в 112
      ANPlayersManager.sendBindActorFromLobby(info.nMyActorId, this.onBindLoadedActorResult.bind(this));
    }
  };
  _.onBindLoadedActorResult = function(resultFlag) {
    if (resultFlag === false) {
      SoundManager.playBuzzer();
      HUIManager.notifyError("Can't load Actor data or Actor already used by another player");
      this.popScene.bind(this);
    } else {
      this.refreshRoom();
    }
  };
  _._onJoinAlreadyGameCommand = function() {
    if (!this.isJoinButtonIsEnabled()) {
      return;
    }
    console.log("Send request worldData");
    ANGameManager.sendStartedRoomGameDataRequest(this._onJoinedAlreadyStartedGameComplete.bind(this), function() {
      return HUIManager.notifyError("Unable to join game");
    });
  };
  _._onJoinedAlreadyStartedGameComplete = function(data) {
    var content, e;
    console.log("!!! JOINED TO THE GAME !!!");
    if (KDX.isMZ()) {
      StorageManager.loadObjectFormNet(data).then((content) => {
        //console.info(content)
        return this._onJoinedAlreadyStartedGameSuccess(content);
      }).catch(function() {
        return HUIManager.notifyError("Unable to join game");
      });
    } else {
      try {
        content = JsonEx.parse(data);
        this._onJoinedAlreadyStartedGameSuccess(content);
      } catch (error) {
        e = error;
        console.warn(e);
      }
    }
  };
  _._onJoinedAlreadyStartedGameSuccess = function(content) {
    this._startingGameTransition = true;
    // * Регистрируем себя в комнате (получаем Player Index)
    ANGameManager.sendJoinedToStartedGame();
    DataManager.createGameObjects();
    DataManager.extractSaveContents(content);
    if (KDX.isMZ()) {
      DataManager.correctDataErrors();
    }
    ANGameManager.applyJoinedDataCorrects();
    SceneManager.goto(Scene_Map);
  };
  _._myActorId = function() {
    return ANGameManager.myPlayerData().actorId;
  };
  _._isAllPlayersSelectActors = function() {
    return ANGameManager.playersData.every(function(pl) {
      return pl.actorId !== 0;
    });
  };
  _._isStartEnabled = function() {
    if (!ANET.PP.isSingleActorNetworkGameAllowed()) {
      if (ANGameManager.playersData.length === 1) {
        return false;
      }
    }
    // * Надо выбрать персонажа, потом можно начинать игру
    if (this.isCanSelectActors() || this.isLoadGame()) {
      //TODO: Разрешить загружаться меньшему количеству игроков??? Опция или НЕТ?
      // * Сейчас может загрузить игру два игрока, если играло 3 или более например
      return this._isAllPlayersSelectActors() && this._isAllPlayersReady();
    } else {
      return this._isAllPlayersReady();
    }
  };
  _._isReadyEnabled = function() {
    if (this.isCanSelectActors()) {
      return !this._isCharSelectEnabled();
    } else {
      return true;
    }
  };
  _._isCharSelectEnabled = function() {
    return this._myActorId() <= 0;
  };
  _._isJoinInAlreadyGameEnabled = function() {
    if (!ANET.PP.isJoinStartedRoomAllowed()) {
      return false;
    }
    if (this.isCanSelectActors()) {
      return this._isAllPlayersSelectActors();
    } else {
      return true; // * Тут сразу можно, без Ready, т.е. игра уже запущена, никого ждать не надо
    }
  };
  
  // * Проверка, что все игроки готовы (только визуальная)
  _._isAllPlayersReady = function() {
    if (ANET.PP.isCheckPlayerReadyState()) {
      // * У себя (хоста) автоматически ставится флаг готов при создании комнаты
      return ANGameManager.playersData.every(function(pl) {
        return pl.isReadyInRoom === true;
      });
    } else {
      return true; // * Всегда да, если параметр отключён
    }
  };
})();

// ■ END Scene_NetworkRoom.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
// * Сцена со списком комнат на сервере
var Scene_NetworkRoomsList;

Scene_NetworkRoomsList = class Scene_NetworkRoomsList extends Scene_MenuBase {
  constructor() {
    super();
  }

  create() {
    super.create();
    // * Сейчас опасно, так как может быть уже 4 из 4, а информация не обновилась
    this._refreshRoomsListThread = new KDX.TimedUpdate(60, this._requestRoomsListFromServer.bind(this));
    this.loadSceneNUIScheme();
    this._requestRoomsListFromServer();
  }

  refreshRooms() {
    var existsItem, existsItems, i, isNeedUpdateList, len, r, ref, roomsItems;
    if (ANET.PP.isRoomFilterON()) {
      this.applyFilterToRooms();
    }
    if (this.roomsList == null) {
      this.roomsList = [];
    }
    if (this.roomsListElement != null) {
      roomsItems = this.roomsList.map((roomData) => {
        return this.createRoomItem(roomData);
      });
      // * Avoid list flickering
      if (roomsItems.length !== this.roomsListElement.list.getAllItems().length) {
        this.roomsListElement.list.setItems(roomsItems);
      } else {
        isNeedUpdateList = false;
        existsItems = this.roomsListElement.list.getAllItems();
        for (i = 0, len = roomsItems.length; i < len; i++) {
          r = roomsItems[i];
          existsItem = existsItems.find(function(e) {
            return e.getHashCode() === r.getHashCode();
          });
          if (existsItem == null) {
            isNeedUpdateList = true;
            break;
          }
        }
        if (isNeedUpdateList === true) {
          this.roomsListElement.list.setItems(roomsItems);
        }
      }
    }
    if ((ref = this.noRoomsMessageText) != null) {
      ref.refreshBindings(this);
    }
  }

  createRoomItem(roomData) {
    return new Sprite_NetworkRoomsListItem(roomData);
  }

  isNoRooms() {
    var ref;
    return ((ref = this.roomsList) != null ? ref.length : void 0) === 0;
  }

  //?VERSION
  applyFilterToRooms() {}

  update() {
    super.update();
    this._refreshRoomsListThread.update();
    return this._updateBackButton();
  }

};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = Scene_NetworkRoomsList.prototype;
  _.loadSceneNUIScheme = function() {
    var ref, ref1, ref2;
    KDNUI.FromScheme(ANET.GetNUIFile('NUI_RoomsListScene'), this, this);
    if ((ref = this.backButton) != null) {
      ref.addClickHandler(() => {
        return this.popScene();
      });
    }
    if ((ref1 = this.roomsListElement) != null) {
      ref1.list.setOkHandler(() => {
        return this._onJoinRoomCommand();
      });
    }
    if ((ref2 = this.roomsListElement) != null) {
      ref2.list.activate();
    }
  };
  _._updateBackButton = function() {
    if (Input.isCancel() && !HUIManager.isLoaderActive()) {
      this.popScene();
    }
  };
  _._requestRoomsListFromServer = function() {
    // * В первый раз показываем Loader
    if (this.roomsList == null) {
      HUIManager.showLoader();
    }
    ANNetwork.callback(NetMessage.Lobby("getRoomsList"), (result) => {
      // * Если сцена была закрыта, а комнаты пришли
      if (!(SceneManager._scene instanceof Scene_NetworkRoomsList)) {
        return;
      }
      this.roomsList = result;
      if (this.roomsList == null) {
        return;
      }
      this.refreshRooms();
      return HUIManager.hideLoader();
    });
    this.refreshRooms();
  };
  _._onJoinRoomCommand = function() {
    var item, ref, ref1, roomData;
    item = this.roomsListElement.list.selectedItem();
    if (item == null) {
      //SoundManager.playBuzzer()
      if ((ref = this.roomsListElement) != null) {
        ref.list.activate();
      }
      return;
    }
    roomData = item.roomData;
    if (NetRoomDataWrapper.isRoomProperToJoin(roomData)) {
      ANNetwork.get(NetMessage.Lobby("joinToRoom", roomData.name), (result) => {
        return this._onJoinedToRoom(result);
      }, () => {
        var ref1;
        console.log("Can't join to Room, server not response in time");
        return (ref1 = this.roomsListElement) != null ? ref1.list.activate() : void 0;
      });
    } else {
      SoundManager.playBuzzer();
      if ((ref1 = this.roomsListElement) != null) {
        ref1.list.activate();
      }
    }
  };
  
  //?EVENT
  _._onJoinedToRoom = function(roomData) {
    var ref;
    if (roomData == null) {
      console.log("Can't join to Room, Room not exists anymore");
      if ((ref = this.roomsListElement) != null) {
        ref.list.activate();
      }
    } else {
      ANNetwork.setRoomJoin(roomData);
      SceneManager.push(Scene_NetworkRoom);
    }
  };
})();

// ■ END PRIVATE.coffee
//---------------------------------------------------------------------------

//TODO: События на обработку: список комнат обновлися, успешное подключение, плохое подключение


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Save.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__onSavefileOk, ALIAS__stop, ALIAS__update, _;
  //@[DEFINES]
  _ = Scene_Save.prototype;
  // * В MV нету метода executeSave, создадим его для совместимости
  if (KDX.isMV()) {
    //?[NEW, from MZ]
    _.executeSave = function(savefileId) {
      $gameSystem.onBeforeSave();
      if (DataManager.saveGame(savefileId)) {
        this.onSaveSuccess();
      } else {
        this.onSaveFailure();
      }
    };
    // * Переопределим стандартный метод (только в МВ)
    // * Теперь в сетевом режиме он будет использовать новый метод executeSave
    //@[ALIAS]
    ALIAS__onSavefileOk = _.onSavefileOk;
    _.onSavefileOk = function() {
      if (ANNetwork.isConnected()) {
        Scene_File.prototype.onSavefileOk.call(this);
        this.executeSave(this.savefileId());
      } else {
        ALIAS__onSavefileOk.call(this);
      }
    };
  }
  //@[ALIAS, STORED]
  _.nALIAS__executeSave_43243 = _.executeSave;
  _.executeSave = function(savefileId) {
    if (ANNetwork.isConnected()) {
      if (ANET.PP.isSaveOnlyInMenu()) {
        //TODO:
        //@nRequestClientsStatesForSave(savefileId)
        this.nExecuteNetworkSave(savefileId);
      } else {
        this.nExecuteNetworkSave(savefileId);
      }
    } else {
      _.nALIAS__executeSave_43243.call(this, savefileId);
    }
  };
  
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    ALIAS__update.call(this);
    if (!ANNetwork.isConnected()) {
      return;
    }
    if (this.nSaveDataPool == null) {
      return;
    }
    this.nUpdateSavePool();
  };
  //@[ALIAS]
  ALIAS__stop = _.stop;
  _.stop = function() {
    ALIAS__stop.call(this);
    this.nClearTempSaveData();
  };
})();

// ■ END Scene_Save.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Save.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Scene_Save.prototype;
  _.nUpdateSavePool = function() {
    var ref;
    return (ref = this.nSaveDataPool) != null ? ref.update() : void 0;
  };
  _.nCreateTempSaveData = function() {
    // * Делаем глобальную переменную чтобы DataManager мог перехватить данные
    $gameTemp.nSaveData = this.nSaveDataPool;
    // * Чтобы у всех был одинаковый, нужно при опредлении какой файл загружать
    $gameTemp.nUniqueSaveID = ANETUtils.generateSaveUniqueId();
  };
  _.nClearTempSaveData = function() {
    $gameTemp.nSaveData = null;
    return $gameTemp.nUniqueSaveID = null;
  };
  // * Запросить проверку статуса других игроков
  // * чтобы они не были "заняты" (например битва или событие)
  // * сейчас используется проверка, что все должны быть в меню
  _.nRequestClientsStatesForSave = function(savefileId) {};
  //TODO: пропустим пока что

  // * Отправить всем команду что нужны данные для сохранения
  _.nExecuteNetworkSave = function(savefileId) {
    // * Создаём пул данных сохранений для каждого игрока
    this.nSaveDataPool = new PlayersDataPool(function() {
      return ANGameManager.anotherPlayers();
    });
    // * Задаём сразу свои данные
    this.nSaveDataPool.setMyData(DataManager.makeSaveContents());
    // * Задаём методы callbacks
    this.nSaveDataPool.onFail(() => {
      return this.nOnWaitSaveDataDone(-1); // * fail
    });
    this.nSaveDataPool.onReady(() => {
      return this.nOnWaitSaveDataDone(savefileId);
    });
    this.nCreateTempSaveData();
    // * Посылаем запрос на сервер ($gameTemp.nUniqueSaveID должен быть уже создан)
    this.nSaveDataPool.register(function() {
      return ANGameManager.sendSaveDataRequest(savefileId);
    });
    this.nOnWaitSaveDataStart();
  };
  _.nOnWaitSaveDataStart = function() {
    return HUIManager.showLoader(600);
  };
  _.nOnWaitSaveDataDone = function(savefileId) {
    HUIManager.hideLoader();
    console.log("SAVE DATA RECEIVED", savefileId);
    if (savefileId >= 0) {
      // * Вызываем стандартный метод
      _.nALIAS__executeSave_43243.call(this, savefileId);
    } else {
      this.onSaveFailure();
    }
  };
})();

// ■ END Scene_Save.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Skill.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__needsPageButtons, _;
  //@[DEFINES]
  _ = Scene_Skill.prototype;
  //@[ALIAS]
  ALIAS__needsPageButtons = _.needsPageButtons;
  _.needsPageButtons = function() {
    // * В сетевом режиме нельзя переключать персонажей
    if (ANNetwork.isConnected()) {
      return false;
    } else {
      return ALIAS__needsPageButtons.call(this);
    }
  };
})();

// ■ END Scene_Skill.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Status.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__needsPageButtons, ALIAS__start, ALIAS__stop, _;
  //@[DEFINES]
  _ = Scene_Status.prototype;
  //@[ALIAS]
  ALIAS__needsPageButtons = _.needsPageButtons;
  _.needsPageButtons = function() {
    // * В сетевом режиме зависит от параметра
    if (ANNetwork.isConnected()) {
      // * Если в режиме просмотра статуса определённого игрока - нет
      if ($gameTemp._netRequestStatusForCertainActorId != null) {
        return false;
      } else {
        return ANET.PP.isOtherPlayersMenuStatusAllowed();
      }
    } else {
      return ALIAS__needsPageButtons.call(this);
    }
  };
  
  //@[ALIAS]
  ALIAS__start = _.start;
  _.start = function() {
    var actor;
    ALIAS__start.call(this);
    // * Показываем статус определённого игрока по сети (для Player Menu опции)
    if (ANNetwork.isConnected() && $gameTemp._netRequestStatusForCertainActorId > 0) {
      actor = $gameActors.actor($gameTemp._netRequestStatusForCertainActorId);
      if (actor != null) {
        this._actor = actor;
        this.refreshActor();
      }
    }
  };
  //@[ALIAS]
  ALIAS__stop = _.stop;
  _.stop = function() {
    ALIAS__stop.call(this);
    $gameTemp._netRequestStatusForCertainActorId = null;
  };
})();

// ■ END Scene_Status.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Title.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__start, ALIAS__update, _;
  //@[DEFINES]
  _ = Scene_Title.prototype;
  //@[ALIAS]
  ALIAS__start = _.start;
  _.start = function() {
    ALIAS__start.call(this);
    if (ANNetwork.isConnected()) {
      ANNetwork.stop();
    }
    $gameTemp.__netAnyMapBeenLoaded = false;
    if (ANET.isDEV() || ANET.PP.isQuickDevConnectionAllowed()) {
      console.log("Precc C for quick connect");
    }
  };
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    ALIAS__update.call(this);
    if (ANET.isDEV() || ANET.PP.isQuickDevConnectionAllowed()) {
      //if ANET.PP.serverIp() == 'localhost'
      this.nUpdateDebugStart();
    }
  };
  (function() {    // * Добавляем команду сетевой игры в главное меню
    //else
    //window.alert("Quick connection allowed only to localhost!")
    var ALIAS__calcWindowHeight, ALIAS__commandWindowRect, ALIAS__createCommandWindow;
    
    //@[ALIAS]
    ALIAS__createCommandWindow = _.createCommandWindow;
    _.createCommandWindow = function() {
      ALIAS__createCommandWindow.call(this);
      return this._commandWindow.setHandler("network", this.commandNetwork.bind(this));
    };
    //@[ALIAS]
    ALIAS__commandWindowRect = _.commandWindowRect;
    _.commandWindowRect = function() {
      if (ANET.PP.isAddNetGameCmdToTitleMenu()) {
        // * little trick to not overwrite method
        this.___isOneMoreCommand = !Imported.VisuMZ_0_CoreEngine;
      } else {
        this.___isOneMoreCommand = false;
      }
      return ALIAS__commandWindowRect.call(this);
    };
    //@[ALIAS]
    ALIAS__calcWindowHeight = _.calcWindowHeight;
    _.calcWindowHeight = function(numLines, selectable) {
      if (this.___isOneMoreCommand === true) {
        numLines += 1;
        if (!ANET.PP.isSinglePlayerAllowed()) {
          // * Если одиночная игра не доступна, то нет одной позиции в меню (Новая ира)
          numLines -= 1;
        }
      }
      return ALIAS__calcWindowHeight.call(this, numLines, selectable);
    };
  })();
})();

// ■ END Scene_Title.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Title.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Scene_Title.prototype;
  (function() {    // DEV FAST GAME START
    // --------------------------------------------------------
    // * Метод только для отладки (быстрый старт на кнопку C)
    _.nUpdateDebugStart = function() {
      if (Input.isTriggered('c')) {
        this.nFastConnectToDevRoom();
      }
      if ($gameTemp._isDevNetGameWaitPlayers === true) {
        if (ANGameManager.playersData.length > 1) {
          return this.nFastGameStart();
        }
      }
    };
    //?EVENT
    _.netOn_lobby_startGame = function() {
      if ($gameTemp._isDevNetGameStart !== true) {
        return;
      }
      Scene_Title.prototype.commandNewGame.call(this);
    };
    _.nFastConnectToDevRoom = function() {
      if (ANET.PP.isActorSelectionAllowed()) {
        console.warn("Can't quick connect with Actor Select mode is ON");
        window.alert("Can't quick connect with Actor Select mode is ON");
        return;
      }
      ANNetwork.initSystem();
      return ANNetwork.setConnection(function(status) {
        if (status === 1) {
          HUIManager.notifySucess("Connected to server");
          ANGameManager.init();
          return ANNetwork.get(NetMessage.Lobby("createRoom", {
            name: "dev",
            gameInfo: ANETUtils.getNetworkGameInfoData()
          }), function(roomData) {
            if (roomData != null) {
              ANNetwork.setRoomMaster(roomData);
              return $gameTemp._isDevNetGameWaitPlayers = true;
            } else {
              return ANNetwork.get(NetMessage.Lobby("joinToRoom", "dev"), function(roomData) {
                $gameTemp._isDevNetGameStart = true;
                return ANNetwork.setRoomJoin(roomData);
              }, function() {
                return console.log("Can't join to Room, server not response in time");
              });
            }
          }, function() {
            return console.log("Can't create Room, server not response in time");
          });
        } else {
          return HUIManager.notifyError("Server not response in time");
        }
      });
    };
    _.nFastGameStart = function() {
      if (ANNetwork.isMasterClient()) {
        $gameTemp._isDevNetGameStart = true;
        return ANNetwork.send(NetMessage.Lobby("startGame"));
      }
    };
  })();
  //?EVENT
  // * Когда соединение прервано, вызывается это событие
  _.onLostConnection = function() {}; // * NOTHING
  _.commandNetwork = function() {
    this._commandWindow.close();
    return SceneManager.push(Scene_NetworkGameMenu);
  };
})();

// ■ END Scene_Title.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
// * Элементы интерфейса ANET Z на карте

// * Интерфейс AABS на карте
(function() {
  var Spriteset_UI;
  Spriteset_UI = class Spriteset_UI extends Sprite {
    constructor() {
      super();
      this._init();
      return;
    }

    isActive() {
      return this.visible === true;
    }

    show() {
      return this.visible = true;
    }

    hide() {
      return this.visible = false;
    }

    terminate() {
      this.visible = false;
    }

    // * Обновить все контроллеры и элементы
    refresh() {}

    onGameMessageStart() {}

    onGameMessageEnd() {}

  };
  ANET.link(Spriteset_UI);
})();

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ PRIVATE
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = ANET.Spriteset_UI.prototype;
  _._init = function() {
    // * Регестрирует себя в менеджере
    ANET.UI.setUI(this);
    // * Набор всех элементов
    this.elements = [];
    // * Набор всех контроллеров
    this.controllers = [];
    return this._create();
  };
  _._create = function() {
    return this._createNormalUILayer();
  };
  _._createNormalUILayer = function() {
    this.layer = new Sprite();
    return this.addChild(this.layer);
  };
  // * Добавить элемент на обычный слой
  _._addElementToUI = function(sprite) {
    return this.layer.addChild(sprite);
  };
})();

// ■ END PRIVATE
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Actor.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__retreat, _;
  //@[DEFINES]
  _ = Sprite_Actor.prototype;
  //TEMP
  //TODO: Временное врешение, работает только на мастере
  //@[ALIAS]
  ALIAS__retreat = _.retreat;
  _.retreat = function() {
    if (ANNetwork.isConnected()) {
      if ($gameParty.leader() === this._battler) {
        return this.startMove(300, 0, 30);
      } else {

      }
    } else {
      // * Другой персонаж не убегает
      return ALIAS__retreat.call(this);
    }
  };
})();

// ■ END Sprite_Actor.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__setCharacter, ALIAS__updateOther, _;
  //@[DEFINES]
  _ = Sprite_Character.prototype;
  //@[ALIAS]
  ALIAS__updateOther = _.updateOther;
  _.updateOther = function() {
    ALIAS__updateOther.call(this);
    this._updateNetworkCharacter();
    this._updateNetworkOther();
  };
  
  //@[ALIAS]
  ALIAS__setCharacter = _.setCharacter;
  _.setCharacter = function(character) {
    ALIAS__setCharacter.call(this, character);
    this._isNetworkCharacter = ANNetwork.isConnected() && character instanceof NETCharacter;
    // * Смена методов
    if (this._isNetworkCharacter === true) {
      this._updateNetworkCharacter = this._updateNetworkCharacterMain;
    }
  };
})();

// ■ END Sprite_Character.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Character.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Sprite_Character.prototype;
  //?DYNAMIC
  // * Данный метод подключается только для NetChar
  _._updateNetworkCharacter = function() {}; // * DUMMY
  _._updateNetworkCharacterMain = function() {
    return this._updateNetworkStateIcon();
  };
  _._updateNetworkStateIcon = function() {
    if (this.netStateIcon == null) {
      this._createNetworkStateIcon();
    } else {
      this.netStateIcon.x = this.x;
      this.netStateIcon.y = this.y - this.height;
    }
  };
  _._createNetworkStateIcon = function() {
    var e, ref;
    this.netStateIcon = new ANET.Sprite_PlayerNetworkStatus(this);
    this.netStateIcon.setupNETCharacter(this._character);
    try {
      // * Не лучший способ
      if ((ref = SceneManager._scene._spriteset) != null) {
        ref.addNetworkStatusIconForCharacter(this.netStateIcon);
      }
    } catch (error) {
      e = error;
      console.warn(e);
    }
  };
  // * Данный метод работает для всех персонажей (NetChar, событие, игрок...)
  // ? Работает всегда, даже когда NOT CONNECTED
  _._updateNetworkOther = function() {}; // * EMPTY NOW
})();

// ■ END Sprite_Character.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_Gauge.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__smoothness, _;
  if (KDX.isMV()) {
    return;
  }
  //@[DEFINES]
  _ = Sprite_Gauge.prototype;
  //@[ALIAS]
  ALIAS__smoothness = _.smoothness;
  _.smoothness = function() {
    // * Делаем более плавное заполнение для сетевой битвы, чтобы не было видно "рывков"
    // * Рывки есть так как с сервера данные обновляются примерно раз в секунду в бою
    if (ANNetwork.isConnected()) {
      if (this._statusType === "time" && $gameParty.inBattle()) {
        return 60;
      }
    }
    return ALIAS__smoothness.call(this);
  };
})();

// ■ END Sprite_Gauge.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
var Sprite_NetworkRoom_CharacterListItem;

Sprite_NetworkRoom_CharacterListItem = class Sprite_NetworkRoom_CharacterListItem extends KNSpriteWithScheme {
  constructor(characterData) {
    super();
    this.characterData = characterData;
    if (this.characterData != null) {
      this.refreshBindings(this);
    }
    return;
  }

  _scheme() {
    return ANET.GetNUIFile('NUI_RoomLobbyCharacterItem');
  }

  refresh() {
    if (this.characterData != null) {
      return this.refreshBindings(this);
    }
  }

  activateInList() {
    var ref;
    this._isActiveInList = true;
    return (ref = this.listItemSelected) != null ? ref.refreshBindings(this) : void 0;
  }

  deactivateInList() {
    var ref;
    this._isActiveInList = false;
    return (ref = this.listItemSelected) != null ? ref.refreshBindings(this) : void 0;
  }

  isActiveInList() {
    return this._isActiveInList === true;
  }

  getActorFaceImage() {
    var e;
    try {
      if (this.characterData != null) {
        return ANETUtils.getActorFaceForNetwork(this.characterData);
      }
    } catch (error) {
      e = error;
      console.warn(e);
    }
    return "faceNoActor";
  }

  getActorName() {
    var e;
    try {
      if (this.characterData != null) {
        return this.characterData.name;
      }
    } catch (error) {
      e = error;
      console.warn(e);
    }
    return "???";
  }

  getActorClassName() {
    var e;
    try {
      if (this.characterData != null) {
        return $dataClasses[this.characterData.classId].name;
      }
    } catch (error) {
      e = error;
      console.warn(e);
    }
    return "???";
  }

  isPicked() {
    var actorId, e;
    try {
      if (this.characterData == null) {
        return false;
      }
      actorId = this.characterData.id;
      return ANGameManager.playersData.some(function(pl) {
        return pl.actorId === actorId;
      });
    } catch (error) {
      e = error;
      console.warn(e);
    }
    return false;
  }

};


// Generated by CoffeeScript 2.7.0
var Sprite_NetworkRoom_PlayerListItem;

Sprite_NetworkRoom_PlayerListItem = class Sprite_NetworkRoom_PlayerListItem extends KNSpriteWithScheme {
  constructor(playerData) {
    super();
    this.playerData = playerData;
    if (this.playerData != null) {
      this.refreshBindings(this);
    }
    return;
  }

  _scheme() {
    return ANET.GetNUIFile('NUI_RoomLobbyPlayerItem');
  }

  refresh() {
    if (this.playerData != null) {
      return this.refreshBindings(this);
    }
  }

  activateInList() {
    return this._isActiveInList = true;
  }

  deactivateInList() {
    return this._isActiveInList = false;
  }

  isActiveInList() {
    return this._isActiveInList === true;
  }

  isLoadGame() {
    return ANETUtils.isLoadGameRoom();
  }

  isStartedRoom() {
    return ANETUtils.isStartedRoom();
  }

  isCanSelectActors() {
    return ANET.PP.isActorSelectionAllowed();
  }

  isMyPlayer() {
    if (this.playerData != null) {
      return this.playerData.id === ANNetwork.myId();
    } else {
      return false;
    }
  }

  getActorFaceImage() {
    var actor, e, possibleActorId;
    try {
      if (this.playerData != null) {
        if (this.playerData.actorId > 0) {
          actor = $dataActors[this.playerData.actorId];
          if (actor != null) {
            return ANETUtils.getActorFaceForNetwork(actor);
          }
        } else if (!this.isCanSelectActors()) {
          possibleActorId = ANET.PP.actorsForNetwork()[ANGameManager.playersData.indexOf(this.playerData)];
          actor = $dataActors[possibleActorId];
          if (actor != null) {
            return ANETUtils.getActorFaceForNetwork(actor);
          }
        }
      }
    } catch (error) {
      e = error;
      console.warn(e);
    }
    return "faceNoActor";
  }

  getActorName() {
    var actor, actorName, e, possibleActorId;
    try {
      if (this.isCanSelectActors()) {
        actorName = this.uiConstant('notSelectedActorText');
      } else {
        actorName = "";
      }
      if (this.playerData == null) {
        return actorName;
      }
      if (this.playerData.actorId > 0) {
        actorName = $dataActors[this.playerData.actorId].name;
      } else if (!this.isCanSelectActors()) {
        possibleActorId = ANET.PP.actorsForNetwork()[ANGameManager.playersData.indexOf(this.playerData)];
        actor = $dataActors[possibleActorId];
        if (actor != null) {
          actorName = actor.name;
        }
      }
      return actorName;
    } catch (error) {
      e = error;
      console.warn(e);
    }
    return "???";
  }

  isReady() {
    var e;
    try {
      if (!ANET.PP.isCheckPlayerReadyState()) {
        return false;
      }
      if (this.playerData == null) {
        return false;
      }
      if (this.isCanSelectActors()) {
        if (!(this.playerData.actorId > 0)) {
          return false;
        }
      }
      return this.playerData.isReadyInRoom === true;
    } catch (error) {
      e = error;
      console.warn(e);
    }
    return false;
  }

  isHost() {
    var e;
    try {
      if (this.playerData != null) {
        return this.playerData.id === ANNetwork.room.masterId;
      }
    } catch (error) {
      e = error;
      console.warn(e);
    }
    return false;
  }

  readyStateText() {
    if (this.isStartedRoom() && NetPlayerDataWrapper.isHaveCharacterInGame(this.playerData)) {
      return this.uiConstant('inGameStateText');
    } else {
      if (this.isReady()) {
        return this.uiConstant('readyStateText');
      }
    }
    return "";
  }

};


// Generated by CoffeeScript 2.7.0
var Sprite_NetworkRoomsListItem;

Sprite_NetworkRoomsListItem = class Sprite_NetworkRoomsListItem extends KNSpriteWithScheme {
  constructor(roomData) {
    super();
    this.roomData = roomData;
    this._prepareData();
    this.refreshBindings(this);
    return;
  }

  getHashCode() {
    var hashCode;
    hashCode = "" + this.getRPGMakerVersionIcon() + this.roomData.uniqueSaveID + this.getGameTitle() + this.getRoomName() + this.getPlayersCount() + this.getMaxPlayers() + this.getRoomStateText();
    return hashCode;
  }

  isRPGMVGame() {
    return this._rpgVersion === 'MV';
  }

  getRPGMakerVersionIcon() {
    if (this.isRPGMVGame()) {
      return 'rpgMv';
    }
    return 'rpgMz';
  }

  getGameTitle() {
    if (this.roomData != null) {
      return this.roomData.gameTitle;
    } else {
      return "???";
    }
  }

  getRoomName() {
    if (this.roomData != null) {
      return this.roomData.name;
    } else {
      return "???";
    }
  }

  getPlayersCount() {
    var e;
    try {
      if ((this.roomData != null) && (this.roomData.playersIds != null)) {
        return this.roomData.playersIds.length;
      }
    } catch (error) {
      e = error;
      console.warn(e);
    }
    return 0;
  }

  getMaxPlayers() {
    var e;
    try {
      if (this.roomData != null) {
        return this.roomData.maxPlayers || 0;
      }
    } catch (error) {
      e = error;
      console.warn(e);
    }
    return 0;
  }

  getRoomStateText() {
    return this._roomState || 'unknown';
  }

  getIsLoadedGame() {
    return this._isLoadGame || false;
  }

  activateInList() {
    this._isActiveInList = true;
    return this.listItemSelected.refreshBindings(this);
  }

  deactivateInList() {
    this._isActiveInList = false;
    return this.listItemSelected.refreshBindings(this);
  }

  isActiveInList() {
    return this._isActiveInList === true;
  }

  isDisabled() {
    return !NetRoomDataWrapper.isRoomProperToJoin(this.roomData);
  }

  _prepareData() {
    if (this.roomData == null) {
      return;
    }
    this._isActiveInList = false;
    this._rpgVersion = this.roomData.rpgVersion === 0 ? 'MZ' : 'MV';
    this._roomState = this.roomData.inGame === true ? 'In Game' : 'In Lobby';
    this._isLoadGame = NetRoomDataWrapper.isLoadGameRoom(this.roomData) ? true : false;
  }

  _scheme() {
    return ANET.GetNUIFile('NUI_RoomsListItem');
  }

};


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Sprite_PlayerNetworkStatus.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var Sprite_PlayerNetworkStatus;
  Sprite_PlayerNetworkStatus = class Sprite_PlayerNetworkStatus extends Sprite_Balloon {
    constructor() {
      super();
      this.visible = false;
      return;
    }

    setupNETCharacter(_character) {
      this._character = _character;
      return this._checkStateThread = new KDX.TimedUpdate(10, this._updateStateCheck.bind(this));
    }

    loadBitmap() {
      this.bitmap = ImageManager.loadNETZ("PlayerStateIcons");
      return this.setFrame(0, 0, 0, 0);
    }

    setup(iconId) {
      if (iconId == null) {
        if (this.visible === true) {
          this.reset();
        }
      } else {
        if (this._balloonId === iconId) {
          return;
        }
        this._balloonId = iconId;
        this.visible = true;
        this.restart();
      }
    }

    restart() {
      return this._duration = 5 * this.speed() + this.waitTime();
    }

    reset() {
      this._duration = 0;
      this._balloonId = -1;
      return this.visible = false;
    }

    // * Не используется, так как прикрепляется к персонажу
    updatePosition() {} // * EMPTY

    update() {
      super.update();
      this._checkStateThread.update();
      // * Начинается снова
      if (this._balloonId >= 0 && this._duration <= 0) {
        this._firstStep = true;
        return this.restart();
      }
    }

    frameIndex() {
      var frameIndex, index;
      index = (this._duration - this.waitTime()) / this.speed();
      frameIndex = 4 - Math.max(Math.floor(index), 0);
      if (this._firstStep == null) {
        return frameIndex;
      } else {
        if (frameIndex === 0) {
          return 1;
        } else {
          return frameIndex;
        }
      }
    }

    // * PRIVATE =====================================================
    _updateStateCheck() {
      if (this._character == null) {
        return;
      }
      this.setup(this._character.networkStateIcon);
    }

  };
  ANET.link(Sprite_PlayerNetworkStatus);
})();

// ■ END Sprite_PlayerNetworkStatus.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_Battle.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Spriteset_Battle.prototype;
  // * Началась битва
  // * Проверим и спрячем "dead" врагов (если мы присоединились)
  _.nRefreshNetBattle = function() {
    var e, i, len, ref, ref1, s;
    try {
      // * Если мы мастер, то не надо, значит мы НЕ присоединились
      if (ANBattleManager.isBattleMaster()) {
        return;
      }
      ref = this._enemySprites;
      for (i = 0, len = ref.length; i < len; i++) {
        s = ref[i];
        if (s == null) {
          continue;
        }
        if (!((ref1 = s._enemy) != null ? ref1.isAlive() : void 0)) {
          s.hide();
        }
      }
    } catch (error) {
      e = error;
      console.warn(e);
    }
  };
})();

// ■ END Spriteset_Battle.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__createCharacters, _;
  //@[DEFINES]
  _ = Spriteset_Map.prototype;
  //@[ALIAS]
  ALIAS__createCharacters = _.createCharacters;
  _.createCharacters = function() {
    ALIAS__createCharacters.call(this);
    if (ANNetwork.isConnected()) {
      this._createNetworkCharacters();
      this._createNetworkCharactersInfo();
    }
  };
})();

// ■ END Spriteset_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Spriteset_Map.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Spriteset_Map.prototype;
  _._createNetworkCharacters = function() {
    // * Отдельный массив для удобства
    this._networkCharacterSprites = [];
    this.refreshNetworkCharacters();
  };
  _.refreshNetworkCharacters = function() {
    var char, i, j, len, len1, ref, ref1, spr;
    ref = this._networkCharacterSprites;
    for (i = 0, len = ref.length; i < len; i++) {
      char = ref[i];
      this._removeNetCharInfo(char);
      this._characterSprites.delete(char);
      this._tilemap.removeChild(char);
    }
    this._networkCharacterSprites = [];
    ref1 = $gameMap.netChars();
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      char = ref1[j];
      spr = new Sprite_Character(char);
      this._characterSprites.push(spr);
      this._networkCharacterSprites.push(spr);
      this._tilemap.addChild(spr);
    }
  };
  
  // * Специальный слой для иконок статусов и имён сетевых персонажей
  _._createNetworkCharactersInfo = function() {
    this._networkCharactersInfoSprites = [];
    this._networkCharactersInfoLayer = new Sprite();
    this._networkCharactersInfoLayer.z = 9;
    this._tilemap.addChild(this._networkCharactersInfoLayer);
  };
  // * Добавить иконку статуса для персонажа
  _.addNetworkStatusIconForCharacter = function(iconSpr) {
    this._destroyNetStatusIconDuplicate(iconSpr);
    this._networkCharactersInfoSprites.push(iconSpr);
    this._networkCharactersInfoLayer.addChild(iconSpr);
  };
  
  // * Надо найти и удалить, если икона уже существует для персонажа
  // * при refreshNetworkCharacters, их иконки не удаляются с ними
  // * так как находятся на другом слое
  _._destroyNetStatusIconDuplicate = function(iconSpr) {
    var i, len, ref, spr;
    if (iconSpr == null) {
      return;
    }
    ref = this._networkCharactersInfoSprites;
    //TODO: Возможно после создания таблиц имён надо разлелить метод
    // так как сейчас удаляется любой спрайт из массива с соответсвием персонажа
    for (i = 0, len = ref.length; i < len; i++) {
      spr = ref[i];
      if (spr == null) {
        continue;
      }
      if (spr._character === iconSpr._character) {
        this._networkCharactersInfoLayer.removeChild(spr);
        this._networkCharactersInfoSprites.delete(spr);
      }
    }
  };
  // * Удаляет все связанные с персонажем спрайты информации (статус, имя)
  _._removeNetCharInfo = function(char) {
    if (char == null) {
      return;
    }
    return this._destroyNetStatusIconDuplicate(char.netStateIcon);
  };
})();

// ■ END Spriteset_Map.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ StorageManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = StorageManager;
  _.saveObjectForNet = function(object) {
    return this.objectToJson(object).then((json) => {
      return this.jsonToZip(json);
    }).then(function(zip) {
      return $gameTemp._startedRoomGameDataResponse = zip;
    });
  };
  _.loadObjectFormNet = function(object) {
    return this.zipToJson(object).then((json) => {
      return this.jsonToObject(json);
    });
  };
})();

// ■ END StorageManager.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Window_BattleLog.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__showNormalAnimation, _;
  //@[DEFINES]
  _ = Window_BattleLog.prototype;
  if (KDX.isMZ()) {
    return;
  }
  //@[ALIAS]
  ALIAS__showNormalAnimation = _.showNormalAnimation;
  _.showNormalAnimation = function(targets, animationId, mirror) {
    ALIAS__showNormalAnimation.call(this, targets, animationId, mirror);
    if (this.isNeedSendLogToServer() && KDX.isMV()) {
      ANBattleManager.sendWindowLogAnimation(targets, animationId, mirror);
    }
  };
})();

// ■ END Window_BattleLog.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Window_BattleLog.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__addText, ALIAS__clear, _;
  //@[DEFINES]
  _ = Window_BattleLog.prototype;
  //@[ALIAS]
  ALIAS__clear = _.clear;
  _.clear = function() {
    ALIAS__clear.call(this);
    if (this.isNeedSendLogToServer()) {
      return ANBattleManager.sendWindowLogMessage("clear", null);
    }
  };
  //@[ALIAS]
  ALIAS__addText = _.addText;
  _.addText = function(text) {
    ALIAS__addText.call(this, text);
    if (this.isNeedSendLogToServer()) {
      ANBattleManager.sendWindowLogMessage("add", text);
    }
  };
})();

// ■ END Window_BattleLog.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Window_BattleLog.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Window_BattleLog.prototype;
  _.isNeedSendLogToServer = function() {
    return ANNetwork.isConnected() && ANGameManager.isBattleMaster() && !$gameParty.isOneBattler();
  };
})();

// ■ END Window_BattleLog.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Window_BattleStatus.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__update, _;
  //@[DEFINES]
  _ = Window_BattleStatus.prototype;
  if (KDX.isMZ()) {
    return;
  }
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    ALIAS__update.call(this);
    if ($gameTemp.isBattleRefreshRequested()) {
      this.refresh();
      $gameTemp.clearBattleRefreshRequest();
    }
  };
})();

// ■ END Window_BattleStatus.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Window_ChoiceList.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__initialize, ALIAS__isCancelEnabled, ALIAS__isCursorMovable, ALIAS__isOkEnabled, ALIAS__processCancel, ALIAS__processOk, ALIAS__select, ALIAS__start, ALIAS__update, _;
  //TODO: ПРОВЕРИТЬ НА MV

  //@[DEFINES]
  _ = Window_ChoiceList.prototype;
  //@[ALIAS]
  ALIAS__isCursorMovable = _.isCursorMovable;
  _.isCursorMovable = function() {
    if (this.nIsNetworkSelection()) {
      return ANInterpreterManager.isSharedEventMaster();
    } else {
      return ALIAS__isCursorMovable.call(this);
    }
  };
  //@[ALIAS]
  ALIAS__isOkEnabled = _.isOkEnabled;
  _.isOkEnabled = function() {
    if (this.nIsNetworkSelection() && !ANInterpreterManager.isSharedEventMaster()) {
      return false;
    }
    return ALIAS__isOkEnabled.call(this);
  };
  //@[ALIAS]
  ALIAS__isCancelEnabled = _.isCancelEnabled;
  _.isCancelEnabled = function() {
    if (this.nIsNetworkSelection() && !ANInterpreterManager.isSharedEventMaster()) {
      return false;
    }
    return ALIAS__isCancelEnabled.call(this);
  };
  //@[ALIAS]
  ALIAS__update = _.update;
  _.update = function() {
    ALIAS__update.call(this);
    if (this.nIsNetworkSelection()) {
      this.nUpdateNetworkSelection();
    }
  };
  // * Можно это тоже, но не обязательно, и так выбор не может сделать второй игрок
  //@[ALIAS]
  //ALIAS__processHandling = _.processHandling
  //_.processHandling = ->
  //    return if @nIsNetworkSelection() && !ANInterpreterManager.isSharedEventMaster()
  //    return ALIAS__processHandling.call(@)

  //@[ALIAS]
  //ALIAS__processTouch = _.processTouch
  //_.processTouch = ->
  //    return if @nIsNetworkSelection() && !ANInterpreterManager.isSharedEventMaster()
  //    return ALIAS__processTouch.call(@)

  //@[ALIAS]
  ALIAS__select = _.select;
  _.select = function(index) {
    if (this.nIsNetworkSelection()) {
      // * Если мастер, то выбор проходит и отправляем всем выбор
      if (ANInterpreterManager.isSharedEventMaster()) {
        ALIAS__select.call(this, index);
        return this.nSendNetworkSelection(index);
      } else {
        // * Если не мастер, но выбор пришёл с сервера (т.е. есть флаг), то ставим выбор
        if (this.nIsSelectFromNetworkMaster === true) {
          this.nIsSelectFromNetworkMaster = false;
          return ALIAS__select.call(this, index);
        } else {

        }
      }
    } else {
      // * NOTHING
      // * Клиент сам не может менять выбор
      return ALIAS__select.call(this, index);
    }
  };
  
  //@[ALIAS]
  ALIAS__initialize = _.initialize;
  _.initialize = function() {
    ALIAS__initialize.call(this, ...arguments);
    if (ANNetwork.isConnected()) {
      this.nSetNetworkSelectMode(false);
    }
  };
  //@[ALIAS]
  ALIAS__start = _.start;
  _.start = function() {
    if (ANNetwork.isConnected()) {
      this.nPrepareNetworkSelection();
    }
    ALIAS__start.call(this);
  };
  
  //@[ALIAS]
  ALIAS__processOk = _.processOk;
  _.processOk = function() {
    ALIAS__processOk.call(this);
    if (this.nIsNetworkSelection() && this.isCurrentItemEnabled()) {
      this.nSendNetworkSelectionAciton('ok');
    }
  };
  //@[ALIAS]
  ALIAS__processCancel = _.processCancel;
  _.processCancel = function() {
    ALIAS__processCancel.call(this);
    if (this.nIsNetworkSelection() && this.isCurrentItemEnabled()) {
      this.nSendNetworkSelectionAciton('cancel');
    }
  };
})();

// ■ END Window_ChoiceList.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Window_ChoiceList.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Window_ChoiceList.prototype;
  (function() {    // * Выбор (только одного игрока) в общем событии
    // -----------------------------------------------------------------------
    // * Подготовка окна к выбору по сети
    _.nPrepareNetworkSelection = function() {
      // * Обнуляем действие из сети
      $gameTemp.nSelectionActionFromNetwork = null;
      this.nSetNetworkSelectMode($gameTemp.nRequireChoiceOnlyForMaster);
      // * Сбрасываем флаг (чтобы не повторился на следующем выборе)
      $gameTemp.nRequireChoiceOnlyForMaster = false;
      // * При открытии окна, первый выбор Default всегда проходит (не запрещён) на клиенте
      // * Поэтому ставим разрешающий флаг (якобы от сервера первый выбор)
      this.nIsSelectFromNetworkMaster = true;
      // * Очищаем последний отправленный индекс
      this.__nLastSentIndex = null;
    };
    _.nSetNetworkSelectMode = function(_networkSelectMode) {
      this._networkSelectMode = _networkSelectMode;
    };
    _.nIsNetworkSelection = function() {
      return this._networkSelectMode === true && ANNetwork.isConnected();
    };
    // * Отправить на сервер индекс выбора
    _.nSendNetworkSelection = function(index) {
      // * Чтобы не спамить
      if (this.__nLastSentIndex === index) {
        return;
      }
      this.__nLastSentIndex = index;
      ANInterpreterManager.sendChoiceSelection(index, null);
    };
    // * Отправить на сервер действие (ОК, отмена)
    _.nSendNetworkSelectionAciton = function(action) {
      ANInterpreterManager.sendChoiceSelection(this.index(), action);
    };
    // * Ожидание действие от сервера (не мастер)
    return _.nUpdateNetworkSelection = function() {
      var action, index;
      if ($gameTemp.nSelectionActionFromNetwork == null) {
        return;
      }
      if (ANInterpreterManager.isSharedEventMaster()) {
        return;
      }
      ({action, index} = $gameTemp.nSelectionActionFromNetwork);
      this.nIsSelectFromNetworkMaster = true;
      if (index != null) {
        // * Всегда ставим выбор аналогичный масетеру (пришёл от сервера который), затем уже действия
        this.select(index);
      }
      switch (action) {
        case 'ok':
          this.processOk();
          break;
        case 'cancel':
          this.processCancel(); // select
          break;
      }
      // * Ничего, выбор всегда идёт
      // * Флаг обработан, очищаем
      $gameTemp.nSelectionActionFromNetwork = null;
    };
  })();
})();

// ■ END Window_ChoiceList.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Window_MenuCommand.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__isFormationEnabled, ALIAS__isSaveEnabled, _;
  //@[DEFINES]
  _ = Window_MenuCommand.prototype;
  // * Команда Formation запрещена в сетевой игре всегда
  //@[ALIAS]
  ALIAS__isFormationEnabled = _.isFormationEnabled;
  _.isFormationEnabled = function() {
    if (ANNetwork.isConnected()) {
      return false;
    } else {
      return ALIAS__isFormationEnabled.call(this, ...arguments);
    }
  };
  
  //@[ALIAS]
  ALIAS__isSaveEnabled = _.isSaveEnabled;
  _.isSaveEnabled = function() {
    if (ANNetwork.isConnected()) {
      // * Если параметр включён
      return ANET.PP.isSaveLoadAllowed();
    } else {
      return ALIAS__isSaveEnabled.call(this, ...arguments);
    }
  };
})();

// ■ END Window_MenuCommand.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Window_MenuStatus.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__initialize, ALIAS__isCurrentItemEnabled, _;
  //@[DEFINES]
  _ = Window_MenuStatus.prototype;
  //@[ALIAS]
  ALIAS__initialize = _.initialize;
  _.initialize = function(rect) {
    ALIAS__initialize.call(this, rect);
    if (ANNetwork.isConnected()) {
      if (ANET.PP.isOtherPlayersVisibleInMenu() === false) {
        this.setOnlyMyPlayerInMenuMode();
      }
    }
  };
  //@[ALIAS]
  ALIAS__isCurrentItemEnabled = _.isCurrentItemEnabled;
  _.isCurrentItemEnabled = function() {
    if (ANNetwork.isConnected()) {
      return this.isCurrentItemEnabledInNetworkGame();
    } else {
      return ALIAS__isCurrentItemEnabled.call(this, ...arguments);
    }
  };
})();

// ■ END Window_MenuStatus.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Window_MenuStatus.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Window_MenuStatus.prototype;
  (function() {    // * Команды Skill, Statis, Equip
    // -----------------------------------------------------------------------
    _.isCurrentItemEnabledInNetworkGame = function() {
      if (this.isSymbolOnlyForMyNetActor()) {
        return this.isCurrentActorIsMyNetActor();
      } else {
        return true;
      }
    };
    // * Набор команд, которые доступны только для текущего игрока (персонажа)
    _.isSymbolOnlyForMyNetActor = function() {
      var e, isOnlyForMyActor, symbol;
      try {
        // * Плохой вариант получения команды, но работает
        symbol = SceneManager._scene._commandWindow.currentSymbol();
        // * Навыки и экипировка - только для моего персонажа
        isOnlyForMyActor = symbol === 'skill' || symbol === 'equip';
        if (ANET.PP.isOtherPlayersMenuStatusAllowed() === false) {
          isOnlyForMyActor = isOnlyForMyActor || (symbol === 'status');
        }
        return isOnlyForMyActor;
      } catch (error) {
        e = error;
        AA.w(e);
        return false;
      }
    };
    
    // * Выбранный (Index) персонаж принадлежит мне? (мой персонаж)
    return _.isCurrentActorIsMyNetActor = function() {
      var actor, e;
      try {
        actor = $gameParty.members()[this.index()];
        if (ANET.PP.isMultiActorsMode()) {
          if (actor.isMyNetworkActor()) {
            return true;
          } else if ($gameParty.nIsIOwnedSharedActor(actor.actorId())) {
            return true;
          }
        } else {
          return actor.isMyNetworkActor();
        }
      } catch (error) {
        e = error;
        AA.w(e);
        return false;
      }
    };
  })();
  (function() {    // * Cписок игроков
    // -----------------------------------------------------------------------
    
    // * Будет видно только моего персонажа
    return _.setOnlyMyPlayerInMenuMode = function() {
      this.maxItems = function() {
        return 1;
      };
      this.actor = function(index) {
        return $gameParty.leader();
      };
      return this.selectLast = function() {
        return this.smoothSelect(0);
      };
    };
  })();
})();

// ■ END Window_MenuStatus.coffee
//---------------------------------------------------------------------------

// -----------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Window_Message.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__startMessage, ALIAS__terminateMessage, _;
  //@[DEFINES]
  _ = Window_Message.prototype;
  //@[ALIAS]
  ALIAS__startMessage = _.startMessage;
  _.startMessage = function() {
    ALIAS__startMessage.call(this);
    return ANET.UI.onGameMessageStart();
  };
  
  //TODO: Тут мерцание происходит. Как быть? Timeout?
  //@[ALIAS]
  ALIAS__terminateMessage = _.terminateMessage;
  _.terminateMessage = function() {
    ALIAS__terminateMessage.call(this);
    return ANET.UI.onGameMessageEnd();
  };
})();

// ■ END Window_Message.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Window_SavefileList.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__drawGameTitle, _;
  //@[DEFINES]
  _ = Window_SavefileList.prototype;
  if (KDX.isMZ()) {
    return;
  }
  //@[ALIAS]
  ALIAS__drawGameTitle = _.drawGameTitle;
  _.drawGameTitle = function(info, x, y, width) {
    var text;
    if ((info.nUniqueSaveID != null) && (info.nMyActorId != null)) {
      text = "";
      if (info.title != null) {
        text = info.title;
      }
      text += " [Network game]";
      return this.drawText(text, x, y, width + 100);
    } else {
      return ALIAS__drawGameTitle.call(this, info, x, y, width);
    }
  };
})();

// ■ END Window_SavefileList.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Window_SavefileList.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__drawTitle, ALIAS__isEnabled, _;
  //@[DEFINES]
  _ = Window_SavefileList.prototype;
  //@[ALIAS]
  ALIAS__isEnabled = _.isEnabled;
  _.isEnabled = function(savefileId) {
    // * Нельзя загружать сетевые сохранения из обычного меню загрузки
    if (this._mode === 'load' && DataManager.nIsNetworkSaveFile(savefileId)) {
      return false;
    } else if (this._mode === 'loadNet') {
      return DataManager.nIsNetworkSaveFile(savefileId);
    } else {
      return ALIAS__isEnabled.call(this, savefileId);
    }
  };
  
  //TODO: Добавить кастомизацию или опцию на отключение
  //@[ALIAS]
  ALIAS__drawTitle = _.drawTitle;
  _.drawTitle = function(savefileId, x, y) {
    if (DataManager.nIsNetworkSaveFile(savefileId)) {
      return this.drawText(TextManager.file + " " + savefileId + " [Network game]", x, y, 240);
    } else {
      return ALIAS__drawTitle.call(this, savefileId, x, y);
    }
  };
})();

// ■ END Window_SavefileList.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Window_Selectable.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Window_Selectable.prototype;
})();

// ■ END Window_Selectable.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Window_Selectable.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Window_Selectable.prototype;
})();

// ■ END Window_Selectable.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Window_TitleCommand.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__makeCommandList, _;
  //@[DEFINES]
  _ = Window_TitleCommand.prototype;
  //@[ALIAS]
  ALIAS__makeCommandList = _.makeCommandList;
  _.makeCommandList = function() {
    ALIAS__makeCommandList.call(this);
    if (ANET.PP.isAddNetGameCmdToTitleMenu()) {
      this.addCommand(ANET.LV("network"), "network");
      this._nRearangeNetworkCommand();
    }
    if (!ANET.PP.isSinglePlayerAllowed()) {
      this._nRemoveNewGameCommand();
    }
  };
})();

// ■ END Window_TitleCommand.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Window_TitleCommand.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Window_TitleCommand.prototype;
  // * Чтобы не была последнией, меняю местами с командой options
  _._nRearangeNetworkCommand = function() {
    var e, netCmd, netCommandIndex, optionsCmd, optionsCommandIndex;
    try {
      optionsCommandIndex = this._list.indexOf(this._list.find(function(item) {
        return item.symbol === "options";
      }));
      if (optionsCommandIndex < 0) {
        return;
      }
      netCommandIndex = this._list.length - 1;
      optionsCmd = this._list[optionsCommandIndex];
      netCmd = this._list[netCommandIndex];
      this._list[optionsCommandIndex] = netCmd;
      return this._list[netCommandIndex] = optionsCmd;
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
  _._nRemoveNewGameCommand = function() {
    var e, newGameIndex;
    try {
      newGameIndex = this._list.indexOf(this._list.find(function(item) {
        return item.symbol === "newGame";
      }));
      return this._list.splice(newGameIndex, 1);
    } catch (error) {
      e = error;
      return console.warn(e);
    }
  };
})();

// ■ END Window_TitleCommand.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
// * Глабольный набор вспомогательных функций для пользователя
var nAPI;

nAPI = function() {};

(function() {  //╒═════════════════════════════════════════════════════════════════════════╛
  // ■ IMPLEMENTATION.coffee
  //╒═════════════════════════════════════════════════════════════════════════╛
  //---------------------------------------------------------------------------
  var _;
  //@[DEFINES]
  _ = nAPI;
  // * Для вызова сцены сетевой игры
  // * (только если в Scene_Title нет пункта или используется кастомная сцена)
  //$[Внимание: могут быть проблемы в вызове из сцены карты (одиночная игра) и выходе из сцены]
  _.startNetworkGameScene = function() {
    if (!ANNetwork.isConnected()) {
      $gameTemp.__netShouldDisconnectAfterLocalModeScene = true;
    }
    SceneManager.push(Scene_NetworkGameMenu);
  };
  _.ID = function() {
    return ANETUtils.getGameVersion();
  };
  _.isExtensionLoaded = function(pluginName) {
    return Imported[pluginName] === true;
  };
  (function() {    // * NETWORK STATE
    // -----------------------------------------------------------------------
    _.isNetworkGame = function() {
      var e;
      try {
        return ANNetwork.isConnected();
      } catch (error) {
        e = error;
        console.warn(e);
      }
      return false;
    };
    _.myPlayerIndex = function() {
      var e;
      try {
        if (ANNetwork.isConnected()) {
          return ANGameManager.myIndex();
        } else {
          return 0;
        }
      } catch (error) {
        e = error;
        console.warn(e);
      }
      return 0;
    };
    _.myActorId = function() {
      var e;
      try {
        if (ANNetwork.isConnected()) {
          return ANGameManager.myActorId();
        } else {
          return $gameParty.leader().actorId();
        }
      } catch (error) {
        e = error;
        console.warn(e);
      }
      return 0;
    };
    _.playersCount = function() {
      var e;
      try {
        return ANGameManager.playersData.length;
      } catch (error) {
        e = error;
        console.warn(e);
      }
      return 0;
    };
    _.isMasterClient = function() {
      var e;
      try {
        return _.isNetworkGame() && ANNetwork.isMasterClient();
      } catch (error) {
        e = error;
        console.warn(e);
      }
      return false;
    };
    _.setWaitWhenTransfer = function(isWait) {
      var e;
      try {
        return $gameSystem.nRefreshWaitTransferMode(isWait, false);
      } catch (error) {
        e = error;
        return console.warn(e);
      }
    };
    // * Возвращает набор данных исходя из what (см. ANGameManager.getPlayerInfo)
    //? what && byWhat: actor, actorId, netId, actorName, playerName, playerIndex, info
    _.getPlayerInfo = function(what, byWhat, value) {
      var e;
      try {
        return ANGameManager.getPlayerInfo(what, byWhat, value);
      } catch (error) {
        e = error;
        console.warn(e);
        return null;
      }
    };
    // * Возвращает NETCharacter или Null
    _.getPlayerCharacter = function(byWhat, value) {
      var e, playerData;
      try {
        if (!KUtils.IsMapScene()) {
          return null;
        }
        playerData = this.getPlayerInfo("info", byWhat, value);
        // * Персонаж должен быть на текущей карте + сцена карты должна быть текущая
        if ((playerData != null) && NetPlayerDataWrapper.isCharOnMap(playerData)) {
          if (playerData.id === ANGameManager.myPlayerData().id) {
            return $gamePlayer;
          } else {
            return $gameMap.networkCharacterById(playerData.id);
          }
        }
      } catch (error) {
        e = error;
        console.warn(e);
      }
      return null;
    };
    // * Кто на данный момент читает событие (локально)
    return _.getEventParticipant = function(what) {
      var e;
      try {
        if ($gameMap._interpreter.isRunning() && ANNetwork.isConnected()) {
          return nAPI.getPlayerInfo(what, "actorId", ANGameManager.myActorId());
        }
      } catch (error) {
        e = error;
        console.warn(e);
      }
      return null;
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    // * HUI
    // -----------------------------------------------------------------------
    _.showGreenAlert = function(text) {
      var e;
      try {
        return typeof HUIManager !== "undefined" && HUIManager !== null ? HUIManager.notifySucess(text) : void 0;
      } catch (error) {
        e = error;
        return console.warn(e);
      }
    };
    _.showRedAlert = function(text) {
      var e;
      try {
        return typeof HUIManager !== "undefined" && HUIManager !== null ? HUIManager.notifyError(text) : void 0;
      } catch (error) {
        e = error;
        return console.warn(e);
      }
    };
    _.showInfoMessage = function(text1, text2 = "") {
      var e;
      try {
        return typeof HUIManager !== "undefined" && HUIManager !== null ? HUIManager.showWaitingInfo(text1, text2, 1) : void 0;
      } catch (error) {
        e = error;
        return console.warn(e);
      }
    };
    return _.hideInfoMessage = function() {
      var e;
      try {
        return typeof HUIManager !== "undefined" && HUIManager !== null ? HUIManager.hideWaitingInfo() : void 0;
      } catch (error) {
        e = error;
        return console.warn(e);
      }
    };
  })();
  (function() {    // -----------------------------------------------------------------------

    // * USER SERVER COMMANDS
    // -----------------------------------------------------------------------
    //@[ALIAS SUPPORT]
    // * FOR ALIASING (for plugin developers and custom commands implementation)
    _.onCustomCommand = function(name, data) {
      var e;
      try {
        if (typeof $gameSystem !== "undefined" && $gameSystem !== null) {
          $gameSystem.nCheckCustomCommandForCEStart(name);
        }
        ANET.CFIX.onCustomCommand(name, data);
      } catch (error) {
        e = error;
        console.warn(e);
      }
      console.log("Custom network command received: " + name);
    };
    // * USER CUSTOM CODE HERE
    _.sendCustomCommand = function(name, data) {
      var e;
      try {
        if (!_.isNetworkGame()) {
          return;
        }
        return ANNetwork.callback(NetMessage.Game("userCommand", {name, data}), function() {
          //TODO: Может не надо выполнять и на данном клиенте?
          // * Сразу выполняем и на данном клиенте
          // * Так как сервер эту команду выполнит в режиме ретрансляции
          return nAPI.onCustomCommand(name, data);
        });
      } catch (error) {
        e = error;
        return console.warn(e);
      }
    };
    // * Подписать на определённую (кастомную) команду выполенине общего события
    _.registerCommonEventForCommand = function(name, commonEventId) {
      var e;
      try {
        return ANNetwork.callback(NetMessage.Game("customCommandLink", {name, commonEventId}), function() {
          if (typeof $gameSystem !== "undefined" && $gameSystem !== null) {
            $gameSystem.nRegisterCustomCommandCE(name, commonEventId);
          }
          return console.log("Custom network command register to Common Event is done");
        });
      } catch (error) {
        e = error;
        return console.warn(e);
      }
    };
    // * Добавить (удалить) значение поля в Observer (Game_CharacterBase)
    _.setupAutoSyncPropertyForCharacter = function(propertyName, isAddSync = true) {
      var e;
      try {
        if (typeof $gameSystem === "undefined" || $gameSystem === null) {
          return;
        }
        return $gameSystem.nModifyUserDefinedObserver('character', propertyName, isAddSync);
      } catch (error) {
        e = error;
        return console.warn(e);
      }
    };
    // * Аналогично, только для Game_BattlerBase
    return _.setupAutoSyncPropertyForBattler = function(propertyName, isAddSync = true) {
      var e;
      try {
        if (typeof $gameSystem === "undefined" || $gameSystem === null) {
          return;
        }
        return $gameSystem.nModifyUserDefinedObserver('battler', propertyName, isAddSync);
      } catch (error) {
        e = error;
        return console.warn(e);
      }
    };
  })();
})();

// ■ END IMPLEMENTATION.coffee
//---------------------------------------------------------------------------
// -----------------------------------------------------------------------
window['nAPI'] = nAPI;


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Game_Party.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__addActor, ALIAS__initialize, ALIAS__removeActor, _;
  if (KDX.isMZ()) {
    return;
  }
  //@[DEFINES]
  _ = Game_Party.prototype;
  // * В MZ этот метод разделён на setup
  //@[ALIAS]
  ALIAS__initialize = _.initialize;
  _.initialize = function() {
    ALIAS__initialize.call(this);
    if (ANNetwork.isConnected()) {
      return this._data = []; // * Нет follower'ов
    }
  };
  
  //@[ALIAS]
  ALIAS__addActor = _.addActor;
  _.addActor = function(actorId) {
    var actor;
    ALIAS__addActor.call(this, actorId);
    // * Обновить окно статуса битвы
    $gameTemp.requestBattleRefresh();
    // * Код из MZ, инициализация битвы для новенького
    if (this.inBattle()) {
      actor = $gameActors.actor(actorId);
      if (this.battleMembers().includes(actor)) {
        actor.onBattleStart();
      }
    }
  };
  // * Если игрок выйдет, чтобы обновился экран битвы тоже
  //@[ALIAS]
  ALIAS__removeActor = _.removeActor;
  _.removeActor = function() {
    ALIAS__removeActor.call(this, ...arguments);
    $gameTemp.requestBattleRefresh();
  };
})();

// ■ END Game_Party.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ SceneManager.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__goto, _;
  //@[DEFINES]
  _ = SceneManager;
  if (KDX.isMZ()) {
    return;
  }
  //@[ALIAS]
  ALIAS__goto = _.goto;
  _.goto = function(sceneClass) {
    if ((typeof $gameTemp !== "undefined" && $gameTemp !== null) && (sceneClass != null)) {
      $gameTemp.__sceneChanging = true;
      setTimeout((function() {
        return typeof $gameTemp !== "undefined" && $gameTemp !== null ? $gameTemp.__sceneChanging = false : void 0;
      }), 100);
    }
    return ALIAS__goto.call(this, sceneClass);
  };
  
  // * В MV плохо работает проверка isSceneChanging, поэтому сделал дополнительную проверку
  _.isSceneReadyForNetwork = function() {
    if (!ANNetwork.isConnected()) {
      return true;
    }
    if ($gameTemp.__sceneChanging == null) {
      return true;
    }
    return !$gameTemp.__sceneChanging;
  };
})();

// ■ END SceneManager.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_Battle.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var ALIAS__updateBattleProcess, _;
  //@[DEFINES]
  _ = Scene_Battle.prototype;
  if (KDX.isMZ()) {
    return;
  }
  // * Чтобы окно открывалось при передаче управления игроку
  //@[ALIAS]
  ALIAS__updateBattleProcess = _.updateBattleProcess;
  _.updateBattleProcess = function() {
    if (ANNetwork.isConnected()) {
      if ($gameTemp._isBattleSceneShouldBeRefreshed === true) {
        this.changeInputWindow();
        $gameTemp._isBattleSceneShouldBeRefreshed = false;
      }
      if (!this.isAnyInputWindowActive() || BattleManager.isAborting() || BattleManager.isBattleEnd()) {
        this.changeInputWindow();
      }
    }
    return ALIAS__updateBattleProcess.call(this);
  };
})();

// ■ END Scene_Battle.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//╒═════════════════════════════════════════════════════════════════════════╛
// ■ Scene_NetworkRoomsList.coffee
//╒═════════════════════════════════════════════════════════════════════════╛
//---------------------------------------------------------------------------
(function() {
  var _;
  //@[DEFINES]
  _ = Scene_NetworkRoomsList.prototype;
  _.applyFilterToRooms = function() {
    if (this.roomsList == null) {
      return;
    }
    // * Применяем фильтр по gameId
    this.roomsList = this.roomsList.filter(function(room) {
      return room.gameId === ANETUtils.getGameVersion();
    });
  };
})();

// ■ END Scene_NetworkRoomsList.coffee
//---------------------------------------------------------------------------


// Generated by CoffeeScript 2.7.0
//? Методы для улучшения совместимости с плагинами Yanfly и VisuMZ

//@[EXTENSION]
ANETExtenders.extend(function() {
  if (Imported.YEP_ItemCore === true) {
    (function() {      //╒═════════════════════════════════════════════════════════════════════════╛
      // ■ Window_ItemInfo.coffee
      //╒═════════════════════════════════════════════════════════════════════════╛
      //---------------------------------------------------------------------------
      var ALIAS__drawInfoTextTop, _;
      
      //@[DEFINES]
      _ = Window_ItemInfo.prototype;
      
      //@[ALIAS]
      ALIAS__drawInfoTextTop = _.drawInfoTextTop;
      _.drawInfoTextTop = function(dy) {
        var e;
        try {
          ALIAS__drawInfoTextTop.call(this, ...arguments);
        } catch (error) {
          e = error;
        }
        return dy;
      };
    })();
  }
  // ■ END Window_ItemInfo.coffee
  //---------------------------------------------------------------------------
  if (Imported.YEP_BattleEngineCore === true || Imported.VisuMZ_1_BattleCore === true) {
    // * Force передача Sprite_Battler:startMove
    console.log("Load extension: YEP_BattleEngineCore | VisuMZ_1_BattleCore");
    ANET.CFIX.on_startMove = function(data) {
      var battler, duration, e, sprite, x, y;
      try {
        if (!$gameParty.inBattle()) {
          return;
        }
        if (!KUtils.IsBattleScene()) {
          return;
        }
        battler = ANETUtils.unpackBattlerFromNetwork(data.packed);
        sprite = ANETUtils.getBattlerSprite(battler);
        if (sprite == null) {
          return;
        }
        ({x, y, duration} = data);
        return ANET.CFIX.callLocalOnly(function() {
          return sprite.startMove(x, y, duration);
        });
      } catch (error) {
        e = error;
        return console.warn(e);
      }
    };
    ANET.CFIX.on_startJump = function(data) {
      var a, b, battler, e, sprite;
      try {
        if (!$gameParty.inBattle()) {
          return;
        }
        if (!KUtils.IsBattleScene()) {
          return;
        }
        battler = ANETUtils.unpackBattlerFromNetwork(data.packed);
        sprite = ANETUtils.getBattlerSprite(battler);
        if (sprite == null) {
          return;
        }
        ({a, b} = data);
        return ANET.CFIX.callLocalOnly(function() {
          return sprite.startJump(a, b);
        });
      } catch (error) {
        e = error;
        return console.warn(e);
      }
    };
    return (function() {      //╒═════════════════════════════════════════════════════════════════════════╛
      // ■ Sprite_Battler.coffee
      //╒═════════════════════════════════════════════════════════════════════════╛
      //---------------------------------------------------------------------------
      var ALIAS__startJump, ALIAS__startMove, _;
      //@[DEFINES]
      _ = Sprite_Battler.prototype;
      //@[ALIAS]
      ALIAS__startMove = _.startMove;
      _.startMove = function(x, y, duration) {
        var e, packed;
        ALIAS__startMove.call(this, x, y, duration);
        try {
          if (this._battler == null) {
            return;
          }
          if (!ANGameManager.isBattleMaster()) {
            return;
          }
          packed = ANETUtils.packBattlerForNetwork(this._battler);
          return ANET.CFIX.send("startMove", {packed, x, y, duration});
        } catch (error) {
          e = error;
          return console.warn(e);
        }
      };
      if (_.startJump != null) {
        ALIAS__startJump = _.startJump;
        _.startJump = function(a, b) {
          var e, packed;
          ALIAS__startJump.call(this, a, b);
          try {
            if (this._battler == null) {
              return;
            }
            if (!ANGameManager.isBattleMaster()) {
              return;
            }
            packed = ANETUtils.packBattlerForNetwork(this._battler);
            return ANET.CFIX.send("startJump", {packed, a, b});
          } catch (error) {
            e = error;
            return console.warn(e);
          }
        }; // * Если определён метод startJump
      }
    })();
  }
// ■ END Sprite_Battler.coffee
//---------------------------------------------------------------------------
}, "YanflyCompatibility");








// ============================================================================
/*!
 * Socket.IO v2.3.0
 * (c) 2014-2019 Guillermo Rauch
 * Released under the MIT License.
 */
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.io=e():t.io=e()}(this,function(){return function(t){function e(n){if(r[n])return r[n].exports;var o=r[n]={exports:{},id:n,loaded:!1};return t[n].call(o.exports,o,o.exports,e),o.loaded=!0,o.exports}var r={};return e.m=t,e.c=r,e.p="",e(0)}([function(t,e,r){"use strict";function n(t,e){"object"===("undefined"==typeof t?"undefined":o(t))&&(e=t,t=void 0),e=e||{};var r,n=i(t),s=n.source,p=n.id,h=n.path,u=c[p]&&h in c[p].nsps,f=e.forceNew||e["force new connection"]||!1===e.multiplex||u;return f?r=a(s,e):(c[p]||(c[p]=a(s,e)),r=c[p]),n.query&&!e.query&&(e.query=n.query),r.socket(n.path,e)}var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i=r(1),s=r(4),a=r(9);r(3)("socket.io-client");t.exports=e=n;var c=e.managers={};e.protocol=s.protocol,e.connect=n,e.Manager=r(9),e.Socket=r(33)},function(t,e,r){"use strict";function n(t,e){var r=t;e=e||"undefined"!=typeof location&&location,null==t&&(t=e.protocol+"//"+e.host),"string"==typeof t&&("/"===t.charAt(0)&&(t="/"===t.charAt(1)?e.protocol+t:e.host+t),/^(https?|wss?):\/\//.test(t)||(t="undefined"!=typeof e?e.protocol+"//"+t:"https://"+t),r=o(t)),r.port||(/^(http|ws)$/.test(r.protocol)?r.port="80":/^(http|ws)s$/.test(r.protocol)&&(r.port="443")),r.path=r.path||"/";var n=r.host.indexOf(":")!==-1,i=n?"["+r.host+"]":r.host;return r.id=r.protocol+"://"+i+":"+r.port,r.href=r.protocol+"://"+i+(e&&e.port===r.port?"":":"+r.port),r}var o=r(2);r(3)("socket.io-client:url");t.exports=n},function(t,e){var r=/^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,n=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"];t.exports=function(t){var e=t,o=t.indexOf("["),i=t.indexOf("]");o!=-1&&i!=-1&&(t=t.substring(0,o)+t.substring(o,i).replace(/:/g,";")+t.substring(i,t.length));for(var s=r.exec(t||""),a={},c=14;c--;)a[n[c]]=s[c]||"";return o!=-1&&i!=-1&&(a.source=e,a.host=a.host.substring(1,a.host.length-1).replace(/;/g,":"),a.authority=a.authority.replace("[","").replace("]","").replace(/;/g,":"),a.ipv6uri=!0),a}},function(t,e){"use strict";t.exports=function(){return function(){}}},function(t,e,r){function n(){}function o(t){var r=""+t.type;if(e.BINARY_EVENT!==t.type&&e.BINARY_ACK!==t.type||(r+=t.attachments+"-"),t.nsp&&"/"!==t.nsp&&(r+=t.nsp+","),null!=t.id&&(r+=t.id),null!=t.data){var n=i(t.data);if(n===!1)return m;r+=n}return r}function i(t){try{return JSON.stringify(t)}catch(t){return!1}}function s(t,e){function r(t){var r=l.deconstructPacket(t),n=o(r.packet),i=r.buffers;i.unshift(n),e(i)}l.removeBlobs(t,r)}function a(){this.reconstructor=null}function c(t){var r=0,n={type:Number(t.charAt(0))};if(null==e.types[n.type])return u("unknown packet type "+n.type);if(e.BINARY_EVENT===n.type||e.BINARY_ACK===n.type){for(var o="";"-"!==t.charAt(++r)&&(o+=t.charAt(r),r!=t.length););if(o!=Number(o)||"-"!==t.charAt(r))throw new Error("Illegal attachments");n.attachments=Number(o)}if("/"===t.charAt(r+1))for(n.nsp="";++r;){var i=t.charAt(r);if(","===i)break;if(n.nsp+=i,r===t.length)break}else n.nsp="/";var s=t.charAt(r+1);if(""!==s&&Number(s)==s){for(n.id="";++r;){var i=t.charAt(r);if(null==i||Number(i)!=i){--r;break}if(n.id+=t.charAt(r),r===t.length)break}n.id=Number(n.id)}if(t.charAt(++r)){var a=p(t.substr(r)),c=a!==!1&&(n.type===e.ERROR||d(a));if(!c)return u("invalid payload");n.data=a}return n}function p(t){try{return JSON.parse(t)}catch(t){return!1}}function h(t){this.reconPack=t,this.buffers=[]}function u(t){return{type:e.ERROR,data:"parser error: "+t}}var f=(r(3)("socket.io-parser"),r(5)),l=r(6),d=r(7),y=r(8);e.protocol=4,e.types=["CONNECT","DISCONNECT","EVENT","ACK","ERROR","BINARY_EVENT","BINARY_ACK"],e.CONNECT=0,e.DISCONNECT=1,e.EVENT=2,e.ACK=3,e.ERROR=4,e.BINARY_EVENT=5,e.BINARY_ACK=6,e.Encoder=n,e.Decoder=a;var m=e.ERROR+'"encode error"';n.prototype.encode=function(t,r){if(e.BINARY_EVENT===t.type||e.BINARY_ACK===t.type)s(t,r);else{var n=o(t);r([n])}},f(a.prototype),a.prototype.add=function(t){var r;if("string"==typeof t)r=c(t),e.BINARY_EVENT===r.type||e.BINARY_ACK===r.type?(this.reconstructor=new h(r),0===this.reconstructor.reconPack.attachments&&this.emit("decoded",r)):this.emit("decoded",r);else{if(!y(t)&&!t.base64)throw new Error("Unknown type: "+t);if(!this.reconstructor)throw new Error("got binary data when not reconstructing a packet");r=this.reconstructor.takeBinaryData(t),r&&(this.reconstructor=null,this.emit("decoded",r))}},a.prototype.destroy=function(){this.reconstructor&&this.reconstructor.finishedReconstruction()},h.prototype.takeBinaryData=function(t){if(this.buffers.push(t),this.buffers.length===this.reconPack.attachments){var e=l.reconstructPacket(this.reconPack,this.buffers);return this.finishedReconstruction(),e}return null},h.prototype.finishedReconstruction=function(){this.reconPack=null,this.buffers=[]}},function(t,e,r){function n(t){if(t)return o(t)}function o(t){for(var e in n.prototype)t[e]=n.prototype[e];return t}t.exports=n,n.prototype.on=n.prototype.addEventListener=function(t,e){return this._callbacks=this._callbacks||{},(this._callbacks["$"+t]=this._callbacks["$"+t]||[]).push(e),this},n.prototype.once=function(t,e){function r(){this.off(t,r),e.apply(this,arguments)}return r.fn=e,this.on(t,r),this},n.prototype.off=n.prototype.removeListener=n.prototype.removeAllListeners=n.prototype.removeEventListener=function(t,e){if(this._callbacks=this._callbacks||{},0==arguments.length)return this._callbacks={},this;var r=this._callbacks["$"+t];if(!r)return this;if(1==arguments.length)return delete this._callbacks["$"+t],this;for(var n,o=0;o<r.length;o++)if(n=r[o],n===e||n.fn===e){r.splice(o,1);break}return this},n.prototype.emit=function(t){this._callbacks=this._callbacks||{};var e=[].slice.call(arguments,1),r=this._callbacks["$"+t];if(r){r=r.slice(0);for(var n=0,o=r.length;n<o;++n)r[n].apply(this,e)}return this},n.prototype.listeners=function(t){return this._callbacks=this._callbacks||{},this._callbacks["$"+t]||[]},n.prototype.hasListeners=function(t){return!!this.listeners(t).length}},function(t,e,r){function n(t,e){if(!t)return t;if(s(t)){var r={_placeholder:!0,num:e.length};return e.push(t),r}if(i(t)){for(var o=new Array(t.length),a=0;a<t.length;a++)o[a]=n(t[a],e);return o}if("object"==typeof t&&!(t instanceof Date)){var o={};for(var c in t)o[c]=n(t[c],e);return o}return t}function o(t,e){if(!t)return t;if(t&&t._placeholder)return e[t.num];if(i(t))for(var r=0;r<t.length;r++)t[r]=o(t[r],e);else if("object"==typeof t)for(var n in t)t[n]=o(t[n],e);return t}var i=r(7),s=r(8),a=Object.prototype.toString,c="function"==typeof Blob||"undefined"!=typeof Blob&&"[object BlobConstructor]"===a.call(Blob),p="function"==typeof File||"undefined"!=typeof File&&"[object FileConstructor]"===a.call(File);e.deconstructPacket=function(t){var e=[],r=t.data,o=t;return o.data=n(r,e),o.attachments=e.length,{packet:o,buffers:e}},e.reconstructPacket=function(t,e){return t.data=o(t.data,e),t.attachments=void 0,t},e.removeBlobs=function(t,e){function r(t,a,h){if(!t)return t;if(c&&t instanceof Blob||p&&t instanceof File){n++;var u=new FileReader;u.onload=function(){h?h[a]=this.result:o=this.result,--n||e(o)},u.readAsArrayBuffer(t)}else if(i(t))for(var f=0;f<t.length;f++)r(t[f],f,t);else if("object"==typeof t&&!s(t))for(var l in t)r(t[l],l,t)}var n=0,o=t;r(o),n||e(o)}},function(t,e){var r={}.toString;t.exports=Array.isArray||function(t){return"[object Array]"==r.call(t)}},function(t,e){function r(t){return n&&Buffer.isBuffer(t)||o&&(t instanceof ArrayBuffer||i(t))}t.exports=r;var n="function"==typeof Buffer&&"function"==typeof Buffer.isBuffer,o="function"==typeof ArrayBuffer,i=function(t){return"function"==typeof ArrayBuffer.isView?ArrayBuffer.isView(t):t.buffer instanceof ArrayBuffer}},function(t,e,r){"use strict";function n(t,e){if(!(this instanceof n))return new n(t,e);t&&"object"===("undefined"==typeof t?"undefined":o(t))&&(e=t,t=void 0),e=e||{},e.path=e.path||"/socket.io",this.nsps={},this.subs=[],this.opts=e,this.reconnection(e.reconnection!==!1),this.reconnectionAttempts(e.reconnectionAttempts||1/0),this.reconnectionDelay(e.reconnectionDelay||1e3),this.reconnectionDelayMax(e.reconnectionDelayMax||5e3),this.randomizationFactor(e.randomizationFactor||.5),this.backoff=new f({min:this.reconnectionDelay(),max:this.reconnectionDelayMax(),jitter:this.randomizationFactor()}),this.timeout(null==e.timeout?2e4:e.timeout),this.readyState="closed",this.uri=t,this.connecting=[],this.lastPing=null,this.encoding=!1,this.packetBuffer=[];var r=e.parser||c;this.encoder=new r.Encoder,this.decoder=new r.Decoder,this.autoConnect=e.autoConnect!==!1,this.autoConnect&&this.open()}var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i=r(10),s=r(33),a=r(5),c=r(4),p=r(35),h=r(36),u=(r(3)("socket.io-client:manager"),r(32)),f=r(37),l=Object.prototype.hasOwnProperty;t.exports=n,n.prototype.emitAll=function(){this.emit.apply(this,arguments);for(var t in this.nsps)l.call(this.nsps,t)&&this.nsps[t].emit.apply(this.nsps[t],arguments)},n.prototype.updateSocketIds=function(){for(var t in this.nsps)l.call(this.nsps,t)&&(this.nsps[t].id=this.generateId(t))},n.prototype.generateId=function(t){return("/"===t?"":t+"#")+this.engine.id},a(n.prototype),n.prototype.reconnection=function(t){return arguments.length?(this._reconnection=!!t,this):this._reconnection},n.prototype.reconnectionAttempts=function(t){return arguments.length?(this._reconnectionAttempts=t,this):this._reconnectionAttempts},n.prototype.reconnectionDelay=function(t){return arguments.length?(this._reconnectionDelay=t,this.backoff&&this.backoff.setMin(t),this):this._reconnectionDelay},n.prototype.randomizationFactor=function(t){return arguments.length?(this._randomizationFactor=t,this.backoff&&this.backoff.setJitter(t),this):this._randomizationFactor},n.prototype.reconnectionDelayMax=function(t){return arguments.length?(this._reconnectionDelayMax=t,this.backoff&&this.backoff.setMax(t),this):this._reconnectionDelayMax},n.prototype.timeout=function(t){return arguments.length?(this._timeout=t,this):this._timeout},n.prototype.maybeReconnectOnOpen=function(){!this.reconnecting&&this._reconnection&&0===this.backoff.attempts&&this.reconnect()},n.prototype.open=n.prototype.connect=function(t,e){if(~this.readyState.indexOf("open"))return this;this.engine=i(this.uri,this.opts);var r=this.engine,n=this;this.readyState="opening",this.skipReconnect=!1;var o=p(r,"open",function(){n.onopen(),t&&t()}),s=p(r,"error",function(e){if(n.cleanup(),n.readyState="closed",n.emitAll("connect_error",e),t){var r=new Error("Connection error");r.data=e,t(r)}else n.maybeReconnectOnOpen()});if(!1!==this._timeout){var a=this._timeout,c=setTimeout(function(){o.destroy(),r.close(),r.emit("error","timeout"),n.emitAll("connect_timeout",a)},a);this.subs.push({destroy:function(){clearTimeout(c)}})}return this.subs.push(o),this.subs.push(s),this},n.prototype.onopen=function(){this.cleanup(),this.readyState="open",this.emit("open");var t=this.engine;this.subs.push(p(t,"data",h(this,"ondata"))),this.subs.push(p(t,"ping",h(this,"onping"))),this.subs.push(p(t,"pong",h(this,"onpong"))),this.subs.push(p(t,"error",h(this,"onerror"))),this.subs.push(p(t,"close",h(this,"onclose"))),this.subs.push(p(this.decoder,"decoded",h(this,"ondecoded")))},n.prototype.onping=function(){this.lastPing=new Date,this.emitAll("ping")},n.prototype.onpong=function(){this.emitAll("pong",new Date-this.lastPing)},n.prototype.ondata=function(t){this.decoder.add(t)},n.prototype.ondecoded=function(t){this.emit("packet",t)},n.prototype.onerror=function(t){this.emitAll("error",t)},n.prototype.socket=function(t,e){function r(){~u(o.connecting,n)||o.connecting.push(n)}var n=this.nsps[t];if(!n){n=new s(this,t,e),this.nsps[t]=n;var o=this;n.on("connecting",r),n.on("connect",function(){n.id=o.generateId(t)}),this.autoConnect&&r()}return n},n.prototype.destroy=function(t){var e=u(this.connecting,t);~e&&this.connecting.splice(e,1),this.connecting.length||this.close()},n.prototype.packet=function(t){var e=this;t.query&&0===t.type&&(t.nsp+="?"+t.query),e.encoding?e.packetBuffer.push(t):(e.encoding=!0,this.encoder.encode(t,function(r){for(var n=0;n<r.length;n++)e.engine.write(r[n],t.options);e.encoding=!1,e.processPacketQueue()}))},n.prototype.processPacketQueue=function(){if(this.packetBuffer.length>0&&!this.encoding){var t=this.packetBuffer.shift();this.packet(t)}},n.prototype.cleanup=function(){for(var t=this.subs.length,e=0;e<t;e++){var r=this.subs.shift();r.destroy()}this.packetBuffer=[],this.encoding=!1,this.lastPing=null,this.decoder.destroy()},n.prototype.close=n.prototype.disconnect=function(){this.skipReconnect=!0,this.reconnecting=!1,"opening"===this.readyState&&this.cleanup(),this.backoff.reset(),this.readyState="closed",this.engine&&this.engine.close()},n.prototype.onclose=function(t){this.cleanup(),this.backoff.reset(),this.readyState="closed",this.emit("close",t),this._reconnection&&!this.skipReconnect&&this.reconnect()},n.prototype.reconnect=function(){if(this.reconnecting||this.skipReconnect)return this;var t=this;if(this.backoff.attempts>=this._reconnectionAttempts)this.backoff.reset(),this.emitAll("reconnect_failed"),this.reconnecting=!1;else{var e=this.backoff.duration();this.reconnecting=!0;var r=setTimeout(function(){t.skipReconnect||(t.emitAll("reconnect_attempt",t.backoff.attempts),t.emitAll("reconnecting",t.backoff.attempts),t.skipReconnect||t.open(function(e){e?(t.reconnecting=!1,t.reconnect(),t.emitAll("reconnect_error",e.data)):t.onreconnect()}))},e);this.subs.push({destroy:function(){clearTimeout(r)}})}},n.prototype.onreconnect=function(){var t=this.backoff.attempts;this.reconnecting=!1,this.backoff.reset(),this.updateSocketIds(),this.emitAll("reconnect",t)}},function(t,e,r){t.exports=r(11),t.exports.parser=r(18)},function(t,e,r){function n(t,e){return this instanceof n?(e=e||{},t&&"object"==typeof t&&(e=t,t=null),t?(t=p(t),e.hostname=t.host,e.secure="https"===t.protocol||"wss"===t.protocol,e.port=t.port,t.query&&(e.query=t.query)):e.host&&(e.hostname=p(e.host).host),this.secure=null!=e.secure?e.secure:"undefined"!=typeof location&&"https:"===location.protocol,e.hostname&&!e.port&&(e.port=this.secure?"443":"80"),this.agent=e.agent||!1,this.hostname=e.hostname||("undefined"!=typeof location?location.hostname:"localhost"),this.port=e.port||("undefined"!=typeof location&&location.port?location.port:this.secure?443:80),this.query=e.query||{},"string"==typeof this.query&&(this.query=h.decode(this.query)),this.upgrade=!1!==e.upgrade,this.path=(e.path||"/engine.io").replace(/\/$/,"")+"/",this.forceJSONP=!!e.forceJSONP,this.jsonp=!1!==e.jsonp,this.forceBase64=!!e.forceBase64,this.enablesXDR=!!e.enablesXDR,this.withCredentials=!1!==e.withCredentials,this.timestampParam=e.timestampParam||"t",this.timestampRequests=e.timestampRequests,this.transports=e.transports||["polling","websocket"],this.transportOptions=e.transportOptions||{},this.readyState="",this.writeBuffer=[],this.prevBufferLen=0,this.policyPort=e.policyPort||843,this.rememberUpgrade=e.rememberUpgrade||!1,this.binaryType=null,this.onlyBinaryUpgrades=e.onlyBinaryUpgrades,this.perMessageDeflate=!1!==e.perMessageDeflate&&(e.perMessageDeflate||{}),!0===this.perMessageDeflate&&(this.perMessageDeflate={}),this.perMessageDeflate&&null==this.perMessageDeflate.threshold&&(this.perMessageDeflate.threshold=1024),this.pfx=e.pfx||null,this.key=e.key||null,this.passphrase=e.passphrase||null,this.cert=e.cert||null,this.ca=e.ca||null,this.ciphers=e.ciphers||null,this.rejectUnauthorized=void 0===e.rejectUnauthorized||e.rejectUnauthorized,this.forceNode=!!e.forceNode,this.isReactNative="undefined"!=typeof navigator&&"string"==typeof navigator.product&&"reactnative"===navigator.product.toLowerCase(),("undefined"==typeof self||this.isReactNative)&&(e.extraHeaders&&Object.keys(e.extraHeaders).length>0&&(this.extraHeaders=e.extraHeaders),e.localAddress&&(this.localAddress=e.localAddress)),this.id=null,this.upgrades=null,this.pingInterval=null,this.pingTimeout=null,this.pingIntervalTimer=null,this.pingTimeoutTimer=null,void this.open()):new n(t,e)}function o(t){var e={};for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r]);return e}var i=r(12),s=r(5),a=(r(3)("engine.io-client:socket"),r(32)),c=r(18),p=r(2),h=r(26);t.exports=n,n.priorWebsocketSuccess=!1,s(n.prototype),n.protocol=c.protocol,n.Socket=n,n.Transport=r(17),n.transports=r(12),n.parser=r(18),n.prototype.createTransport=function(t){var e=o(this.query);e.EIO=c.protocol,e.transport=t;var r=this.transportOptions[t]||{};this.id&&(e.sid=this.id);var n=new i[t]({query:e,socket:this,agent:r.agent||this.agent,hostname:r.hostname||this.hostname,port:r.port||this.port,secure:r.secure||this.secure,path:r.path||this.path,forceJSONP:r.forceJSONP||this.forceJSONP,jsonp:r.jsonp||this.jsonp,forceBase64:r.forceBase64||this.forceBase64,enablesXDR:r.enablesXDR||this.enablesXDR,withCredentials:r.withCredentials||this.withCredentials,timestampRequests:r.timestampRequests||this.timestampRequests,timestampParam:r.timestampParam||this.timestampParam,policyPort:r.policyPort||this.policyPort,pfx:r.pfx||this.pfx,key:r.key||this.key,passphrase:r.passphrase||this.passphrase,cert:r.cert||this.cert,ca:r.ca||this.ca,ciphers:r.ciphers||this.ciphers,rejectUnauthorized:r.rejectUnauthorized||this.rejectUnauthorized,perMessageDeflate:r.perMessageDeflate||this.perMessageDeflate,extraHeaders:r.extraHeaders||this.extraHeaders,forceNode:r.forceNode||this.forceNode,localAddress:r.localAddress||this.localAddress,requestTimeout:r.requestTimeout||this.requestTimeout,protocols:r.protocols||void 0,isReactNative:this.isReactNative});return n},n.prototype.open=function(){var t;if(this.rememberUpgrade&&n.priorWebsocketSuccess&&this.transports.indexOf("websocket")!==-1)t="websocket";else{if(0===this.transports.length){var e=this;return void setTimeout(function(){e.emit("error","No transports available")},0)}t=this.transports[0]}this.readyState="opening";try{t=this.createTransport(t)}catch(t){return this.transports.shift(),void this.open()}t.open(),this.setTransport(t)},n.prototype.setTransport=function(t){var e=this;this.transport&&this.transport.removeAllListeners(),this.transport=t,t.on("drain",function(){e.onDrain()}).on("packet",function(t){e.onPacket(t)}).on("error",function(t){e.onError(t)}).on("close",function(){e.onClose("transport close")})},n.prototype.probe=function(t){function e(){if(u.onlyBinaryUpgrades){var t=!this.supportsBinary&&u.transport.supportsBinary;h=h||t}h||(p.send([{type:"ping",data:"probe"}]),p.once("packet",function(t){if(!h)if("pong"===t.type&&"probe"===t.data){if(u.upgrading=!0,u.emit("upgrading",p),!p)return;n.priorWebsocketSuccess="websocket"===p.name,u.transport.pause(function(){h||"closed"!==u.readyState&&(c(),u.setTransport(p),p.send([{type:"upgrade"}]),u.emit("upgrade",p),p=null,u.upgrading=!1,u.flush())})}else{var e=new Error("probe error");e.transport=p.name,u.emit("upgradeError",e)}}))}function r(){h||(h=!0,c(),p.close(),p=null)}function o(t){var e=new Error("probe error: "+t);e.transport=p.name,r(),u.emit("upgradeError",e)}function i(){o("transport closed")}function s(){o("socket closed")}function a(t){p&&t.name!==p.name&&r()}function c(){p.removeListener("open",e),p.removeListener("error",o),p.removeListener("close",i),u.removeListener("close",s),u.removeListener("upgrading",a)}var p=this.createTransport(t,{probe:1}),h=!1,u=this;n.priorWebsocketSuccess=!1,p.once("open",e),p.once("error",o),p.once("close",i),this.once("close",s),this.once("upgrading",a),p.open()},n.prototype.onOpen=function(){if(this.readyState="open",n.priorWebsocketSuccess="websocket"===this.transport.name,this.emit("open"),this.flush(),"open"===this.readyState&&this.upgrade&&this.transport.pause)for(var t=0,e=this.upgrades.length;t<e;t++)this.probe(this.upgrades[t])},n.prototype.onPacket=function(t){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState)switch(this.emit("packet",t),this.emit("heartbeat"),t.type){case"open":this.onHandshake(JSON.parse(t.data));break;case"pong":this.setPing(),this.emit("pong");break;case"error":var e=new Error("server error");e.code=t.data,this.onError(e);break;case"message":this.emit("data",t.data),this.emit("message",t.data)}},n.prototype.onHandshake=function(t){this.emit("handshake",t),this.id=t.sid,this.transport.query.sid=t.sid,this.upgrades=this.filterUpgrades(t.upgrades),this.pingInterval=t.pingInterval,this.pingTimeout=t.pingTimeout,this.onOpen(),"closed"!==this.readyState&&(this.setPing(),this.removeListener("heartbeat",this.onHeartbeat),this.on("heartbeat",this.onHeartbeat))},n.prototype.onHeartbeat=function(t){clearTimeout(this.pingTimeoutTimer);var e=this;e.pingTimeoutTimer=setTimeout(function(){"closed"!==e.readyState&&e.onClose("ping timeout")},t||e.pingInterval+e.pingTimeout)},n.prototype.setPing=function(){var t=this;clearTimeout(t.pingIntervalTimer),t.pingIntervalTimer=setTimeout(function(){t.ping(),t.onHeartbeat(t.pingTimeout)},t.pingInterval)},n.prototype.ping=function(){var t=this;this.sendPacket("ping",function(){t.emit("ping")})},n.prototype.onDrain=function(){this.writeBuffer.splice(0,this.prevBufferLen),this.prevBufferLen=0,0===this.writeBuffer.length?this.emit("drain"):this.flush()},n.prototype.flush=function(){"closed"!==this.readyState&&this.transport.writable&&!this.upgrading&&this.writeBuffer.length&&(this.transport.send(this.writeBuffer),this.prevBufferLen=this.writeBuffer.length,this.emit("flush"))},n.prototype.write=n.prototype.send=function(t,e,r){return this.sendPacket("message",t,e,r),this},n.prototype.sendPacket=function(t,e,r,n){if("function"==typeof e&&(n=e,e=void 0),"function"==typeof r&&(n=r,r=null),"closing"!==this.readyState&&"closed"!==this.readyState){r=r||{},r.compress=!1!==r.compress;var o={type:t,data:e,options:r};this.emit("packetCreate",o),this.writeBuffer.push(o),n&&this.once("flush",n),this.flush()}},n.prototype.close=function(){function t(){n.onClose("forced close"),n.transport.close()}function e(){n.removeListener("upgrade",e),n.removeListener("upgradeError",e),t()}function r(){n.once("upgrade",e),n.once("upgradeError",e)}if("opening"===this.readyState||"open"===this.readyState){this.readyState="closing";var n=this;this.writeBuffer.length?this.once("drain",function(){this.upgrading?r():t()}):this.upgrading?r():t()}return this},n.prototype.onError=function(t){n.priorWebsocketSuccess=!1,this.emit("error",t),this.onClose("transport error",t)},n.prototype.onClose=function(t,e){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState){var r=this;clearTimeout(this.pingIntervalTimer),clearTimeout(this.pingTimeoutTimer),this.transport.removeAllListeners("close"),this.transport.close(),this.transport.removeAllListeners(),this.readyState="closed",this.id=null,this.emit("close",t,e),r.writeBuffer=[],r.prevBufferLen=0}},n.prototype.filterUpgrades=function(t){for(var e=[],r=0,n=t.length;r<n;r++)~a(this.transports,t[r])&&e.push(t[r]);return e}},function(t,e,r){function n(t){var e,r=!1,n=!1,a=!1!==t.jsonp;if("undefined"!=typeof location){var c="https:"===location.protocol,p=location.port;p||(p=c?443:80),r=t.hostname!==location.hostname||p!==t.port,n=t.secure!==c}if(t.xdomain=r,t.xscheme=n,e=new o(t),"open"in e&&!t.forceJSONP)return new i(t);if(!a)throw new Error("JSONP disabled");return new s(t)}var o=r(13),i=r(15),s=r(29),a=r(30);e.polling=n,e.websocket=a},function(t,e,r){var n=r(14);t.exports=function(t){var e=t.xdomain,r=t.xscheme,o=t.enablesXDR;try{if("undefined"!=typeof XMLHttpRequest&&(!e||n))return new XMLHttpRequest}catch(t){}try{if("undefined"!=typeof XDomainRequest&&!r&&o)return new XDomainRequest}catch(t){}if(!e)try{return new(self[["Active"].concat("Object").join("X")])("Microsoft.XMLHTTP")}catch(t){}}},function(t,e){try{t.exports="undefined"!=typeof XMLHttpRequest&&"withCredentials"in new XMLHttpRequest}catch(e){t.exports=!1}},function(t,e,r){function n(){}function o(t){if(c.call(this,t),this.requestTimeout=t.requestTimeout,this.extraHeaders=t.extraHeaders,"undefined"!=typeof location){var e="https:"===location.protocol,r=location.port;r||(r=e?443:80),this.xd="undefined"!=typeof location&&t.hostname!==location.hostname||r!==t.port,this.xs=t.secure!==e}}function i(t){this.method=t.method||"GET",this.uri=t.uri,this.xd=!!t.xd,this.xs=!!t.xs,this.async=!1!==t.async,this.data=void 0!==t.data?t.data:null,this.agent=t.agent,this.isBinary=t.isBinary,this.supportsBinary=t.supportsBinary,this.enablesXDR=t.enablesXDR,this.withCredentials=t.withCredentials,this.requestTimeout=t.requestTimeout,this.pfx=t.pfx,this.key=t.key,this.passphrase=t.passphrase,this.cert=t.cert,this.ca=t.ca,this.ciphers=t.ciphers,this.rejectUnauthorized=t.rejectUnauthorized,this.extraHeaders=t.extraHeaders,this.create()}function s(){for(var t in i.requests)i.requests.hasOwnProperty(t)&&i.requests[t].abort()}var a=r(13),c=r(16),p=r(5),h=r(27);r(3)("engine.io-client:polling-xhr");if(t.exports=o,t.exports.Request=i,h(o,c),o.prototype.supportsBinary=!0,o.prototype.request=function(t){return t=t||{},t.uri=this.uri(),t.xd=this.xd,t.xs=this.xs,t.agent=this.agent||!1,t.supportsBinary=this.supportsBinary,t.enablesXDR=this.enablesXDR,t.withCredentials=this.withCredentials,t.pfx=this.pfx,t.key=this.key,t.passphrase=this.passphrase,t.cert=this.cert,t.ca=this.ca,t.ciphers=this.ciphers,t.rejectUnauthorized=this.rejectUnauthorized,t.requestTimeout=this.requestTimeout,t.extraHeaders=this.extraHeaders,new i(t)},o.prototype.doWrite=function(t,e){var r="string"!=typeof t&&void 0!==t,n=this.request({method:"POST",data:t,isBinary:r}),o=this;n.on("success",e),n.on("error",function(t){o.onError("xhr post error",t)}),this.sendXhr=n},o.prototype.doPoll=function(){var t=this.request(),e=this;t.on("data",function(t){e.onData(t)}),t.on("error",function(t){e.onError("xhr poll error",t)}),this.pollXhr=t},p(i.prototype),i.prototype.create=function(){var t={agent:this.agent,xdomain:this.xd,xscheme:this.xs,enablesXDR:this.enablesXDR};t.pfx=this.pfx,t.key=this.key,t.passphrase=this.passphrase,t.cert=this.cert,t.ca=this.ca,t.ciphers=this.ciphers,t.rejectUnauthorized=this.rejectUnauthorized;var e=this.xhr=new a(t),r=this;try{e.open(this.method,this.uri,this.async);try{if(this.extraHeaders){e.setDisableHeaderCheck&&e.setDisableHeaderCheck(!0);for(var n in this.extraHeaders)this.extraHeaders.hasOwnProperty(n)&&e.setRequestHeader(n,this.extraHeaders[n])}}catch(t){}if("POST"===this.method)try{this.isBinary?e.setRequestHeader("Content-type","application/octet-stream"):e.setRequestHeader("Content-type","text/plain;charset=UTF-8")}catch(t){}try{e.setRequestHeader("Accept","*/*")}catch(t){}"withCredentials"in e&&(e.withCredentials=this.withCredentials),this.requestTimeout&&(e.timeout=this.requestTimeout),this.hasXDR()?(e.onload=function(){r.onLoad()},e.onerror=function(){r.onError(e.responseText)}):e.onreadystatechange=function(){if(2===e.readyState)try{var t=e.getResponseHeader("Content-Type");(r.supportsBinary&&"application/octet-stream"===t||"application/octet-stream; charset=UTF-8"===t)&&(e.responseType="arraybuffer")}catch(t){}4===e.readyState&&(200===e.status||1223===e.status?r.onLoad():setTimeout(function(){r.onError("number"==typeof e.status?e.status:0)},0))},e.send(this.data)}catch(t){return void setTimeout(function(){r.onError(t)},0)}"undefined"!=typeof document&&(this.index=i.requestsCount++,i.requests[this.index]=this)},i.prototype.onSuccess=function(){this.emit("success"),this.cleanup()},i.prototype.onData=function(t){this.emit("data",t),this.onSuccess()},i.prototype.onError=function(t){this.emit("error",t),this.cleanup(!0)},i.prototype.cleanup=function(t){if("undefined"!=typeof this.xhr&&null!==this.xhr){if(this.hasXDR()?this.xhr.onload=this.xhr.onerror=n:this.xhr.onreadystatechange=n,t)try{this.xhr.abort()}catch(t){}"undefined"!=typeof document&&delete i.requests[this.index],this.xhr=null}},i.prototype.onLoad=function(){var t;try{var e;try{e=this.xhr.getResponseHeader("Content-Type")}catch(t){}t="application/octet-stream"===e||"application/octet-stream; charset=UTF-8"===e?this.xhr.response||this.xhr.responseText:this.xhr.responseText}catch(t){this.onError(t)}null!=t&&this.onData(t)},i.prototype.hasXDR=function(){return"undefined"!=typeof XDomainRequest&&!this.xs&&this.enablesXDR},i.prototype.abort=function(){this.cleanup()},i.requestsCount=0,i.requests={},"undefined"!=typeof document)if("function"==typeof attachEvent)attachEvent("onunload",s);else if("function"==typeof addEventListener){var u="onpagehide"in self?"pagehide":"unload";addEventListener(u,s,!1)}},function(t,e,r){function n(t){var e=t&&t.forceBase64;p&&!e||(this.supportsBinary=!1),o.call(this,t)}var o=r(17),i=r(26),s=r(18),a=r(27),c=r(28);r(3)("engine.io-client:polling");t.exports=n;var p=function(){var t=r(13),e=new t({xdomain:!1});return null!=e.responseType}();a(n,o),n.prototype.name="polling",n.prototype.doOpen=function(){this.poll()},n.prototype.pause=function(t){function e(){r.readyState="paused",t()}var r=this;if(this.readyState="pausing",this.polling||!this.writable){var n=0;this.polling&&(n++,this.once("pollComplete",function(){--n||e()})),this.writable||(n++,this.once("drain",function(){--n||e()}))}else e()},n.prototype.poll=function(){this.polling=!0,this.doPoll(),this.emit("poll")},n.prototype.onData=function(t){var e=this,r=function(t,r,n){return"opening"===e.readyState&&e.onOpen(),"close"===t.type?(e.onClose(),!1):void e.onPacket(t)};s.decodePayload(t,this.socket.binaryType,r),"closed"!==this.readyState&&(this.polling=!1,this.emit("pollComplete"),"open"===this.readyState&&this.poll())},n.prototype.doClose=function(){function t(){e.write([{type:"close"}])}var e=this;"open"===this.readyState?t():this.once("open",t)},n.prototype.write=function(t){var e=this;this.writable=!1;var r=function(){e.writable=!0,e.emit("drain")};s.encodePayload(t,this.supportsBinary,function(t){e.doWrite(t,r)})},n.prototype.uri=function(){var t=this.query||{},e=this.secure?"https":"http",r="";!1!==this.timestampRequests&&(t[this.timestampParam]=c()),this.supportsBinary||t.sid||(t.b64=1),t=i.encode(t),this.port&&("https"===e&&443!==Number(this.port)||"http"===e&&80!==Number(this.port))&&(r=":"+this.port),t.length&&(t="?"+t);var n=this.hostname.indexOf(":")!==-1;return e+"://"+(n?"["+this.hostname+"]":this.hostname)+r+this.path+t}},function(t,e,r){function n(t){this.path=t.path,this.hostname=t.hostname,this.port=t.port,this.secure=t.secure,this.query=t.query,this.timestampParam=t.timestampParam,this.timestampRequests=t.timestampRequests,this.readyState="",this.agent=t.agent||!1,this.socket=t.socket,this.enablesXDR=t.enablesXDR,this.withCredentials=t.withCredentials,this.pfx=t.pfx,this.key=t.key,this.passphrase=t.passphrase,this.cert=t.cert,this.ca=t.ca,this.ciphers=t.ciphers,this.rejectUnauthorized=t.rejectUnauthorized,this.forceNode=t.forceNode,this.isReactNative=t.isReactNative,this.extraHeaders=t.extraHeaders,this.localAddress=t.localAddress}var o=r(18),i=r(5);t.exports=n,i(n.prototype),n.prototype.onError=function(t,e){var r=new Error(t);return r.type="TransportError",r.description=e,this.emit("error",r),this},n.prototype.open=function(){return"closed"!==this.readyState&&""!==this.readyState||(this.readyState="opening",this.doOpen()),this},n.prototype.close=function(){return"opening"!==this.readyState&&"open"!==this.readyState||(this.doClose(),this.onClose()),this},n.prototype.send=function(t){if("open"!==this.readyState)throw new Error("Transport not open");
this.write(t)},n.prototype.onOpen=function(){this.readyState="open",this.writable=!0,this.emit("open")},n.prototype.onData=function(t){var e=o.decodePacket(t,this.socket.binaryType);this.onPacket(e)},n.prototype.onPacket=function(t){this.emit("packet",t)},n.prototype.onClose=function(){this.readyState="closed",this.emit("close")}},function(t,e,r){function n(t,r){var n="b"+e.packets[t.type]+t.data.data;return r(n)}function o(t,r,n){if(!r)return e.encodeBase64Packet(t,n);var o=t.data,i=new Uint8Array(o),s=new Uint8Array(1+o.byteLength);s[0]=v[t.type];for(var a=0;a<i.length;a++)s[a+1]=i[a];return n(s.buffer)}function i(t,r,n){if(!r)return e.encodeBase64Packet(t,n);var o=new FileReader;return o.onload=function(){e.encodePacket({type:t.type,data:o.result},r,!0,n)},o.readAsArrayBuffer(t.data)}function s(t,r,n){if(!r)return e.encodeBase64Packet(t,n);if(g)return i(t,r,n);var o=new Uint8Array(1);o[0]=v[t.type];var s=new w([o.buffer,t.data]);return n(s)}function a(t){try{t=d.decode(t,{strict:!1})}catch(t){return!1}return t}function c(t,e,r){for(var n=new Array(t.length),o=l(t.length,r),i=function(t,r,o){e(r,function(e,r){n[t]=r,o(e,n)})},s=0;s<t.length;s++)i(s,t[s],o)}var p,h=r(19),u=r(20),f=r(21),l=r(22),d=r(23);"undefined"!=typeof ArrayBuffer&&(p=r(24));var y="undefined"!=typeof navigator&&/Android/i.test(navigator.userAgent),m="undefined"!=typeof navigator&&/PhantomJS/i.test(navigator.userAgent),g=y||m;e.protocol=3;var v=e.packets={open:0,close:1,ping:2,pong:3,message:4,upgrade:5,noop:6},b=h(v),k={type:"error",data:"parser error"},w=r(25);e.encodePacket=function(t,e,r,i){"function"==typeof e&&(i=e,e=!1),"function"==typeof r&&(i=r,r=null);var a=void 0===t.data?void 0:t.data.buffer||t.data;if("undefined"!=typeof ArrayBuffer&&a instanceof ArrayBuffer)return o(t,e,i);if("undefined"!=typeof w&&a instanceof w)return s(t,e,i);if(a&&a.base64)return n(t,i);var c=v[t.type];return void 0!==t.data&&(c+=r?d.encode(String(t.data),{strict:!1}):String(t.data)),i(""+c)},e.encodeBase64Packet=function(t,r){var n="b"+e.packets[t.type];if("undefined"!=typeof w&&t.data instanceof w){var o=new FileReader;return o.onload=function(){var t=o.result.split(",")[1];r(n+t)},o.readAsDataURL(t.data)}var i;try{i=String.fromCharCode.apply(null,new Uint8Array(t.data))}catch(e){for(var s=new Uint8Array(t.data),a=new Array(s.length),c=0;c<s.length;c++)a[c]=s[c];i=String.fromCharCode.apply(null,a)}return n+=btoa(i),r(n)},e.decodePacket=function(t,r,n){if(void 0===t)return k;if("string"==typeof t){if("b"===t.charAt(0))return e.decodeBase64Packet(t.substr(1),r);if(n&&(t=a(t),t===!1))return k;var o=t.charAt(0);return Number(o)==o&&b[o]?t.length>1?{type:b[o],data:t.substring(1)}:{type:b[o]}:k}var i=new Uint8Array(t),o=i[0],s=f(t,1);return w&&"blob"===r&&(s=new w([s])),{type:b[o],data:s}},e.decodeBase64Packet=function(t,e){var r=b[t.charAt(0)];if(!p)return{type:r,data:{base64:!0,data:t.substr(1)}};var n=p.decode(t.substr(1));return"blob"===e&&w&&(n=new w([n])),{type:r,data:n}},e.encodePayload=function(t,r,n){function o(t){return t.length+":"+t}function i(t,n){e.encodePacket(t,!!s&&r,!1,function(t){n(null,o(t))})}"function"==typeof r&&(n=r,r=null);var s=u(t);return r&&s?w&&!g?e.encodePayloadAsBlob(t,n):e.encodePayloadAsArrayBuffer(t,n):t.length?void c(t,i,function(t,e){return n(e.join(""))}):n("0:")},e.decodePayload=function(t,r,n){if("string"!=typeof t)return e.decodePayloadAsBinary(t,r,n);"function"==typeof r&&(n=r,r=null);var o;if(""===t)return n(k,0,1);for(var i,s,a="",c=0,p=t.length;c<p;c++){var h=t.charAt(c);if(":"===h){if(""===a||a!=(i=Number(a)))return n(k,0,1);if(s=t.substr(c+1,i),a!=s.length)return n(k,0,1);if(s.length){if(o=e.decodePacket(s,r,!1),k.type===o.type&&k.data===o.data)return n(k,0,1);var u=n(o,c+i,p);if(!1===u)return}c+=i,a=""}else a+=h}return""!==a?n(k,0,1):void 0},e.encodePayloadAsArrayBuffer=function(t,r){function n(t,r){e.encodePacket(t,!0,!0,function(t){return r(null,t)})}return t.length?void c(t,n,function(t,e){var n=e.reduce(function(t,e){var r;return r="string"==typeof e?e.length:e.byteLength,t+r.toString().length+r+2},0),o=new Uint8Array(n),i=0;return e.forEach(function(t){var e="string"==typeof t,r=t;if(e){for(var n=new Uint8Array(t.length),s=0;s<t.length;s++)n[s]=t.charCodeAt(s);r=n.buffer}e?o[i++]=0:o[i++]=1;for(var a=r.byteLength.toString(),s=0;s<a.length;s++)o[i++]=parseInt(a[s]);o[i++]=255;for(var n=new Uint8Array(r),s=0;s<n.length;s++)o[i++]=n[s]}),r(o.buffer)}):r(new ArrayBuffer(0))},e.encodePayloadAsBlob=function(t,r){function n(t,r){e.encodePacket(t,!0,!0,function(t){var e=new Uint8Array(1);if(e[0]=1,"string"==typeof t){for(var n=new Uint8Array(t.length),o=0;o<t.length;o++)n[o]=t.charCodeAt(o);t=n.buffer,e[0]=0}for(var i=t instanceof ArrayBuffer?t.byteLength:t.size,s=i.toString(),a=new Uint8Array(s.length+1),o=0;o<s.length;o++)a[o]=parseInt(s[o]);if(a[s.length]=255,w){var c=new w([e.buffer,a.buffer,t]);r(null,c)}})}c(t,n,function(t,e){return r(new w(e))})},e.decodePayloadAsBinary=function(t,r,n){"function"==typeof r&&(n=r,r=null);for(var o=t,i=[];o.byteLength>0;){for(var s=new Uint8Array(o),a=0===s[0],c="",p=1;255!==s[p];p++){if(c.length>310)return n(k,0,1);c+=s[p]}o=f(o,2+c.length),c=parseInt(c);var h=f(o,0,c);if(a)try{h=String.fromCharCode.apply(null,new Uint8Array(h))}catch(t){var u=new Uint8Array(h);h="";for(var p=0;p<u.length;p++)h+=String.fromCharCode(u[p])}i.push(h),o=f(o,c)}var l=i.length;i.forEach(function(t,o){n(e.decodePacket(t,r,!0),o,l)})}},function(t,e){t.exports=Object.keys||function(t){var e=[],r=Object.prototype.hasOwnProperty;for(var n in t)r.call(t,n)&&e.push(n);return e}},function(t,e,r){function n(t){if(!t||"object"!=typeof t)return!1;if(o(t)){for(var e=0,r=t.length;e<r;e++)if(n(t[e]))return!0;return!1}if("function"==typeof Buffer&&Buffer.isBuffer&&Buffer.isBuffer(t)||"function"==typeof ArrayBuffer&&t instanceof ArrayBuffer||s&&t instanceof Blob||a&&t instanceof File)return!0;if(t.toJSON&&"function"==typeof t.toJSON&&1===arguments.length)return n(t.toJSON(),!0);for(var i in t)if(Object.prototype.hasOwnProperty.call(t,i)&&n(t[i]))return!0;return!1}var o=r(7),i=Object.prototype.toString,s="function"==typeof Blob||"undefined"!=typeof Blob&&"[object BlobConstructor]"===i.call(Blob),a="function"==typeof File||"undefined"!=typeof File&&"[object FileConstructor]"===i.call(File);t.exports=n},function(t,e){t.exports=function(t,e,r){var n=t.byteLength;if(e=e||0,r=r||n,t.slice)return t.slice(e,r);if(e<0&&(e+=n),r<0&&(r+=n),r>n&&(r=n),e>=n||e>=r||0===n)return new ArrayBuffer(0);for(var o=new Uint8Array(t),i=new Uint8Array(r-e),s=e,a=0;s<r;s++,a++)i[a]=o[s];return i.buffer}},function(t,e){function r(t,e,r){function o(t,n){if(o.count<=0)throw new Error("after called too many times");--o.count,t?(i=!0,e(t),e=r):0!==o.count||i||e(null,n)}var i=!1;return r=r||n,o.count=t,0===t?e():o}function n(){}t.exports=r},function(t,e){function r(t){for(var e,r,n=[],o=0,i=t.length;o<i;)e=t.charCodeAt(o++),e>=55296&&e<=56319&&o<i?(r=t.charCodeAt(o++),56320==(64512&r)?n.push(((1023&e)<<10)+(1023&r)+65536):(n.push(e),o--)):n.push(e);return n}function n(t){for(var e,r=t.length,n=-1,o="";++n<r;)e=t[n],e>65535&&(e-=65536,o+=d(e>>>10&1023|55296),e=56320|1023&e),o+=d(e);return o}function o(t,e){if(t>=55296&&t<=57343){if(e)throw Error("Lone surrogate U+"+t.toString(16).toUpperCase()+" is not a scalar value");return!1}return!0}function i(t,e){return d(t>>e&63|128)}function s(t,e){if(0==(4294967168&t))return d(t);var r="";return 0==(4294965248&t)?r=d(t>>6&31|192):0==(4294901760&t)?(o(t,e)||(t=65533),r=d(t>>12&15|224),r+=i(t,6)):0==(4292870144&t)&&(r=d(t>>18&7|240),r+=i(t,12),r+=i(t,6)),r+=d(63&t|128)}function a(t,e){e=e||{};for(var n,o=!1!==e.strict,i=r(t),a=i.length,c=-1,p="";++c<a;)n=i[c],p+=s(n,o);return p}function c(){if(l>=f)throw Error("Invalid byte index");var t=255&u[l];if(l++,128==(192&t))return 63&t;throw Error("Invalid continuation byte")}function p(t){var e,r,n,i,s;if(l>f)throw Error("Invalid byte index");if(l==f)return!1;if(e=255&u[l],l++,0==(128&e))return e;if(192==(224&e)){if(r=c(),s=(31&e)<<6|r,s>=128)return s;throw Error("Invalid continuation byte")}if(224==(240&e)){if(r=c(),n=c(),s=(15&e)<<12|r<<6|n,s>=2048)return o(s,t)?s:65533;throw Error("Invalid continuation byte")}if(240==(248&e)&&(r=c(),n=c(),i=c(),s=(7&e)<<18|r<<12|n<<6|i,s>=65536&&s<=1114111))return s;throw Error("Invalid UTF-8 detected")}function h(t,e){e=e||{};var o=!1!==e.strict;u=r(t),f=u.length,l=0;for(var i,s=[];(i=p(o))!==!1;)s.push(i);return n(s)}/*! https://mths.be/utf8js v2.1.2 by @mathias */
var u,f,l,d=String.fromCharCode;t.exports={version:"2.1.2",encode:a,decode:h}},function(t,e){!function(){"use strict";for(var t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",r=new Uint8Array(256),n=0;n<t.length;n++)r[t.charCodeAt(n)]=n;e.encode=function(e){var r,n=new Uint8Array(e),o=n.length,i="";for(r=0;r<o;r+=3)i+=t[n[r]>>2],i+=t[(3&n[r])<<4|n[r+1]>>4],i+=t[(15&n[r+1])<<2|n[r+2]>>6],i+=t[63&n[r+2]];return o%3===2?i=i.substring(0,i.length-1)+"=":o%3===1&&(i=i.substring(0,i.length-2)+"=="),i},e.decode=function(t){var e,n,o,i,s,a=.75*t.length,c=t.length,p=0;"="===t[t.length-1]&&(a--,"="===t[t.length-2]&&a--);var h=new ArrayBuffer(a),u=new Uint8Array(h);for(e=0;e<c;e+=4)n=r[t.charCodeAt(e)],o=r[t.charCodeAt(e+1)],i=r[t.charCodeAt(e+2)],s=r[t.charCodeAt(e+3)],u[p++]=n<<2|o>>4,u[p++]=(15&o)<<4|i>>2,u[p++]=(3&i)<<6|63&s;return h}}()},function(t,e){function r(t){return t.map(function(t){if(t.buffer instanceof ArrayBuffer){var e=t.buffer;if(t.byteLength!==e.byteLength){var r=new Uint8Array(t.byteLength);r.set(new Uint8Array(e,t.byteOffset,t.byteLength)),e=r.buffer}return e}return t})}function n(t,e){e=e||{};var n=new i;return r(t).forEach(function(t){n.append(t)}),e.type?n.getBlob(e.type):n.getBlob()}function o(t,e){return new Blob(r(t),e||{})}var i="undefined"!=typeof i?i:"undefined"!=typeof WebKitBlobBuilder?WebKitBlobBuilder:"undefined"!=typeof MSBlobBuilder?MSBlobBuilder:"undefined"!=typeof MozBlobBuilder&&MozBlobBuilder,s=function(){try{var t=new Blob(["hi"]);return 2===t.size}catch(t){return!1}}(),a=s&&function(){try{var t=new Blob([new Uint8Array([1,2])]);return 2===t.size}catch(t){return!1}}(),c=i&&i.prototype.append&&i.prototype.getBlob;"undefined"!=typeof Blob&&(n.prototype=Blob.prototype,o.prototype=Blob.prototype),t.exports=function(){return s?a?Blob:o:c?n:void 0}()},function(t,e){e.encode=function(t){var e="";for(var r in t)t.hasOwnProperty(r)&&(e.length&&(e+="&"),e+=encodeURIComponent(r)+"="+encodeURIComponent(t[r]));return e},e.decode=function(t){for(var e={},r=t.split("&"),n=0,o=r.length;n<o;n++){var i=r[n].split("=");e[decodeURIComponent(i[0])]=decodeURIComponent(i[1])}return e}},function(t,e){t.exports=function(t,e){var r=function(){};r.prototype=e.prototype,t.prototype=new r,t.prototype.constructor=t}},function(t,e){"use strict";function r(t){var e="";do e=s[t%a]+e,t=Math.floor(t/a);while(t>0);return e}function n(t){var e=0;for(h=0;h<t.length;h++)e=e*a+c[t.charAt(h)];return e}function o(){var t=r(+new Date);return t!==i?(p=0,i=t):t+"."+r(p++)}for(var i,s="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""),a=64,c={},p=0,h=0;h<a;h++)c[s[h]]=h;o.encode=r,o.decode=n,t.exports=o},function(t,e,r){(function(e){function n(){}function o(){return"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof e?e:{}}function i(t){if(s.call(this,t),this.query=this.query||{},!c){var e=o();c=e.___eio=e.___eio||[]}this.index=c.length;var r=this;c.push(function(t){r.onData(t)}),this.query.j=this.index,"function"==typeof addEventListener&&addEventListener("beforeunload",function(){r.script&&(r.script.onerror=n)},!1)}var s=r(16),a=r(27);t.exports=i;var c,p=/\n/g,h=/\\n/g;a(i,s),i.prototype.supportsBinary=!1,i.prototype.doClose=function(){this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),this.form&&(this.form.parentNode.removeChild(this.form),this.form=null,this.iframe=null),s.prototype.doClose.call(this)},i.prototype.doPoll=function(){var t=this,e=document.createElement("script");this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),e.async=!0,e.src=this.uri(),e.onerror=function(e){t.onError("jsonp poll error",e)};var r=document.getElementsByTagName("script")[0];r?r.parentNode.insertBefore(e,r):(document.head||document.body).appendChild(e),this.script=e;var n="undefined"!=typeof navigator&&/gecko/i.test(navigator.userAgent);n&&setTimeout(function(){var t=document.createElement("iframe");document.body.appendChild(t),document.body.removeChild(t)},100)},i.prototype.doWrite=function(t,e){function r(){n(),e()}function n(){if(o.iframe)try{o.form.removeChild(o.iframe)}catch(t){o.onError("jsonp polling iframe removal error",t)}try{var t='<iframe src="javascript:0" name="'+o.iframeId+'">';i=document.createElement(t)}catch(t){i=document.createElement("iframe"),i.name=o.iframeId,i.src="javascript:0"}i.id=o.iframeId,o.form.appendChild(i),o.iframe=i}var o=this;if(!this.form){var i,s=document.createElement("form"),a=document.createElement("textarea"),c=this.iframeId="eio_iframe_"+this.index;s.className="socketio",s.style.position="absolute",s.style.top="-1000px",s.style.left="-1000px",s.target=c,s.method="POST",s.setAttribute("accept-charset","utf-8"),a.name="d",s.appendChild(a),document.body.appendChild(s),this.form=s,this.area=a}this.form.action=this.uri(),n(),t=t.replace(h,"\\\n"),this.area.value=t.replace(p,"\\n");try{this.form.submit()}catch(t){}this.iframe.attachEvent?this.iframe.onreadystatechange=function(){"complete"===o.iframe.readyState&&r()}:this.iframe.onload=r}}).call(e,function(){return this}())},function(t,e,r){function n(t){var e=t&&t.forceBase64;e&&(this.supportsBinary=!1),this.perMessageDeflate=t.perMessageDeflate,this.usingBrowserWebSocket=o&&!t.forceNode,this.protocols=t.protocols,this.usingBrowserWebSocket||(u=i),s.call(this,t)}var o,i,s=r(17),a=r(18),c=r(26),p=r(27),h=r(28);r(3)("engine.io-client:websocket");if("undefined"!=typeof WebSocket?o=WebSocket:"undefined"!=typeof self&&(o=self.WebSocket||self.MozWebSocket),"undefined"==typeof window)try{i=r(31)}catch(t){}var u=o||i;t.exports=n,p(n,s),n.prototype.name="websocket",n.prototype.supportsBinary=!0,n.prototype.doOpen=function(){if(this.check()){var t=this.uri(),e=this.protocols,r={agent:this.agent,perMessageDeflate:this.perMessageDeflate};r.pfx=this.pfx,r.key=this.key,r.passphrase=this.passphrase,r.cert=this.cert,r.ca=this.ca,r.ciphers=this.ciphers,r.rejectUnauthorized=this.rejectUnauthorized,this.extraHeaders&&(r.headers=this.extraHeaders),this.localAddress&&(r.localAddress=this.localAddress);try{this.ws=this.usingBrowserWebSocket&&!this.isReactNative?e?new u(t,e):new u(t):new u(t,e,r)}catch(t){return this.emit("error",t)}void 0===this.ws.binaryType&&(this.supportsBinary=!1),this.ws.supports&&this.ws.supports.binary?(this.supportsBinary=!0,this.ws.binaryType="nodebuffer"):this.ws.binaryType="arraybuffer",this.addEventListeners()}},n.prototype.addEventListeners=function(){var t=this;this.ws.onopen=function(){t.onOpen()},this.ws.onclose=function(){t.onClose()},this.ws.onmessage=function(e){t.onData(e.data)},this.ws.onerror=function(e){t.onError("websocket error",e)}},n.prototype.write=function(t){function e(){r.emit("flush"),setTimeout(function(){r.writable=!0,r.emit("drain")},0)}var r=this;this.writable=!1;for(var n=t.length,o=0,i=n;o<i;o++)!function(t){a.encodePacket(t,r.supportsBinary,function(o){if(!r.usingBrowserWebSocket){var i={};if(t.options&&(i.compress=t.options.compress),r.perMessageDeflate){var s="string"==typeof o?Buffer.byteLength(o):o.length;s<r.perMessageDeflate.threshold&&(i.compress=!1)}}try{r.usingBrowserWebSocket?r.ws.send(o):r.ws.send(o,i)}catch(t){}--n||e()})}(t[o])},n.prototype.onClose=function(){s.prototype.onClose.call(this)},n.prototype.doClose=function(){"undefined"!=typeof this.ws&&this.ws.close()},n.prototype.uri=function(){var t=this.query||{},e=this.secure?"wss":"ws",r="";this.port&&("wss"===e&&443!==Number(this.port)||"ws"===e&&80!==Number(this.port))&&(r=":"+this.port),this.timestampRequests&&(t[this.timestampParam]=h()),this.supportsBinary||(t.b64=1),t=c.encode(t),t.length&&(t="?"+t);var n=this.hostname.indexOf(":")!==-1;return e+"://"+(n?"["+this.hostname+"]":this.hostname)+r+this.path+t},n.prototype.check=function(){return!(!u||"__initialize"in u&&this.name===n.prototype.name)}},function(t,e){},function(t,e){var r=[].indexOf;t.exports=function(t,e){if(r)return t.indexOf(e);for(var n=0;n<t.length;++n)if(t[n]===e)return n;return-1}},function(t,e,r){"use strict";function n(t,e,r){this.io=t,this.nsp=e,this.json=this,this.ids=0,this.acks={},this.receiveBuffer=[],this.sendBuffer=[],this.connected=!1,this.disconnected=!0,this.flags={},r&&r.query&&(this.query=r.query),this.io.autoConnect&&this.open()}var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i=r(4),s=r(5),a=r(34),c=r(35),p=r(36),h=(r(3)("socket.io-client:socket"),r(26)),u=r(20);t.exports=e=n;var f={connect:1,connect_error:1,connect_timeout:1,connecting:1,disconnect:1,error:1,reconnect:1,reconnect_attempt:1,reconnect_failed:1,reconnect_error:1,reconnecting:1,ping:1,pong:1},l=s.prototype.emit;s(n.prototype),n.prototype.subEvents=function(){if(!this.subs){var t=this.io;this.subs=[c(t,"open",p(this,"onopen")),c(t,"packet",p(this,"onpacket")),c(t,"close",p(this,"onclose"))]}},n.prototype.open=n.prototype.connect=function(){return this.connected?this:(this.subEvents(),this.io.open(),"open"===this.io.readyState&&this.onopen(),this.emit("connecting"),this)},n.prototype.send=function(){var t=a(arguments);return t.unshift("message"),this.emit.apply(this,t),this},n.prototype.emit=function(t){if(f.hasOwnProperty(t))return l.apply(this,arguments),this;var e=a(arguments),r={type:(void 0!==this.flags.binary?this.flags.binary:u(e))?i.BINARY_EVENT:i.EVENT,data:e};return r.options={},r.options.compress=!this.flags||!1!==this.flags.compress,"function"==typeof e[e.length-1]&&(this.acks[this.ids]=e.pop(),r.id=this.ids++),this.connected?this.packet(r):this.sendBuffer.push(r),this.flags={},this},n.prototype.packet=function(t){t.nsp=this.nsp,this.io.packet(t)},n.prototype.onopen=function(){if("/"!==this.nsp)if(this.query){var t="object"===o(this.query)?h.encode(this.query):this.query;this.packet({type:i.CONNECT,query:t})}else this.packet({type:i.CONNECT})},n.prototype.onclose=function(t){this.connected=!1,this.disconnected=!0,delete this.id,this.emit("disconnect",t)},n.prototype.onpacket=function(t){var e=t.nsp===this.nsp,r=t.type===i.ERROR&&"/"===t.nsp;if(e||r)switch(t.type){case i.CONNECT:this.onconnect();break;case i.EVENT:this.onevent(t);break;case i.BINARY_EVENT:this.onevent(t);break;case i.ACK:this.onack(t);break;case i.BINARY_ACK:this.onack(t);break;case i.DISCONNECT:this.ondisconnect();break;case i.ERROR:this.emit("error",t.data)}},n.prototype.onevent=function(t){var e=t.data||[];null!=t.id&&e.push(this.ack(t.id)),this.connected?l.apply(this,e):this.receiveBuffer.push(e)},n.prototype.ack=function(t){var e=this,r=!1;return function(){if(!r){r=!0;var n=a(arguments);e.packet({type:u(n)?i.BINARY_ACK:i.ACK,id:t,data:n})}}},n.prototype.onack=function(t){var e=this.acks[t.id];"function"==typeof e&&(e.apply(this,t.data),delete this.acks[t.id])},n.prototype.onconnect=function(){this.connected=!0,this.disconnected=!1,this.emit("connect"),this.emitBuffered()},n.prototype.emitBuffered=function(){var t;for(t=0;t<this.receiveBuffer.length;t++)l.apply(this,this.receiveBuffer[t]);for(this.receiveBuffer=[],t=0;t<this.sendBuffer.length;t++)this.packet(this.sendBuffer[t]);this.sendBuffer=[]},n.prototype.ondisconnect=function(){this.destroy(),this.onclose("io server disconnect")},n.prototype.destroy=function(){if(this.subs){for(var t=0;t<this.subs.length;t++)this.subs[t].destroy();this.subs=null}this.io.destroy(this)},n.prototype.close=n.prototype.disconnect=function(){return this.connected&&this.packet({type:i.DISCONNECT}),this.destroy(),this.connected&&this.onclose("io client disconnect"),this},n.prototype.compress=function(t){return this.flags.compress=t,this},n.prototype.binary=function(t){return this.flags.binary=t,this}},function(t,e){function r(t,e){var r=[];e=e||0;for(var n=e||0;n<t.length;n++)r[n-e]=t[n];return r}t.exports=r},function(t,e){"use strict";function r(t,e,r){return t.on(e,r),{destroy:function(){t.removeListener(e,r)}}}t.exports=r},function(t,e){var r=[].slice;t.exports=function(t,e){if("string"==typeof e&&(e=t[e]),"function"!=typeof e)throw new Error("bind() requires a function");var n=r.call(arguments,2);return function(){return e.apply(t,n.concat(r.call(arguments)))}}},function(t,e){function r(t){t=t||{},this.ms=t.min||100,this.max=t.max||1e4,this.factor=t.factor||2,this.jitter=t.jitter>0&&t.jitter<=1?t.jitter:0,this.attempts=0}t.exports=r,r.prototype.duration=function(){var t=this.ms*Math.pow(this.factor,this.attempts++);if(this.jitter){var e=Math.random(),r=Math.floor(e*this.jitter*t);t=0==(1&Math.floor(10*e))?t-r:t+r}return 0|Math.min(t,this.max)},r.prototype.reset=function(){this.attempts=0},r.prototype.setMin=function(t){this.ms=t},r.prototype.setMax=function(t){this.max=t},r.prototype.setJitter=function(t){this.jitter=t}}])});
//# sourceMappingURL=socket.io.slim.js.map

text = "%c  Socket.io is loaded 2.3.0";
console.log(text, 'background: #3b3b3b; color: #22ab3b');

})();